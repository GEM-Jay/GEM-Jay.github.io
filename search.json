[{"title":"关于Waline部署在Vercel上无法正常加载的解决方案","path":"/posts/3352780266/","content":"问题描述在博客的搭建基本完成的时候，我发现Waline的评论框无法正常加载。 我的Waline是在Vercel上托管部署的。默认的情况下，Waline是无法正常加载的，因为vercel.app的域名在国内已经被DNS污染了。 那么同理，如果你是直接把自己的博客平台都部署在Vercel上，也会出现无法正常加载的情况。解决方案也是类似的，接下来来介绍一下如何操作。 解决方法前提： 1、你已经拥有了自己的博客并且已经为它申请了域名，申请域名的过程就不再赘述了。 2、按步骤开通了walinee所需的环境（leancloud、vercel那些），这里我默认你已经搭建好，如果还不会，请参照官方文档进行操作。 添加新的域名解析登录你的域名解析商的后台，找到你的域名记录。 我使用的是腾讯云的域名解析，所以我在域名解析的页面找到我的域名记录，点击添加记录。 添加一个二级域名 比如我在腾讯云里的主机记录里增加了一个叫做 comment 并且 CNAME 解析记录指向了 cname.vercel-dns.com 。 如下图： 这样我就拥有了一个 comment.zargo.site 的子域名了。 修改Vercel的Domains信息在setting里找到Domains 让你原有的vercel上的Waline地址指向你设置的子域名上： Redeploy一下你的Waline项目 修改Hexo的配置文件我在修改完以上信息之后还是不能正常访问，随后我去到了我的博客的配置文件里，将waline配置文件的’serverURL’字段修改成了’comment.zargo.site’ 现在问题真正解决了！ 问题解决后随想这样就可以正常访问了。但是我心中对DNS污染的相关疑惑还没有解决。 下面查阅了一些资料： DNS污染是一种网络攻击，攻击者通过向域名系统（DNS）服务器注入错误的解析记录，导致用户访问到错误的IP地址。这种攻击通常用于干扰正常的网络通信、窃取信息或将用户重定向到恶意网站。 简单来说，当用户尝试访问某个网站时，DNS会将域名转换为对应的IP地址。如果DNS被污染，用户可能会被导向一个假的或恶意的地址，而不是他们想要访问的真实网站。这种方式可以被用来进行网络钓鱼或其他类型的网络攻击。 在现代互联网中，DNS污染已经成为一个严重的问题。一些国家和组织已经采取了措施来防止DNS污染，例如使用DNSSEC（DNS安全扩展）来验证DNS记录的真实性。然而，DNS污染仍然是一个持续的问题，需要采取措施来保护用户的隐私和安全。"},{"title":"Github仓库里文件有白色箭头但是打不开问题（已解决）","path":"/posts/2535023956/","content":"问题描述今天在检查之前git进远程仓库的代码时，发现有一个文件有白色箭头，但是点击后无法打开。 通过查询文档，发现了问题所在。在此记录。 原因箭头可能意味着这是一个子模块 子模块的意思: 有一个指向另一个git版本控制项目&#x2F;储存库提交的链接。 我是用的别人的Hexo主题，他的代码是包含”.git”文件夹和”.gitignore”文件，属于子模块，所以会出现箭头。 解决方法！！！在进行所有操作前一定要对目标文件夹进行备份！！！ 出现了问题可以及时回滚，就不怕操作出问题导致项目文件丢失了。这很重要！ 在git bash中输入 1234567891011121314git pull #先拉取远程仓库代码下来#删除子文件夹里面.git文件,我这里是删除了&quot;blog/themes&quot;文件夹里面的.git文件和gitignore文件git rm -cached + 文件夹路径 #删除缓存，我是建议打不开的文件夹全部删掉,注意文件夹的名字需要写清楚路径，我这里用的是&quot;blog/themes&quot;#如果遇到删不掉的情况使用命令：rm -rf + 文件夹路径#然后重新推到远程仓库git add --allgit commit -m &#x27;备注&#x27; git push &lt;remote_repository_name&gt; &lt;branch_name&gt; 在处理期间由于看了别人的解决办法都是使用 “git add .” 命令，一直失败，文件还是带箭头的打不开，后来发现正是提交到缓存区的命令出问题了，应该使用 “git add –all” 命令。 “git add .”命令并不会记录你在工作目录里的删除操作，也就是你删除的文件记录并不会被提交到缓存区，所以你还是会把在本地删掉的git文件传上去，那不是等于没有删除吗。 “git add –all”命令则会记录你在工作目录里的所有操作，包括删除操作。再次上传之后就完成了。"},{"title":"博客部署SSL证书教程，带你搞懂HTTPS","path":"/posts/1527092412/","content":"前言最近在做自己的博客，发现部署在自己的服务器上后，是HTTP协议的站点，作为小白，查询了很多文件和资料，成功将HTTP的站点变更为了HTTPS。 不过在这背后，关于HTTPS的相关知识我想能够全部记录下来，本文整合了自己在学习过程中查询到的资料，希望能够帮助到大家。 需要查看如何在Nignx上部署SSL证书的可以直接跳转在Nignx上部署SSL证书。 本文尝试从 HTTP 开始，一步一步深入到 HTTPS，告诉你 HTTPS 到底是什么、为什么需要 HTTPS、以及 HTTPS 到底是怎么做的。相信你在阅读完本文后，一定会对 HTTPS 有深入的了解。 好了，废话不多说，直接进入正题吧。 什么是 HTTPS ?一句话，HTTPS &#x3D; HTTP + SSL。HTTPS 并不是一个全新的协议，而是在 HTTP 的基础上，通过 SSL 增加了一层加密协议，从而大大增加了 HTTP 协议的安全性。 所以在正式了解 HTTPS 之前，我们需要先了解 HTTP。 1.HTTPHTTP 全称 超文本传输协议（HyperText Transfer Protocol），是一种广泛用于互联网中浏览器与服务器之间的应用层传输协议。简单来说，浏览器向服务器发送 HTTP 请求，服务器向浏览器返回 HTTP 响应，两者之间通过这种方式进行“交流”，来使得我们的浏览器可以正常从服务器端获取数据，并展示在用户的电脑屏幕上. 以访问 http://httpbin.org 网址为例，一个典型的 HTTP 请求如下所示： 12345678910GET / HTTP/1.1Accept: text/html,...Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cache-Control: no-cacheConnection: keep-aliveHost: httpbin.orgPragma: no-cacheUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Safari/537.366 GET 表示请求方法，常见的 HTTP 请求方法有 GET、POST、PUT、DELETE 等… GET 后面的 &#x2F;表示请求路径，这里我们访问的根路径，所以显示为 &#x2F;。如果你访问 httpbin.org&#x2F;get 的话，这里显示的就是 &#x2F;get了 HTTP&#x2F;1.1 表示使用的 HTTP 协议版本，现在常用的有 HTTP&#x2F;1.1 和 HTTP&#x2F;2，当然还有更先进的 HTTP&#x2F;3，这里就不过多展开了 下面的 9 行全部都是 HTTP header，每一个 header 包含 name 和 value，之间用冒号分隔开。 一个典型的 HTTP 响应如下所示 12345678910HTTP/1.1 200 OKDate: Sat, 08 Apr 2023 16:28:43 GMTContent-Type: text/html; charset=utf-8Content-Length: 9593Connection: keep-aliveServer: gunicorn/19.9.0Access-Control-Allow-Origin: *Access-Control-Allow-Credentials: truebody... HTTP&#x2F;1.1 指的协议版本，响应和请求的协议版本是一致的 200 OK 代表返回的响应码，表示这个响应是符合预期的。另外还有非常常见的返回码 404 NOT FOUND ，大家应该或多或少听说过，它表示服务器告诉你你访问的这个资源不存在 后面 7 行全部是 HTTP header，同样每一个 header 包含 name 和 value，之间用冒号分隔开。 最后是 HTTP Body，也就是响应体，即服务器返回给你的内容主体，浏览器正是根据响应体来渲染页面的 由于本文重点不在 HTTP，这里不再详细介绍各个部分的作用 2.为什么需要HTTPS我们知道，HTTP （除了最新的 HTTP&#x2F;3 外），传输层是基于 TCP 协议的。TCP 建立连接时，有三次握手。三次握手完毕之后，TCP 连接就顺利建立了，接下来两端将会传输数据。 对于普通的 HTTP 协议，在建立完 TCP 连接之后，就直接开始传输数据了，这时候数据是明文传输的，这也是 HTTP 最不安全的地方。 明文传输是什么概念呢？ 我们知道，浏览器和服务器之间，是存在很长一条路线的，你在家里通过浏览器访问网页的时候，数据会从你的电脑，传到你家里的路由器，再到光猫，到运营商，到互联网…直到最后才到服务器。在明文传输下，理论上来讲，浏览器和服务器之间的任一节点，包括你家里的路由器、包括你购买宽带&#x2F;流量的运营商，都可以“窃听”你们的数据，甚至还可以修改数据。 听起来不够直观？ 打个比方，近代时期，战场上打仗时，部队之间会通过电台进行交流。如果通过明文进行交流，那么非常危险，敌军可以打开电台进行窃听，偷取你的军事情报，这样的事也屡见不鲜了…那么他们是如何解决这个问题的呢？ 两个部队之间提前约定一个加密的方案，在传数据之前，先把它进行加密再传输，另一端收到数据之后，按照事先约定的方案进行解密，然后读取就可以了。这样即使敌军开始窃听，也只能听到加密后的情报，如果无法对其破解的话，得不到任何有效信息。 没错，这就是 HTTPS 的思想，浏览器在发送 HTTP 请求之前，先通过某种方式对其进行加密，然后再进行传输。服务器端收到数据之后，对其解密，读取真实内容，生成 HTTP 响应，同样对响应进行加密，然后传回给浏览器，浏览器收到数据之后，对其进行解密，得到真正的 HTTP 响应。这样就可以保证数据在传输过程中的安全性，无论是路由器还是运营商，都没有办法“窃听”你们的数据了。 说到这里，想必你已经知道 HTTPS 的一大作用了，它可以保证数据在互联网上传输的安全性，避免中间节点进行窃听和修改。 当然，聪明的你还可能会想到一些问题，例如： 战场上军队之间是提前约定好加密方案的，但是咱们任意一个浏览器都可以随时访问网页，没有办法提前约定加密方案呀，那是怎么做到的呢？ 战场上经常出现敌军对另一方部队之间的电台加密进行破解的事情，破解完成之后，还是能够窃听到数据，那 HTTPS 的这个加密方案到底安全吗，会被破解吗？ 这些问题，你都可以在本文中得到答案。 3. HTTP + SSL &#x3D; HTTPS ！上面提到了对 HTTP 进行加密的思想。在 HTTPS 的具体实现中，这个加密方案即是大名鼎鼎的 SSL（Secure Sockets Layer）。 定义：SSL（Secure Sockets Layer）是一种安全协议，用于在互联网上保护数据的传输安全。它工作在传输层，主要功能是通过加密技术，保护不同计算机之间的数据传输过程，防止敏感数据被黑客窃取和篡改。SSL 协议可以用于保护网站的用户登录、信用卡支付、网上银行等敏感信息的传输，以及企业之间的机密数据的传输。SSL 协议目前已经被继承为 TLS（Transport Layer Security），是一种安全性更高的传输层协议。所以，下面我将统一以 TLS 为名称进行讲解。 首先，划重点，TLS 中有 Transport Layer，顾名思义，它一定是工作在传输层了。上面提到过，HTTP 是应用层协议，传输层和应用层的概念，想必大家应该知道吧，计算机网络的事实标准中，自顶向下可以分为五层：应用层、传输层、网络层、链路层、物理层…这是《计算机网络》的基础，这里不过多展开，不熟悉的同学，要回去重修一下课程了。 我们知道，TCP 协议里有三次握手，三次握手成功后连接才算建立，接下来才会真正开始传输数据。传统的 HTTP 协议中，三次握手成功之后，就会直接开始明文传输 HTTP 数据了。 那么 TLS 是什么时候开始发挥作用的呢？答案很简单，在三次握手之后，传输数据之前。 也就是说，在 TCP 协议中加入 TLS 之后，三次握手成功之后就不会再立刻开始传输数据了，而是紧接着开始 TLS 的建立过程，也被称为 TLS 握手。 TLS 握手是干嘛呢？或者说为什么需要 TLS 握手呢？上面提到，在战场上，两个部队之间会提前约定好加密的方案，例如面对面用纸互相写下加密方案，然后在一段时间之内的电台通信统一用这个加密方案，这样能一定程度上保证电台通信的安全性。但是 TLS 中我们并没有这样一个“面对面”的机会，咱们总不可能在访问网页之前，人肉跑到服务器的维护者那边去跟他约定加密方案吧。出于这个目的，TLS 握手便出现了。所以我们可以说，TLS 握手的目的是给通信双方约定一个安全的加密方案（可以理解为商量一个只有双方知道的加密密钥）。 知道了 TLS 握手的目的，接下来我们需要知道它具体是怎么做的。首先，我们肯定不能直接明文传输加密方案（密钥），不然这个密钥在传输过程中就直接被第三方获取了，那么加密将没有任何意义。也就是说，TLS 握手需要做到：通信双方可以约定一个共同的加密方案（密钥），并且这个约定的过程（即 TLS 握手过程），即使被任何第三方窃听到，也无法解析出这个加密方案（密钥）。 是不是听起来很神奇，那到底是怎么做到的呢？这就不得不提到密码学中非常经典的两个概念：对称加密和非对称加密。 4.对称加密，非对称加密 对称加密是 TLS 握手成功后，通信双方之间采用的数据加密方案。现在的主要问题是：通信双方如何安全的商量好这个对称密钥，防止密钥被其他人窃取？ 这时就需要轮到非对称加密出场了。什么是非对称加密呢？与对称加密不同，非对称加密方案中，用户手握两把密钥，一把称为公钥，一把称为私钥，其中公&#x2F;私钥都可以用来加密&#x2F;解密数据，但是：用公钥加密后的数据，只有用私钥才能将其解开；用私钥加密后的数据，只有用公钥才能将其解开！ 这里只介绍了非对称加密的特点，并没有介绍其原理，因为这属于密码学的范畴了，展开来讲又是一篇文章。简单说说其思想吧，目前流行的非对称加密算法 RSA 基于的原理其实就一句话：我们目前还没有很好的办法对一个很大的数做因式分解，例如你在心里默默想一个很大的质数 p 和 质数 q，算出其乘积 n，那么向外公开 n 的话，外部人员是很难找出 p 和 q 的（只能暴力尝试，而当这样的数够大够多的时候，以现在的计算机算力也需要几百上千年的时间才能破解了）。对密码学感兴趣的同学，可自行进一步了解。 有了非对称加密，事情就变得有意思起来了。见下图，服务器端用非对称加密方案生成一对公&#x2F;私钥，私钥掌握在自己手里，谁也不告诉；在 TLS 握手的过程中，服务器将自己的公钥交给浏览器端，浏览器端在心里默默想出一个对称加密的密钥后，将这个密钥用服务器端的公钥进行加密，然后再传回给浏览器端；浏览器端收到这个数据之后，用自己的私钥将其进行解密，就能够得到刚才浏览器心里默念的那个对称密钥了。这样这个问题就完美的解决了，两边可以心有灵犀的拿到这个对称密钥，而不用担心被任何第三方窃取到了。 这就是 TLS 握手的过程吗？不，当然没这么简单了，我们还没有考虑一个非常巧妙的攻击手段：中间人攻击。 5.中间人攻击 假设现在我们从电脑上访问百度，如果有一个中间人在我的路由器端，或者运营商端，或者任何一个中间节点上截取了我的请求，刚不是提到服务器端需要返回给我们公钥吗，中间人他自己也生成一套公&#x2F;私钥，然后将自己的公钥返回给我，这样我就与中间人之间建立了一条我以为“安全”的连接了，此时我以为我连接的是百度服务器，其实我连接的是中间人…那么此时中间人可以做任何事情了，如果他人品比较好的话，他可以默默当一个代理，我要访问百度，他就去帮我访问百度，然后把结果返回给我，勤勤恳恳做一个“中间商”。当然，我们知道做这种攻击的人人品往往不会太好，所以他们可以做更坏的事情，例如伪造一个银行网页返回给我，让我填写账号和密码，这样的话…后果就不堪设想了。 那么如何防止中间人攻击呢？其中的核心就是：我们需要保证我们访问的就是目标服务器，例如，当我们访问百度时，我们需要确保在 TLS 握手时，给我们公钥的人就是百度，而不是任何其他人。 那么这个应该如何去保证呢？这就不得不提到接下来的几个概念了，数字证书，以及证书权威机构（Certificate Authority，简称 CA）。 6.数字证书、CA数字证书是由证书权威机构（CA）颁发的一个用于证明身份的证书，当然其中还包含了该用户的公钥等信息。例如还是以百度为例，假设百度需要给 www.baidu.com 这个域名申请一个数字证书，他需要在生成公钥&#x2F;私钥后，将自身的信息（包括域名、公司名称、公钥信息等）发给某个证书权威机构（CA），让 CA 给自己颁发一个数字证书。CA 需要验证百度的真实身份，并且他确实拥有 www.baidu.com 这个域名，一切都验证通过后，CA 才会给百度颁发这么一个数字证书。那么之后，不管是谁用浏览器访问 www.baidu.com 的时候，百度都会将刚才那个 CA 颁发的数字证书发送给用户，既可以用来自证身份，同时还顺便告诉了用户自己的公钥。 到这里你可能还会有几个疑问： 数字证书如何保证不能伪造呢，难道中间人不能伪造一个数字证书发送给用户吗？即使数字证书不能被伪造，从概念上看他是公开的，难道中间人不能直接把这个证书颁发给用户吗？ 下面会一一回答这几个问题。正式回答之前，先来看看数字证书里究竟有哪些内容。 既然上面提到百度，我们就以百度为例，我们使用浏览器访问百度，可以在地址栏左边看到一个小锁，点击后，就可以查看百度的数字证书 图中可以看到该证书的一些基本信息： 颁发对象：这个证书是颁发给百度的，并且只对域名 (www.)baidu.com 有效 颁发者：这个证书是由 GlobalSign 颁发的。（GlobalSign是一家全球知名的证书权威机构） 有效期：这个证书的有效期是从 2022 年 7 月到 2023 年 8 月。（一旦过期，证书将不被信任） 指纹：指纹是整张证书经过哈希计算后得到的特征值，主要与后面会提到的签名一起工作，起到防篡改的作用 当然，一张数字证书的内容远远不止于此，例如还包含了服务器的公钥，可以在“详细信息”中进行查看。 下面我们在证书详细信息中点击“导出”，将证书导出为 Base64 编码的单一证书，然后使用 openssl 对其进行解析和查看 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253$ openssl x509 -noout -text -in baidu.com.cerCertificate: Data: Version: 3 (0x2) Serial Number: 44:17:ce:86:ef:82:ec:69:21:cc:6f:68 Signature Algorithm: sha256WithRSAEncryption Issuer: C=BE, O=GlobalSign nv-sa, CN=GlobalSign RSA OV SSL CA 2018 Validity Not Before: Jul 5 05:16:02 2022 GMT Not After : Aug 6 05:16:01 2023 GMT Subject: C=CN, ST=beijing, L=beijing, OU=service operation department, O=Beijing Baidu Netcom Science Technology Co., Ltd, CN=baidu.com Subject Public Key Info: Public Key Algorithm: rsaEncryption RSA Public-Key: (2048 bit) Modulus: 00:aa:2f:cc:41:8d:25:ae:83:e9:f4:27:c4:00:b3: 39:6f:0e:98:2a:55:7d:07:e5:80:49:82:fa:d3:d3: 85:98:b5:df:7b:6f:bb:02:dd:ed:78:e4:0c:07:2b: 9e:1e:86:4b:f6:6a:86:58:d7:57:6f:21:59:11:d8: 6f:96:6e:d2:de:36:28:f6:b4:e3:ce:95:32:29:00: c1:65:8e:69:b0:00:fe:52:37:f4:88:3f:8b:6d:0f: bb:f0:ec:c5:c0:31:ef:ad:b5:0c:06:66:ad:be:dc: 43:13:c4:66:b0:5d:cf:56:53:e2:d1:96:82:1c:06: bb:9b:5f:ed:60:8d:d2:ed:f3:d2:50:ee:bb:cd:b2: 36:97:c8:ce:7b:d2:4b:b7:5c:b4:88:ca:37:6e:8b: ce:f9:96:fd:b4:f5:47:b5:20:77:bb:fc:a8:9d:81: b2:6c:f8:c7:09:6a:dd:22:6e:83:3f:a7:53:df:f1: da:2f:29:6b:22:c3:e9:1d:65:e8:c5:a0:ba:13:4e: 16:3f:03:93:f0:a5:59:8a:1a:80:e8:27:7d:49:23: df:d1:f9:4b:97:b7:01:c4:19:f5:f1:c5:ff:91:33: d0:a1:74:c6:ee:d4:cf:f6:38:0c:ed:bd:5e:aa:44: fb:88:f7:7b:99:70:76:34:55:7e:55:d2:0f:9e:bf: 94:93 ... (中间省略） Signature Algorithm: sha256WithRSAEncryption 63:21:07:23:47:06:eb:b3:7c:77:6c:df:bc:55:12:b9:f1:5e: 6a:04:60:16:be:d0:0b:18:9c:94:0c:a8:82:08:25:0d:26:fb: dd:cb:fc:8c:27:d9:0c:fa:4a:b6:31:b6:67:f0:26:2c:0d:96: 96:39:65:3f:d9:a1:ee:de:9c:10:4d:54:e1:c8:d6:a9:0e:77: db:00:e2:37:e3:3f:b4:9c:31:4f:ac:74:d3:22:12:53:36:d0: ef:18:07:2d:8e:d0:e6:91:b2:6c:4a:5e:39:53:14:58:4e:d1: 50:04:c9:83:7e:0d:7b:15:96:87:11:d7:5d:4a:17:ac:aa:9f: 84:e3:a8:24:9d:d6:17:77:26:8c:9f:7a:7b:18:da:39:2f:77: f7:2b:c7:23:b8:97:6f:c3:d1:72:4c:7e:fc:c6:0d:cc:73:38: 19:81:fb:e7:c1:7a:e8:b9:1d:3a:05:dc:36:04:9b:f1:f0:e1: a6:47:a0:30:4f:55:90:6c:da:cf:9e:b2:76:12:11:a1:5c:b6: 61:8d:15:a4:68:65:9a:57:2f:7a:6e:a3:1f:f5:b4:92:5a:3c: df:71:0a:cd:57:d4:d0:15:36:7e:ba:d5:03:25:27:45:b4:60: cd:2e:02:c1:0f:0a:e7:41:6f:58:69:20:9e:ad:47:52:1a:b5: e6:e5:8d:1d 可以看到，除了上面 Chrome 里显示的一些基本信息外，证书里还包含了几个重要信息： 服务器端的公钥，即上面 RSA Public-Key 下面的那一长串数字，就是百度的公钥了。 签名，证明数字证书有效的关键信息。如果把数字证书类比成一张合同的话，我们知道合同需要老板签字才算有效，同样，数字证书是需要 CA 签名才算有效的，这里的一长串字符就是 CA 对该证书的“签名”了。 我们知道合同上的签名是靠笔迹鉴定来确认真伪的，很明显这一长串字符里没有笔迹，那它是如何保证该签名是 CA 颁发的，而不是被其他人伪造的呢？ 上面我们提到，每一张数字证书有一个指纹，是将整张证书经过哈希运算后得到的特征值。CA 作为权威机构，其本身也是有一对公钥&#x2F;私钥的，它在颁发数字证书的时候，会用自己的私钥对证书的指纹进行加密，生成的这段加密数据，就是该证书的签名了！那么我们浏览器是如何验证证书的真伪呢？我们只需要使用 CA 的公钥对签名进行解密，看看得到的值是不是跟证书的指纹是一样的，这样就 OK 了，只要是一样，说明这个证书一定是 CA 颁发的。 那么，又有问题来了：我们浏览器是从哪里拿到 CA 的公钥呢？总不能还是通过网络传输吧，这样就有“套娃”的中间人攻击风险了。所以啊，我们的浏览器或操作系统已经内置了世界权威的 CA 的数字证书（证书里就包含了其公钥）了，点击浏览器的 设置 -&gt; 隐私设置和安全性 -&gt; 安全 -&gt; 管理设备证书，可以查看当前系统内置的所有 CA 证书。 上图是我的电脑中内置的 CA 证书。刚刚提到了百度的数字证书是由 GlobalSign 颁发的，这里也可以验证，GlobalSign 是被我们的操作系统所信任的 CA，并且我们已经将它的证书内置在操作系统中了。因此现在我们可以认定说，这个证书是值得信任的，与我们建立连接的就是百度，不是别人。 你可能会想，如果中间人将百度真实的数字证书返回给我呢？中间人是没有百度的私钥的，所以当我们提取出证书中的公钥，并对心里想的密钥进行加密后，中间人是解不开这个密钥的，所以中间人无论如何也无法与我们建立连接。 好了，数字证书的内容已经全部讲述完毕了，最后回过头来复习下前面提到的两个问题： 数字证书如何保证自身不会被伪造？数字证书中有一段签名，该签名是 CA 使用其私钥对证书指纹进行加密后得到的值，我们浏览器使用 CA 的公钥对该签名进行解密后，与该证书的指纹进行对比，就可以知道证书是否被篡改或者伪造了。当然，这里要多提一嘴，我们作为客户端，需要保证自己的电脑里保存的都是值得信任的 CA 根证书，因为信任某 CA 就代表信任了该 CA 颁发的所有数字证书，如果有人&#x2F;软件想在你的电脑里安装来历不明的 CA 证书，那你就要保持警惕了…如果中间人直接把真实的数字证书返回给我，它能够成功与我建立连接吗？答案是不行的。这个问题其实比较简单，刚刚提到，服务器端除了公钥外，自身还保存有一份私钥的，而中间人是拿不到这个私钥的，因为它被服务器雪藏起来，不会发送到互联网中的…那么如果中间人用服务器的证书返回给用户，用户采用服务器的公钥对自身默念出来的对称密钥进行加密后，返回给中间人的时候，中间人就一脸懵逼了，因为这个密钥它解不开呀，它没有私钥的，所以这个问题就完美解决了。 7.TLS握手的具体过程 上图来自 www.ssl.com ，展示了整个握手流程，我用大白话解释一下： 客户端向服务器发送 Client Hello 信息，告知自己想要建立一条 TLS 连接，并告知自己支持的加密算法。 服务器向客户端发送一个 Server Hello 的回应，并选择一个加密算法，同时给客户端发送自己的数字证书（包含服务器的公钥）。 客户端验证服务器发来的数字证书，验证通过后，在心里默默想出一个 pre-master 密钥（预主密钥），然后使用服务器的公钥，将预主密钥进行加密后，发送给服务器。服务器用自己的私钥进行解密，得到预主密钥。 客户端和服务器都通过预主密钥，进行相同的计算后，得到后续通信时使用的对称加密密钥，称为 shared secret。 客户端和服务器端都分别用生成的 shared-secret 加密一段报文后，发送给对方，以验证对方能够成功收到信息并解密。 然后 TLS 就建立成功了，接下来双方都用这个 shared-secret 进行加密通信。 总结一下，HTTPS 的加密过程中其实既用到了非对称加密也用到了对称加密，其中握手过程使用的是非对称加密，主要目的是双方可以安全的协商一个统一的密钥，而真正的数据传输过程则使用的是对称加密，正是使用刚才商量的这个密钥。 你可能会问，为什么不全程使用非对称加密呢？因为对称加密效率更高，尤其是在大量数据的时候，对称加密比非对称加密整整快几个数量级，所以真正数据传输的过程选用了对称加密。 到这里，HTTPS 的原理就已经全部介绍完毕了。大家如果还有什么疑问，欢迎在评论区留言讨论。 总结最后，我们总结一下，HTTPS 解决了两个问题： 数据传输过程中的安全问题，因为它对数据进行了加密，只有浏览器和服务器可以对其进行解密。 浏览器对服务器的信任问题，数字证书以及其中的数字签名，保证了我们访问的就是我们想要访问的服务器，不可能被钓鱼网站欺骗，也不可能被中间人攻击所欺骗。 当然，保证以上安全的前提是我们的电脑本身没有被攻破，如果你的电脑被黑客攻击，装上了来历不明的根证书，那么 HTTPS 也不能保障你的安全了。 在Nignx上部署SSL证书介绍完了HTTPS的原理，我们来看看如何在Nginx上部署SSL证书。 首先你要去到你购买服务器的控制台，找到你的服务器，点击“管理”，然后点击“安全组”，在“入站规则”中添加一个“HTTPS”规则，端口号为443，协议为TCP，然后点击“保存”。 然后搜索“SSL证书”，找到“SSL证书”，点击“创建证书”，然后按照提示填写好信息，点击“确定”。 每个服务器供应商都会提供免费的SSL证书，你可以选择免费的证书，也可以选择付费的证书。 按流程添加DNS解析并等待证书生成即可。 证书生成后点击下载并解压到本地 解压文件后，将其中以.key和.crt结尾的文件打开并复制到Nginx的配置文件中。 我是用的是宝塔面板进行配置的，在“网站”中找到你的网站，点击“设置”–&gt;“SSL”，然后点击“上传证书”，将刚才复制的文件粘贴进去即可。 之后你就可以用HTTPS访问你的网站了!"},{"title":"Redis的数据类型","path":"/posts/1286363648/","content":"Redis 数据类型Redis 主要支持以下几种数据类型： string（字符串）: 基本的数据存储单元，可以存储字符串、整数或者浮点数。 **hash（哈希）:**一个键值对集合，可以存储多个字段。 **list（列表）:**一个简单的列表，可以存储一系列的字符串元素。 **set（集合）:**一个无序集合，可以存储不重复的字符串元素。 zset(sorted set：有序集合): 类似于集合，但是每个元素都有一个分数（score）与之关联。 位图（Bitmaps）：基于字符串类型，可以对每个位进行操作。 超日志（HyperLogLogs）：用于基数统计，可以估算集合中的唯一元素数量。 地理空间（Geospatial）：用于存储地理位置信息。 发布&#x2F;订阅（Pub&#x2F;Sub）：一种消息通信模式，允许客户端订阅消息通道，并接收发布到该通道的消息。 流（Streams）：用于消息队列和日志存储，支持消息的持久化和时间排序。 模块（Modules）：Redis 支持动态加载模块，可以扩展 Redis 的功能。 String（字符串）string 是 redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。 string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据，比如jpg图片或者序列化的对象。 string 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB。 常用命令 SET key value：设置键的值。 GET key：获取键的值。 INCR key：将键的值加 1。 DECR key：将键的值减 1。 APPEND key value：将值追加到键的值之后。 实例redis 127.0.0.1:6379&gt; SET runoob “菜鸟教程”OKredis 127.0.0.1:6379&gt; GET runoob“菜鸟教程” 在以上实例中我们使用了 Redis 的 SET 和 GET 命令。键为 runoob，对应的值为 菜鸟教程。 注意：一个键最大能存储 512MB。 Hash（哈希）Redis hash 是一个键值(key&#x3D;&gt;value)对集合，类似于一个小型的 NoSQL 数据库。 Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。 每个哈希最多可以存储 2^32 - 1 个键值对。 常用命令 HSET key field value：设置哈希表中字段的值。 HGET key field：获取哈希表中字段的值。 HGETALL key：获取哈希表中所有字段和值。 HDEL key field：删除哈希表中的一个或多个字段。 实例DEL runoob 用于删除前面测试用过的 key，不然会报错：(error) WRONGTYPE Operation against a key holding the wrong kind of value redis 127.0.0.1:6379&gt; DEL runoobredis 127.0.0.1:6379&gt; HMSET runoob field1 “Hello” field2 “World”“OK”redis 127.0.0.1:6379&gt; HGET runoob field1“Hello”redis 127.0.0.1:6379&gt; HGET runoob field2“World” 实例中我们使用了 Redis HMSET, HGET 命令，HMSET 设置了两个 field&#x3D;&gt;value 对, HGET 获取对应 field 对应的 value。 List（列表）Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。 列表最多可以存储 2^32 - 1 个元素。 常用命令 LPUSH key value：将值插入到列表头部。 RPUSH key value：将值插入到列表尾部。 LPOP key：移出并获取列表的第一个元素。 RPOP key：移出并获取列表的最后一个元素。 LRANGE key start stop：获取列表在指定范围内的元素。 实例redis 127.0.0.1:6379&gt; DEL runoobredis 127.0.0.1:6379&gt; lpush runoob redis(integer) 1redis 127.0.0.1:6379&gt; lpush runoob mongodb(integer) 2redis 127.0.0.1:6379&gt; lpush runoob rabbitmq(integer) 3redis 127.0.0.1:6379&gt; lrange runoob 0 101) “rabbitmq”2) “mongodb”3) “redis”redis 127.0.0.1:6379&gt; Set（集合）Redis 的 Set 是 string 类型的无序集合。 集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 常用命令 SADD key value：向集合添加一个或多个成员。 SREM key value：移除集合中的一个或多个成员。 SMEMBERS key：返回集合中的所有成员。 SISMEMBER key value：判断值是否是集合的成员。 sadd 命令添加一个 string 元素到 key 对应的 set 集合中，成功返回 1，如果元素已经在集合中返回 0。 sadd key member 实例redis 127.0.0.1:6379&gt; DEL runoobredis 127.0.0.1:6379&gt; sadd runoob redis(integer) 1redis 127.0.0.1:6379&gt; sadd runoob mongodb(integer) 1redis 127.0.0.1:6379&gt; sadd runoob rabbitmq(integer) 1redis 127.0.0.1:6379&gt; sadd runoob rabbitmq(integer) 0redis 127.0.0.1:6379&gt; smembers runoob 1) “redis”2) “rabbitmq”3) “mongodb” 注意：以上实例中 rabbitmq 添加了两次，但根据集合内元素的唯一性，第二次插入的元素将被忽略。 集合中最大的成员数为 232 - 1(4294967295, 每个集合可存储40多亿个成员)。 zset(sorted set：有序集合)Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。 不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。 zset的成员是唯一的,但分数(score)却可以重复。 常用命令 ZADD key score value：向有序集合添加一个或多个成员，或更新已存在成员的分数。 ZRANGE key start stop [WITHSCORES]：返回指定范围内的成员。 ZREM key value：移除有序集合中的一个或多个成员。 ZSCORE key value：返回有序集合中，成员的分数值。 zadd 命令添加元素到集合，元素在集合中存在则更新对应score zadd key score member 实例redis 127.0.0.1:6379&gt; DEL runoobredis 127.0.0.1:6379&gt; zadd runoob 0 redis(integer) 1redis 127.0.0.1:6379&gt; zadd runoob 0 mongodb(integer) 1redis 127.0.0.1:6379&gt; zadd runoob 0 rabbitmq(integer) 1redis 127.0.0.1:6379&gt; zadd runoob 0 rabbitmq(integer) 0redis 127.0.0.1:6379&gt; ZRANGEBYSCORE runoob 0 10001) “mongodb”2) “rabbitmq”3) “redis” 其他高级数据类似HyperLogLog 用于基数估计算法的数据结构。 常用于统计唯一值的近似值。 Bitmaps 位数组，可以对字符串进行位操作。 常用于实现布隆过滤器等位操作。 Geospatial Indexes 处理地理空间数据，支持地理空间索引和半径查询。 Streams* 日志数据类型，支持时间序列数据。 * 用于消息队列和实时数据处理。"},{"title":"Redis的安装","path":"/posts/590946299/","content":"Redis 安装Windows 下安装下载地址：https://github.com/tporadowski/redis/releases。 Redis 支持 32 位和 64 位。这个需要根据你系统平台的实际情况选择，这里我们下载 Redis-x64-xxx.zip压缩包到 C 盘，解压后，将文件夹重新命名为 redis。 打开文件夹，内容如下： 打开一个 cmd 窗口 使用 cd 命令切换目录到 C:\\redis 运行： redis-server.exe redis.windows.conf 如果想方便的话，可以把 redis 的路径加到系统的环境变量里，这样就省得再输路径了，后面的那个 redis.windows.conf 可以省略，如果省略，会启用默认的。输入之后，会显示如下界面： 这时候另启一个 cmd 窗口，原来的不要关闭，不然就无法访问服务端了。 切换到 redis 目录下运行: redis-cli.exe -h 127.0.0.1 -p 6379 设置键值对: set myKey abc 取出键值对: get myKey Linux 源码安装下载地址：http://redis.io/download，下载最新稳定版本。 本教程使用的最新文档版本为 2.8.17，下载并安装： # wget http://download.redis.io/releases/redis-6.0.8.tar.gz tar -xzvf redis-6.0.8.tar.gzcd redis-6.0.8make执行完 make 命令后，redis-6.0.8 的 src 目录下会出现编译后的 redis 服务程序 redis-server，还有用于测试的客户端程序 redis-cli： 下面启动 redis 服务： # cd src .&#x2F;redis-server注意这种方式启动 redis 使用的是默认配置。也可以通过启动参数告诉 redis 使用指定配置文件使用下面命令启动。 # cd src .&#x2F;redis-server ..&#x2F;redis.confredis.conf 是一个默认的配置文件。我们可以根据需要使用自己的配置文件。 启动 redis 服务进程后，就可以使用测试客户端程序 redis-cli 和 redis 服务交互了。 比如： # cd src .&#x2F;redis-cliredis&gt; set foo barOKredis&gt; get foo“bar” Ubuntu apt 命令安装在 Ubuntu 系统安装 Redis 可以使用以下命令: # sudo apt update sudo apt install redis-server启动 Redis# redis-server 查看 redis 是否启动？# redis-cli 以上命令将打开以下终端： redis 127.0.0.1:6379&gt; 127.0.0.1 是本机 IP ，6379 是 redis 服务端口。现在我们输入 PING 命令。 redis 127.0.0.1:6379&gt; pingPONG 以上说明我们已经成功安装了redis。"},{"title":"Redis从入门到入土","path":"/posts/3383901741/","content":"Redis入门到入土 学习Redis的重要性Remote Dictionary Server(Redis) 是一个由 Salvatore Sanfilippo 写的 key-value 存储系统，是跨平台的非关系型数据库。 Redis 是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存、分布式、可选持久性的键值对(Key-Value)存储数据库，并提供多种语言的 API。 Redis 通常被称为数据结构服务器，因为值（value）可以是字符串(String)、哈希(Hash)、列表(list)、集合(sets)和有序集合(sorted sets)等类型。 如今，大多数互联网公司都已经使用Redis中间件来优化他们的服务速度。那么Redis的重要信就不言而喻了。 Redis的简介Redis（Remote Dictionary Server）是一个开源的内存数据库，遵守 BSD 协议，它提供了一个高性能的键值（key-value）存储系统，常用于缓存、消息队列、会话存储等应用场景。 性能极高：Redis 以其极高的性能而著称，能够支持每秒数十万次的读写操作24。这使得Redis成为处理高并发请求的理想选择，尤其是在需要快速响应的场景中，如缓存、会话管理、排行榜等。 丰富的数据类型：Redis 不仅支持基本的键值存储，还提供了丰富的数据类型，包括字符串、列表、集合、哈希表、有序集合等。这些数据类型为开发者提供了灵活的数据操作能力，使得Redis可以适应各种不同的应用场景。 原子性操作：Redis 的所有操作都是原子性的，这意味着操作要么完全执行，要么完全不执行。这种特性对于确保数据的一致性和完整性至关重要，尤其是在高并发环境下处理事务时。 持久化：Redis 支持数据的持久化，可以将内存中的数据保存到磁盘中，以便在系统重启后恢复数据。这为 Redis 提供了数据安全性，确保数据不会因为系统故障而丢失。 支持发布&#x2F;订阅模式：Redis 内置了发布&#x2F;订阅模式（Pub&#x2F;Sub），允许客户端之间通过消息传递进行通信。这使得 Redis 可以作为消息队列和实时数据传输的平台。 单线程模型：尽管 Redis 是单线程的，但它通过高效的事件驱动模型来处理并发请求，确保了高性能和低延迟。单线程模型也简化了并发控制的复杂性。 主从复制：Redis 支持主从复制，可以通过从节点来备份数据或分担读请求，提高数据的可用性和系统的伸缩性。 应用场景广泛：Redis 被广泛应用于各种场景，包括但不限于缓存系统、会话存储、排行榜、实时分析、地理空间数据索引等。 社区支持：Redis 拥有一个活跃的开发者社区，提供了大量的文档、教程和第三方库，这为开发者提供了强大的支持和丰富的资源。 跨平台兼容性：Redis 可以在多种操作系统上运行，包括 Linux、macOS 和 Windows，这使得它能够在不同的技术栈中灵活部署。 Redis 与其他 key-value 存储有什么不同？Redis 与其他 key-value 存储系统的主要区别在于其提供了丰富的数据类型、高性能的读写能力、原子性操作、持久化机制、以及丰富的特性集。 以下是 Redis 的一些独特之处： 丰富的数据类型：Redis 不仅仅支持简单的 key-value 类型的数据，还提供了 list、set、zset（有序集合）、hash 等数据结构的存储。这些数据类型可以更好地满足特定的业务需求，使得 Redis 可以用于更广泛的应用场景。 高性能的读写能力：Redis 能读的速度是 110000次&#x2F;s，写的速度是 81000次&#x2F;s。这种高性能主要得益于 Redis 将数据存储在内存中，从而显著提高了数据的访问速度。 原子性操作：Redis 的所有操作都是原子性的，这意味着操作要么完全执行，要么完全不执行。这种特性对于确保数据的一致性和完整性非常重要。 持久化机制：Redis 支持数据的持久化，可以将内存中的数据保存在磁盘中，以便在系统重启后能够再次加载使用。这为 Redis 提供了数据安全性，确保数据不会因为系统故障而丢失。 丰富的特性集：Redis 还支持 publish&#x2F;subscribe（发布&#x2F;订阅）模式、通知、key 过期等高级特性。这些特性使得 Redis 可以用于消息队列、实时数据分析等复杂的应用场景。 主从复制和高可用性：Redis 支持 master-slave 模式的数据备份，提供了数据的备份和主从复制功能，增强了数据的可用性和容错性。 支持 Lua 脚本：Redis 支持使用 Lua 脚本来编写复杂的操作，这些脚本可以在服务器端执行，提供了更多的灵活性和强大的功能。 单线程模型：尽管 Redis 是单线程的，但它通过高效的事件驱动模型来处理并发请求，确保了高性能和低延迟。"},{"title":"Blog主题美化-sakura","path":"/posts/4114488392/","content":"sakura主题美化（本站作者前博客，已经不再使用）本站正在积极优化中，优化完成后将贴出心得优化参考链接： Mashiro.本站原作者 cungudafa.一个很厉害的小姐姐 hojun.从sakura主题魔改本站的大佬 感谢以上大佬代码的开源，枣糕也备受开源精神的感染 感谢在本站优化过程中为枣糕提供帮助的小伙伴： kang.我的好朋友兼本站优化指导 更新日志2021&#x2F;4&#x2F;24 23:58 关于-我？今日更新:“关于—我”下的botui BOTUI:一款自动回复文字、图片、视频的JS聊天机器人框架BotUI，可以自由设置多种选项、触发关键词、输入框等内容，聊天内容或范围也可以自由设置，回复内容可以是文字、图片（GIF亦可）、视频，我在博客中引用了此框架。 优化后图片:详情跳转至关于—我本次优化参考了cungudafa姐姐的教程教程链接修改了主目录\\source\\about\\index.md及sakura/js/botui.js, 具体修改内容参考cungudafa的教程链接 修改了各分类页的图片和内容框架，不过不是很满意，仍在施工中 2021&#x2F;4&#x2F;25 23:58 添加视频HEXO添加视频 添加了分类页的播放器 2021&#x2F;10&#x2F;17 22:26 给文字标题添加css动画博客搁置了好久了，今天来更新一下主题美化首先看看效果： 修改前 修改后 1.给文章标题添加css动画横线修改 themes\\Sakura\\layout\\_widget\\common-article.ejs编辑文章通用属性目录themes\\Sakura\\layout\\_widget\\common-article.ejs 找到如下部分在&lt;p class=&quot;entry-census&quot;&gt;前添加： 1&lt;span class=&quot;toppic-line&quot;&gt;&lt;/span&gt; 添加自定义CSS将添加到style.css里头的自定义 CSS 样式就好啦~直接复制下列代码粘贴到style.css 12345/*标题横线动画*/.single-center header.single-header .toppic-line&#123;position:relative;bottom:0;left:0;display:block;width:100%;height:2px;background-color:#fff;animation:lineWidth 2.5s;animation-fill-mode:forwards;&#125;@keyframes lineWidth&#123;0%&#123;width:0;&#125;100%&#123;width:100%;&#125;&#125; 2.给标题文字添加CSS动画这部分比较简单直接添加自定义css即可 添加自定义CSS 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/*标题动画*/.entry-title &#123;\t-moz-animation: fadeInUp 2s; -webkit-animation:fadeInUp 2s;\tanimation: fadeInUp 2s;&#125;@-moz-keyframes fadeInUp &#123;\t0% &#123; -moz-transform: translateY(200%); transform: translateY(200%); opacity: 0\t&#125;\t50% &#123; -moz-transform: translateY(200%); transform: translateY(200%); opacity: 0\t&#125;\t100% &#123; -moz-transform: translateY(0%); transform: translateY(0%); opacity: 1\t&#125;&#125;@-webkit-keyframes fadeInUp &#123;\t0% &#123; -webkit-transform: translateY(200%); transform: translateY(200%); opacity: 0\t&#125;\t50% &#123; -webkit-transform: translateY(200%); transform: translateY(200%); opacity: 0\t&#125;\t100% &#123; -webkit-transform: translateY(0%); transform: translateY(0%); opacity: 1\t&#125;&#125;@keyframes fadeInUp &#123;\t0% &#123; -moz-transform: translateY(200%); -ms-transform: translateY(200%); -webkit-transform: translateY(200%); transform: translateY(200%); opacity: 0\t&#125;\t50% &#123; -moz-transform: translateY(200%); -ms-transform: translateY(200%); -webkit-transform: translateY(200%); transform: translateY(200%); opacity: 0\t&#125;\t100% &#123; -moz-transform: translateY(0%); -ms-transform: translateY(0%); -webkit-transform: translateY(0%); transform: translateY(0%); opacity: 1\t&#125;&#125;"},{"title":"算法—贪婪算法之田忌赛马","path":"/posts/3615288770/","content":"贪婪算法之田忌赛马贪婪算法之田忌赛马【问题描述】中国古代的历史故事“田忌赛马”是为大家所熟知的。话说齐王和田忌又要赛马了，他们各派出N匹马，每场比赛，输的一方将要给赢的一方200两黄金，如果是平局的话，双方都不必拿出钱。现在每匹马的速度值是固定而且已知的，而齐王出马也不管田忌的出马顺序。请问田忌该如何安排自己的马去对抗齐王的马，才能赢取最多的钱？ 输入第一行为一个正整数n (n &lt;&#x3D; 2000) ，表示双方马的数量。第二行有N个整数表示田忌的马的速度。第三行的N个整数为齐王的马的速度。 输出仅有一行，为田忌赛马可能赢得的最多的钱，结果有可能为负。 输入示例392 83 7195 87 74 输出示例200 C语言的实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;stdio.h&gt;#define MAX 1000int t[MAX],w[MAX];void sort(int n,int t[])&#123;\tint i,j,temp;\tfor(i=1;i&lt;=n;i++) for(j=1;j&lt;=n-i;j++) &#123; if(t[j]&gt;t[j+1]) &#123; temp=t[j]; t[j]=t[j+1]; t[j+1]=temp; &#125; &#125;&#125;int main()&#123;\tint n;\tprintf(&quot;请输入双方赛马数量n:&quot;);\tscanf(&quot;%d&quot;,&amp;n);\tprintf(&quot;请录入田忌赛马速度:&quot;);\tfor(int i=1;i&lt;=n;i++)\t&#123; scanf(&quot;%d&quot;,&amp;t[i]);\t&#125;\tprintf(&quot;请录入齐王赛马速度:&quot;);\tfor(i=1;i&lt;=n;i++)\t&#123; scanf(&quot;%d&quot;,&amp;w[i]);\t&#125;\tsort(n,t);\tsort(n,w);\tint tj_min=1,tj_max=n,qw_min=1,qw_max=n,count=0,sum;\twhile(n--)\t&#123; if(t[tj_max]&gt;w[qw_max]) &#123; count++; tj_max--; qw_max--; &#125; else if(t[tj_max]&lt;w[qw_max]) &#123; count--; tj_min++; qw_max--; &#125; else &#123; if(t[tj_min]&gt;w[qw_min]) &#123; count++; tj_min++; qw_min++; &#125; else &#123; if(t[tj_min]&lt;w[qw_max]) count--; tj_min++; qw_max--; &#125; &#125;\t&#125;\tsum=count*200;\tprintf(&quot;最终田忌最多可以拿到%d的奖金 &quot;,sum);\treturn 0;&#125; 运行截图"},{"title":"算法—贪婪算法之背包问题","path":"/posts/3151518252/","content":"贪婪算法之背包问题算法描述设有编号为1、2、…、n的n个物品，它们的重量分别为w1、w2、…、wn，价值分别为v1、v2、…、vn，其中wi、vi（1≤i≤n）均为正数。 有一个背包可以携带的最大重量不超过W。求解目标：在不超过背包负重的前提下，使背包装入的总价值最大（即效益最大化），与0&#x2F;1背包问题的区别是，这里的每个物品可以取一部分装入背包。 C语言的实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;stdio.h&gt;#define MAX 101void sort(int n,float w[],float v[])&#123;\tint i,j;\tfloat temp1,temp2;\tfor(i=1;i&lt;=n;i++) for(j=1;j&lt;=n-i;j++) &#123; temp1=v[j]/w[j]; temp2=v[j+1]/w[j+1]; if(temp1&lt;temp2) &#123; float temp; temp=w[j]; w[j]=w[j+1]; w[j+1]=temp; temp=v[j]; v[j]=v[j+1]; v[j+1]=temp; &#125; &#125;&#125;int main()&#123;\tfloat p[MAX],w[MAX],v[MAX];\tint n;\tfloat M;\tprintf(&quot;请输入物品总数n和背包最大容纳重量M:&quot;);\tscanf(&quot;%d %f&quot;,&amp;n,&amp;M);\tfor(int i=1;i&lt;=n;i++)\t&#123; printf(&quot;请输入第%d件物品的重量和价值:&quot;,i); scanf(&quot;%f %f&quot;,&amp;w[i],&amp;v[i]);\t&#125;\tsort(n,w,v);\tfloat c=M;\tfor(i=1;i&lt;=n;i++)\t&#123; p[i]=0;\t&#125;\tfor(i=1;i&lt;=n;i++)\t&#123; if(c&gt;=w[i]) &#123; p[i]=1; c=c-w[i]; &#125; else &#123; p[i]=c/w[i]; break; &#125;\t&#125;\tfor(i=1;i&lt;=n;i++)\t&#123; printf(&quot;重量为%.0f,价值量为%.0f,的物品，放入的比例为%.2f &quot;,w[i],v[i],p[i]);\t&#125;\treturn 0;&#125; 运行截图"},{"title":"算法—动态规划算法求数塔问题","path":"/posts/213526926/","content":"动态规划算法求数塔问题算法描述【实验目的】1.掌握动态算法的思想和求解问题的步骤；2.用动态规划算法策略求解数塔问题；3.用动态规划算法策略求解收获花生问题。 【实验内容】1．动态规划算法求解数塔问题 【问题描述】数塔问题有如下图所示的一个数塔，从顶部出发，在每一结点可以选择向左走或是向右走，一直走到底层，要求找出一条路径，使路径上的数值和最大。 【算法设计】给出算法设计思想，并用动态规划算法实现。 C语言的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;stdio.h&gt;#define MAX 1000int data[MAX][MAX];int dp[MAX][MAX];int n;void tower_walk()&#123;\tfor(int i=1;i&lt;=n;i++)\t&#123; dp[n][i]=data[n][i];\t&#125;\tint temp_max;\tfor(i=n;i&gt;=1;i--)\t&#123; for(int j=1;j&lt;=i;j++) &#123; if(dp[i+1][j]&gt;dp[i+1][j+1]) temp_max=dp[i+1][j]; else if(dp[i+1][j]&lt;dp[i+1][j+1]) temp_max=dp[i+1][j+1]; else temp_max=dp[i+1][j]; //\ttemp_max=max(dp[i+1][j],dp[i+1][j+1]); dp[i][j]=temp_max+data[i][j]; &#125;\t&#125;&#125;int\tprint_tower()&#123;\tprintf(&quot;最大路径和是:%d &quot;,dp[1][1]);\tint node_value;\tprintf(&quot;最大路径是:%d&quot;,data[1][1]);\tint j=1;\tfor(int i=2;i&lt;=n;i++)\t&#123; node_value=dp[i-1][j]-data[i-1][j]; if(node_value==dp[i][j+1]) ++j; printf(&quot;--&gt;%d&quot;,data[i][j]);\t&#125;\tprintf(&quot; &quot;);\treturn 0;&#125;int main()&#123;\tprintf(&quot;请输入塔的层数n:&quot;);\tscanf(&quot;%d&quot;,&amp;n);\tprintf(&quot;请输入塔每个节点的数据(第i层有i个节点): &quot;);\tfor(int i=1;i&lt;=n;i++)\t&#123; for(int j=1;j&lt;=i;j++) &#123; scanf(&quot;%d&quot;,&amp;data[i][j]); &#125;\t&#125;\ttower_walk();\tprint_tower();\treturn 0;&#125; 运行截图"},{"title":"算法—动态规划算法求收花生问题","path":"/posts/3835304321/","content":"动态规划算法求收花生问题算法描述【问题描述】收获花生问题咚咚想摘点花生送给她喜欢的米老鼠。她来到一片有网格状道路的矩形花生地(如下图)，从西北角进去，东南角出来。地里每个道路的交叉点上都有种着一株花生苗，上面有若干颗花生，经过一株花生苗就能摘走该它上面所有的花生。咚咚只能向东或向南走，不能向西或向北走。问咚咚最多能够摘到多少颗花生。 【输入】第一行是一个整数T，代表一共有多少组数据。1&lt;&#x3D;T &lt;&#x3D; 100接下来是T组数据。每组数据的第一行是两个整数，分别代表花生苗的行数R和列数 C ( 1&lt;&#x3D; R,C &lt;&#x3D;100)每组数据的接下来R行数据，从北向南依次描述每行花生苗的情况。每行数据有 C 个整数，按从西向东的顺序描述了该行每株花生苗上的花生数目 M ( 0&lt;&#x3D; M &lt;&#x3D; 1000)。 【输出】【样例输入】22 21 13 42 32 3 41 6 5【样例输出】816 对每组输入数据，输出一行，内容为能摘到得最多的花生颗数。 【问题分析】根据题意只能向东或者向南走，不能向西或向北走。所以这道题不用判断是不是访问过，直接选取最大的经过的数来代替，然后把最后一个数输出就大功告成了。以下是具体思路图片。 【算法设计】给出算法设计思想，并用动态规划算法实现。 C语言的实现123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;#define MAX 1000int w[MAX][MAX];int f[MAX][MAX];int t,n,m;int main()&#123;\tprintf(&quot;请输入数据组数t的值:&quot;); scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; printf(&quot;请输入行数n和列数m的值:&quot;); scanf(&quot;%d %d&quot;,&amp;n,&amp;m); printf(&quot;请输入每个节点上的花生数量 &quot;); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) scanf(&quot;%d&quot;,&amp;w[i][j]); for(i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++)&#123; if(f[i-1][j]&gt;f[i][j-1]) f[i][j] = f[i-1][j]+w[i][j]; else f[i][j] = f[i][j-1]+w[i][j]; &#125; printf(&quot;可以摘到的花生的总和的最大值是:%d &quot;,f[n][m]); &#125;\treturn 0;&#125; 运行截图"},{"title":"算法—动态规划算法求最长公共子序列问题","path":"/posts/2646402340/","content":"动态规划算法求最长公共子序列问题问题描述【问题描述】字符序列的子序列是指从给定字符序列中随意地（不一定连续）去掉若干个字符（可能一个也不去掉）后所形成的字符序列。给定两个字符序列A和B，如果字符序列Z既是A的子序列，又是B的子序列，则称序列Z是A和B的公共子序列。该问题是求两序列A和B的最长公共子序列（LCS）。【问题分析】dp[i][j]为子序列（a0，a1，…，ai-1）和（b0，b1，…，bj-1）的最长公共子序列的长度。对应的状态转移方程如下： C语言的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;stdio.h&gt;#include&lt;string.h&gt;char str1[100];char str2[100];int c[100][100]; int b[100][100];void print_LCS(int lenght1, int lenght2)&#123;\tif(lenght1 == 0 || lenght2 == 0)&#123; return; &#125;\tif(b[lenght1][lenght2] == 1)&#123; print_LCS(lenght1-1,lenght2-1); printf(&quot;%c&quot;,str1[lenght1-1]); &#125; else if(b[lenght1][lenght2] == 2)&#123; print_LCS(lenght1-1,lenght2); &#125;else&#123; print_LCS(lenght1,lenght2-1); &#125; &#125;void LCS(char str1[], char str2[])&#123; int str1_lenght, str2_lenght; str1_lenght = strlen(str1); str2_lenght = strlen(str2); if(str1_lenght == 0 || str2_lenght == 0)&#123; printf(&quot;%s &quot;, &quot;No sub seqence&quot;); return;\t&#125; int i, j;\tfor(i = 0; i &lt;= str1_lenght; i++)&#123; c[i][0] = 0;\t&#125; for(j = 0; j &lt;= str2_lenght; j++)&#123; c[0][j] = 0; &#125; for(i = 1; i &lt;= str1_lenght; i++)&#123; for(j = 1; j &lt;= str2_lenght; j++)&#123; if (str1[i-1] == str2[j-1])&#123; c[i][j] = c[i-1][j-1] + 1; b[i][j] = 1; &#125; else if(c[i-1][j] &gt; c[i][j-1])&#123; c[i][j] = c[i-1][j]; b[i][j] = 2; &#125; else&#123; c[i][j] = c[i][j-1]; b[i][j] = 3; &#125; &#125; &#125; if(c[str1_lenght][str2_lenght] &lt;= 0)&#123; printf(&quot;%s &quot;,&quot;No sub squence&quot;); return; &#125; printf(&quot;size = %d &quot;, c[str1_lenght][str2_lenght]); print_LCS(str1_lenght,str2_lenght); printf(&quot; &quot;);&#125;int main()&#123; printf(&quot;请输入第一个字符串:&quot;); scanf(&quot;%s&quot;, str1); printf(&quot;请输入第二个字符串:&quot;); scanf(&quot;%s&quot;, str2); LCS(str1,str2); return 0;&#125; 运行截图"},{"title":"算法—动态规划算法求最大子段和","path":"/posts/1148179130/","content":"动态规划算法求最大子段和问题描述【问题描述】给定由n个整数组成的序列a1,a2,…,an，求该序列子段和的最大值。当所有整数均为负值时定义其最大子段和为0。依此定义， 例如， 当(a1,a2, a3, a4, a5,a6)&#x3D;(-2, 11, -4, 13, -5, -2)时，最大子段和为20。【问题分析】 【算法设计】给出算法设计思想，并用动态规划算法实现。 C语言的实现1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;#define MAX 100int a[MAX]; int MaxSum(int a[],int n)&#123;\tint temp = 0;\tint maxsum = 0;\tfor(int i=1;i&lt;=n;i++)&#123; if(temp&lt;0) temp=a[i]; else temp=temp+a[i]; if(temp &gt; maxsum)&#123; maxsum = temp; &#125;\t&#125;\treturn maxsum;\t&#125;int main()&#123;\tint n;\tprintf(&quot;请输入n的值:&quot;);\tscanf(&quot;%d&quot;,&amp;n);\tprintf(&quot;请依次输入元素:&quot;);\tfor(int i=1;i&lt;=n;i++)&#123; scanf(&quot;%d&quot;,&amp;a[i]);\t&#125;\tprintf(&quot;最大子段和为:%d &quot;,MaxSum(a,n)); return 0;&#125; 运行截图"},{"title":"算法—回溯法求解01背包问题","path":"/posts/4146540002/","content":"回溯法求解01背包问题算法描述【问题描述】有n个重量分别为{w1，w2，…，wn}的物品，它们的价值分别为{v1，v2，…，vn}，给定一个容量为W的背包。设计从这些物品中选取一部分物品放入该背包的方案，每个物品要么选中要么不选中，要求选中的物品不仅能够放到背包中，而且满足重量限制具有最大的价值。 C语言实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;stdio.h&gt;float w[100],p[100];int x1[100],x[100],m,n;float max=0,total=0;int knap(int i)&#123;\tint j;\tfloat sum=0;\tif(i==n+1)\t&#123; for(j=1;j&lt;=n;j++) sum=sum+x1[j]*p[j]; if(sum&gt;max) &#123; max=sum; for(j=1;j&lt;=n;j++) x[j]=x1[j]; &#125; return 0;\t&#125;\tx1[i]=0;\tknap(i+1);\tif(total+w[i]&lt;=m)\t&#123; x1[i]=1; total=total+w[i]; knap(i+1); x1[i]=0; total=total-w[i];\t&#125;\treturn 0;&#125;int main()&#123;\tint s=0,sum=0,i;\tprintf(&quot;请输入背包的总容量m和物品件数n的值:&quot;);\tscanf(&quot;%d %d&quot;,&amp;m,&amp;n);\tfor(i=1;i&lt;=n;i++)\t&#123; printf(&quot;请输入第%d件物品的重量和价值:&quot;,i); scanf(&quot;%f %f&quot;,&amp;w[i],&amp;p[i]); s+=w[i]; sum+=p[i];\t&#125;\tif(s&lt;=m)\t&#123; printf(&quot;%d %d&quot;,m,sum); printf(&quot;最大价值为%d&quot;,sum); return 0;\t&#125;\telse knap(1);\tfor(i=1;i&lt;=n;i++) printf(&quot;x%d=%d &quot;,i+1,x[i]);\tprintf(&quot;最大价值为%.2f&quot;, max);\treturn 0;&#125; 运行截图"},{"title":"算法—回溯法求解七巧板涂色问题","path":"/posts/4151911364/","content":"回溯法求解七巧板涂色问题算法描述【问题描述】有如图所示的七巧板，试编写一源程序如下，使用至多四种不同颜色对七巧板进行涂色(每块涂一种颜色)，要求相邻区域的颜色互不相同，打印输出所有可能的涂色方案。【问题分析】为了让算法能识别不同区域间的相邻关 系，我们把七巧板上每一个区域看成一个顶点若两个区域相邻，则相应的顶点间用一条边相连，这样该问题就转化为图一个图的搜索问题了。 C语言实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;int m, pointnum, edgenum, sum = 0;int Graph[100][100], x[100];void InPut() &#123; int pos1, pos2; printf(&quot;请输入点的个数和色数(p m)：&quot;); scanf(&quot;%d%d&quot;,&amp;pointnum,&amp;m); printf(&quot;请输入边的个数: &quot;); scanf(&quot;%d&quot;,&amp;edgenum); printf(&quot;输入边的起始点信息(起点 终点)： &quot;); for(int i = 1; i &lt;= edgenum; ++i) &#123; scanf(&quot;%d%d&quot;,&amp;pos1,&amp;pos2); Graph[pos1][pos2] = Graph[pos2][pos1] = 1; &#125;&#125;int IsOk(int i) &#123; for(int j = 1; j &lt; i; ++j) if(Graph[i][j] == 1 &amp;&amp; x[j] == x[i]) return 0; return 1;&#125;void BackTrack(int i) &#123; if(i &gt; pointnum) &#123; sum += 1; printf(&quot;方法 %d:&quot;,sum); for(int j = 1; j &lt;= pointnum; ++j) &#123; printf(&quot; %d&quot;,x[j]); &#125; printf(&quot; &quot;); &#125; else &#123; for(int j = 1; j &lt;= m; ++j) &#123; x[i] = j; if(IsOk(i)) BackTrack(i + 1); x[i] = 0; &#125; &#125;&#125;int main() &#123; InPut(); BackTrack(1); printf(&quot;一共有%d种绘色方案&quot;,sum);&#125; 运行截图"},{"title":"算法—矩阵最长滑翔路径","path":"/posts/2945491289/","content":"算法——矩阵最长滑翔路径算法描述【问题描述】在一个C行R列的矩阵M中，其元素M[i][j]可以滑翔到相邻的上下左右的四个元素中的一个(当然不能超出矩阵的边界)，当且仅当相邻的元素比它要小，因为只能从高处滑翔到低处，每滑翔到一个元素，路径长度加1，现在要求你编程计算该矩阵中最长的滑翔路径长度是多少。要求输入矩阵的行列数和各元素的值，计算输出该矩阵中最长的滑翔路径长度。并给出路径。【输入样例】5 51 2 3 4 516 17 18 19 615 24 25 20 714 23 22 21 813 12 11 10 9【输出样例】2525 24……1 C语言实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;stdio.h&gt;#include&lt;string.h&gt;int G[100][100],len[100][100],have[100][100];int n,m,mov[2][4]=&#123;0,0,1,-1,1,-1,0,0&#125;;bool bound(int p,int q) &#123; return p&gt;n||p&lt;1||q&gt;m||q&lt;1;&#125;int DFS(int p,int q)&#123; if(have[p][q]) return len[p][q]; int ans=1; for(int i=0;i&lt;4;i++) &#123; int np=p+mov[0][i],nq=q+mov[1][i]; if(bound(np,nq)) continue; if(G[p][q]&gt;G[np][nq])&#123; if(ans&gt;DFS(np,nq)+1) ans=ans; else &#123; ans=DFS(np,nq)+1; &#125; &#125; &#125; len[p][q]=ans; have[p][q]=1; return ans; &#125;int main()&#123;\tint i,j,maxi,maxj;\tprintf(&quot;请输入行列数(用空格分隔): &quot;); scanf(&quot;%d %d&quot;,&amp;n,&amp;m);\tG[0][0]=0;\tprintf(&quot;请输入矩阵的值: &quot;); for(i=1;i&lt;=n;i++) for(j=1;j&lt;=m;j++) &#123; scanf(&quot;%d&quot;,&amp;G[i][j]); have[i][j]=0; &#125; int ans=0; for(i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) &#123; len[i][j]=DFS(i,j); if(ans&gt;len[i][j]) ans=ans; else &#123; ans=len[i][j]; maxi=i; maxj=j; &#125; &#125; printf(&quot;最长滑翔长度是%d &quot;,ans);\tfor(i=ans;i&gt;1;i--) printf(&quot;%d-&quot;,i);\tprintf(&quot;1&quot;); return 0;&#125; 运行截图"},{"title":"Mysql基础命令","path":"/posts/4265605807/","content":"mysql基基础——常用命令一、MySQL——常用命令1、创建数据库（Create）12345678mysql&gt; create database db_name; -- 创建数据库mysql&gt; show databases; -- 显示所有的数据库mysql&gt; drop database db_name; -- 删除数据库mysql&gt; use db_name; -- 选择数据库mysql&gt; create table tb_name (字段名 varchar(20), 字段名 char(1)); -- 创建数据表模板mysql&gt; show tables; -- 显示数据表mysql&gt; desc tb_name； -- 显示表结构mysql&gt; drop table tb_name； -- 删除表 例如：创建学生表 1234567create table Student( Sno char(10) primary key, Sname char(20) unique, Ssex char(2), Sage smallint, Sdept char(20))； 2、插入数据（Insert）insert into 语句用于向表格中插入新的行: 1234/*第一种形式无需指定要插入数据的列名，只需提供被插入的值即可：*/mysql&gt; insert into tb_name values (value1,value2,value3,...);/*第二种形式需要指定列名及被插入的值：*/mysql&gt; insert into tb_name (column1,column2,column3,...) values (value1,value2,value3,...); 例如：插入数据 1234mysql&gt; insert into Student values ( 20180001,张三,男,20,CS）;mysql&gt; insert into Student values ( 20180002,李四,男,19,CS）;mysql&gt; insert into Student (Sno,Sname,Ssex,Sage,Sdept) values ( 20180003,王五,男,18,MA）;mysql&gt; insert into Student (Sno,Sname,Ssex,Sage,Sdept) values ( 20180004,赵六,男,20,IS）; 3、查询数据（Select）select语句除了可以查看数据库中的表格和视图的信息外,还可以查看 SQL Server的系统信息、复制、创建数据表。其查询功能强大，是SQL语言的灵魂语句，也是SQL中使用频率最高的语句。 基本select语句：一个基本的select语句可分解成三个部分：查找什么数据（select）、从哪里查找（from）、查找的条件是什么（where）。 select 语句的一般格式如下： 1234567select &lt;目标列表达式列表&gt;[into 新表名]from 表名或视图名[where &lt;条件&gt;][group by &lt;分组表达式&gt;][having &lt;条件&gt;][order by &lt;排序表达式&gt;[ASC|DESC]] (一)查询指定的列1.查询表中所有列在select语句指定列的位置上使用*号时，表示查询表的所有列。 1select * from tb_name 2.查询表中指定的列查询多列时，列名之间要用逗号隔开。 1select tb_name.&lt;字符型字段&gt;,&lt;字符型字段&gt;... from tb_name; 3.指定查询结果中的列标题通过指定列标题（也叫列别名）可使输出结果更容易被人理解。指定列标题时，可在列名之后使用AS子句；也可使用:列别名&#x3D;&lt;表达式&gt;的形式指定列标题。 AS子句的格式为：列名或计算表达式 [AS] 列标题 1select &lt;字符型字段&gt; as 列标题1,&lt;字符型字段&gt; as 列标题2, &lt;字符型字段&gt; as 列标题3 from bt_name； 4.查询经过计算的列（即表达式的值）使用select对列进行查询时，不仅可以直接以列的原始值作为结果，而且还可以将列值进行计算后所得值作为查询结果，即select子句可以查询表达式的值,表达式可由列名、常量及算术运算符组成。查询结果计算列显示“无列名”,一般要给计算列加列标题。其中：表达式中可以使用的运算符有：加+、减-、乘*、除&#x2F;、取余% 1select &lt;字符型字段&gt;,&lt;字符型字段&gt;,列标题 = &lt;字符型字段&gt; * n from tb_name； (二)选择行：选择表中的部分行或全部行作为查询的结果1select [all|distinct] [top n[percent]]&lt;目标列表达式列表&gt; from 表名 1. 消除查询结果中的重复行对于关系数据库来说，表中的每一行都必须是不同的(即无重复行)。但当对表进行查询时若只选择其中的某些列，查询结果中就可能会出现重复行。在select语句中使用distinct关键字可以消除结果集中的重复行 1select distinct &lt;字符型字段&gt;[,&lt;字符型字段&gt;,...] from tb_name； 2. 限制查询结果中的返回行数使用top选项可限制查询结果的返回行数，即返回指定个数的记录数。其中：n是一个正整数，表示返回查询结果集的前n行；若带percent关键字，则表示返回结果集的前n%行。 12celect top n from tb_name; /*查询前 n 的数据*/celect top n percent from tb_name; /*查询前 n% tb_name的数据*/ (三)查询满足条件的行: 用where子句实现条件查询通过where子句实现,该子句必须紧跟在From子句之后 1select [all|distinct] [top n[percent]]&lt;目标列表达式列表&gt; from 表名 where &lt;条件&gt;； 说明：在查询条件中可使用以下运算符或表达式运算符 运算符标识比较运算符 &lt;&#x3D;，&lt;，&#x3D;，&gt;，&gt;&#x3D;，!&#x3D;，&lt;&gt;，!&gt;，!&lt;范围运算符 between… and，not between… and列举运算符 in，not in模糊匹配运算符 like，not like空值运算符 is null，is not null逻辑运算符 and，or，not 1.使用比较运算符1select * from tb_name where &lt;字符型字段&gt; &gt;=n; 2.指定范围用于指定范围的关键字有两个：between…and和 not between…and。 1select * from tb_name where [not] between &lt;表达式1&gt; and &lt;表达式2&gt;; 其中：between关键字之后的是范围的下限（即低值）,and关键字之后的是范围的上限（即高值）用于查找字段值在（或不在）指定范围的行。 3.使用列举使用in关键字可以指定一个值的集合，集合中列出所有可能的值，当表达式的值与集合中的任一元素个匹配时，即返回true，否则返回false。 1select * from tb_name where &lt;字符型字段&gt; [not] in(值1,值2,...,值n); 4.使用通配符进行模糊查询可用like 子句进行字符串的模糊匹配查询，like子句将返回逻辑值（true或False）。like子句的格式： select * from tb_name where &lt;字符型字段&gt; [not] like &lt;匹配串&gt;；其含义是：查找指定字段值与匹配串相匹配的记录。匹配串中通常含有通配符%和_（下划线）。其中: %：代表任意长度（包括0）的字符串 5.使用null的查询当需要判定一个表达式的值是否为空值时，使用 is null关键字。当不使用not时，若表达式的值为空值，则返回true，否则返回false；当使用not时，结果刚好相反。 1select * from tb_name where &lt;字符型字段&gt; is [not] null; 6.多重条件查询(使用逻辑运算符)逻辑运算符and（与：两个条件都要满足）和or（或：满足其中一个条件即可）可用来联接多个查询条件。and的优先级高于or,但若使用括号可以改变优先级。 1select * from tb_name where &lt;字符型字段&gt; = &#x27;volues&#x27; and &lt;字符型字段&gt; &gt; n; (四)对查询结果排序order by子句可用于对查询结果按照一个或多个字段的值（或表达式的值）进行升序（ASC）或降序（DESC）排列，默认为升序。 1order by &#123;排序表达式[ASC|DESC]&#125;[,...n]； 其中：排序表达式既可以是单个的一个字段，也可以是由字段、函数、常量等组成的表达式，或一个正整数。模板：select * from tb_name order by &lt;排序表达式&gt; &lt;排序方法&gt;； (五)使用统计函数(又称集函数，聚合函数)在对表进行检索时，经常需要对结果进行计算或统计，T-SQL提供了一些统计函数（也称集函数或聚合函数），用来增强检索功能。统计函数用于计算表中的数据，即利用这些函数对一组数据进行计算，并返回单一的值。常用统计函数表 函数名 功能 AVG 求平均值 count 求记录个数，返回int类型整数 max 求最大值 min 求最小值 sum 求和 1. SUM和AVG功能：求指定的数值型表达式的和或平均值。 1select avg(&lt;字符型字段&gt;) as 平均数,sum(&lt;字符型字段&gt;) as 总数 from tb_name where &lt;字符型字段&gt; =&#x27;字符串&#x27;; 2. Max和Min功能：求指定表达式的最大值或最小值。 1select max(&lt;字符型字段&gt;) as 最大值,min(&lt;字符型字段&gt;) as 最小值 from tb_name; 3. count该函数有两种格式：count(_)和count([all]|[distinct] 字段名），为避免出错，查询记录个数一般使用count(_)，而查询某字段有几种取值用count(distinct 字段名）。 (1).count(*):功能：统计记录总数。 1select count(*) as 总数 from tb_name; (2).count([all]|[distinct] 字段名）功能：统计指定字段值不为空的记录个数，字段的数据类型可以是text、image、ntext、uniqueidentifier之外的任何类型。 1select count(&lt;字符型字段&gt;) as 总数 from tb_name; (六)对查询结果分组group by子句用于将查询结果表按某一列或多列值进行分组，列值相等的为一组，每组统计出一个结果。该子句常与统计函数一起使用进行分组统计。 1group by 分组字段[,...n][having &lt;条件表达式&gt;]； 1.在使用group by子句后select列表中只能包含：group by子句中所指定的分组字段及统计函数。 2.having子句的用法having子句必须与group by 子句配合使用，用于对分组后的结果进行筛选（筛选条件中常含有统计函数）。 3. 分组查询时不含统计函数的条件通常使用where子句；含有统计函数的条件,则只能用having子句。 1select &lt;字符型字段&gt;,count(*) as 列标题 from tb_name where &lt;字符型字段&gt;=&#x27;字符串&#x27; group by &lt;字符型字段&gt;； 4、修改数据(Update）Update 语句用于修改表中的数据。 1update tb_name set 列名称 = 新值 where 列名称 = 某值； 5、删除数据(Delete)删除单行 1delete from tb_name where 列名称 = 某值； 删除所有行可以在不删除表的情况下删除所有的行。这意味着表的结构、属性和索引都是完整的： 1delete * from tb_name 或 delete from tb_name； 二、MySQL——alter命令alter add命令用来增加表的字段。alter add命令格式：alter table 表名 add字段 类型 其他; 例如，在表MyClass中添加了一个字段passtest，类型为int(4)，默认值为0： 1mysql&gt; alter table MyClass add passtest int(4) default &#x27;0&#x27;; 添加两个字段 1mysql&gt; alter table Person add age int,add address varchar(11); 删除两个字段 1mysql&gt; alter table Person drop column age,drop column address; 修改字段的注释 1mysql&gt; alter table `student` modify column `id` comment &#x27;学号&#x27;; 1)加索引mysql&gt; alter table 表名 add index 索引名 (字段名1[，字段名2 …]); 1mysql&gt; alter table employee add index emp_name (name); 2)加主关键字的索引mysql&gt; alter table 表名 add primary key (字段名); 1mysql&gt; alter table employee add primary key(id); 3)加唯一限制条件的索引mysql&gt; alter table 表名 add unique 索引名 (字段名); 1mysql&gt; alter table employee add unique emp_name2(cardnumber); 4)删除某个索引mysql&gt; alter table 表名 drop index 索引名; 1mysql&gt;alter table employee drop index emp_name; 5)添加字段1mysql&gt; ALTER TABLE table_name ADD field_name field_type; 6)修改原字段名称及类型1mysql&gt; ALTER TABLE table_name CHANGE old_field_name new_field_name field_type; 7)删除字段1MySQL ALTER TABLE table_name DROP field_name; 三、MySQL – 应用学生-课程数据库 学生表：Student（Sno，Sname，Ssex，Sage，Sdept） 课程表：Course（Cno，Cname，Cpno，Ccredit） 学生选课表：SC（Sno，Cno，Grade） 关系的主码加下划线表示。各个表中的数据示例如图所示： 一、建立一个“学生”表Student1234567create table Student( Sno char(9) peimary key, /*列级完整性约束条件，Sno是主码*/ Sname char(20) unique, /* Sname取唯一值*/ Ssex char(2), Sage smallint, Sdept char(20)); 二、建立一个“课程”表Course1234567create table Course( Sno char(4) primary key, /*列级完整性约束条件，Cname不能取空值*/ Sname char(40) not null, /*Cpno的含义是先修课*/ Cpno char(4) Ccredit smallint, foreign key (Cpnoo) references Course(Cno) /*表级完整性约束条件，Cpno是外码，被参照表是Course，被参照列是Cno*/); 三、建立学生选课表SC12345678create table SC( Sno char(9), Cno char(4), Grade smallint, frimary key (Sno,Cno), /*主码由两个属性构成，必须作为表级完整性进行定义*/ foreign key (Sno) references Student(Sno), /*表级完整性约束条件，Sno是外码，被参照表是Student*/ foreign key (Cno) references Course(Cno) /*表级完整性约束条件，Cno是外码，被参照表是Course */); 本文转载于MySQL基础 — 常用命令"},{"title":"算法—加法接力赛","path":"/posts/2038932490/","content":"算法—加法接力赛算法描述【问题描述】正在上一年级的小卡卡最近开始学习数的加法运算，一天老师为了测试大家对加法的掌握情况，让同学们做了一个有趣的加法接力赛游戏。老师在黑板上从左到右写下了n个大于零的整数，老师接下来找出n个同学完成下面的计算任务。第一个同学在黑板上抄下最左边的数字，第二个同学负责将第一个同学写下的数字，加上老师写下的左边第二个数字所得到的数写在了黑板上。以此类推，第m个同学将前面第m-1个同学所写下的数字加上老师在黑板上写下的从左边数的第m个数字所得之和，并将结果写到黑板上。当计算完成这n个数字之后，老师又让同学从最右边开始按相同的方法再次计算出n个数值。最后老师让同学们找出这所有数字当中共有多少个是相同的。例如：老师在黑板上写下了7个数，从左到右依次为：3，6，2，1，4，5，2，则同学们第一次从左边开始计算所得到的7个数值应该是：3，9，11，12，16，21，23；而第二次从右边开始计算所得到的7个数值应该是：2，7，11，12，14，20，23；于是第一次与第二次计算出的数值中相同的有3个，它们分别是：11、12与23。【输入】共两行，第一行为n（1&lt;n&lt;100），第二行为n个数，用空格隔开， 每个数的大小在0～200之间。 【输出】第一次与第二次计算出的数值中相同的个数。【输入样例】73 6 2 1 4 5 2【输出样例】3 C语言的实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;stdio.h&gt;#define MAX 100int a[MAX],sum[MAX],sum1[MAX],same[MAX];int i,j,k,n,s,t;void try1()&#123;\tfor(i=1;i&lt;=n;i++) same[i]=0;\tfor(i=1;i&lt;=n;i++)&#123; for(j=1;j&lt;=n;j++)&#123; if(sum[i]==sum1[j]) same[i]=sum[i]; &#125;\t&#125;\tt=0;\tfor(i=1;i&lt;=n;i++)&#123; if(same[i]!=0)&#123; t++; printf(&quot;%d &quot;,same[i]); &#125;\t&#125;\tprintf(&quot; &quot;);\tprintf(&quot;共%d个数相同 &quot;,t);&#125;int main()&#123;\ta[0]=0;\tprintf(&quot;请输入数字总量n:&quot;);\tscanf(&quot;%d&quot;,&amp;n);\tprintf(&quot;请从左到右录入数字(以空格分隔):&quot;);\tfor(i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);\tprintf(&quot;第一次运行: &quot;);\ts=0;\tfor(i=0;i&lt;n;i++)&#123; sum[i+1]=s+a[i+1]; s=sum[i+1];\t&#125;\tfor(i=1;i&lt;=n;i++) printf(&quot;%d &quot;,sum[i]);\tprintf(&quot; 第二次运行: &quot;);\ts=0;\tfor(i=n;i&gt;0;i--)&#123; sum1[n-i+1]=s+a[i]; s=sum1[n-i+1];\t&#125;\tfor(i=1;i&lt;=n;i++) printf(&quot;%d &quot;,sum1[i]);\tprintf(&quot; &quot;);\ttry1();\treturn 0;&#125; 运行截图"},{"title":"算法—矩阵连乘","path":"/posts/502788320/","content":"算法—矩阵连乘算法描述【问题描述】给定n个矩阵{A1,A2,…,An}，其中Ai与Ai+1是可乘的，i&#x3D;1,2…,n-1。现在需要研究的问题是如何确定矩阵连乘积的计算次序，使得计算矩阵连乘所需的乘法次数最少。矩阵连乘问题满足结合律, 其计算次序可以用加括号的方式确定，若矩阵连乘已完全加括号，则其计算次序完全确定。例如，有四个矩阵A,B,C,D，它们的维数分别是：A&#x3D;50×10，B&#x3D;10×40, C&#x3D;40×30, D&#x3D;30×5。ABCD矩阵连乘共有五种完全加括号的方式，计算次序和乘法次数如下：(A((BC)D)) 16000 (A(B(CD))) 10500((AB)(CD)) 36000 (((AB)C)D) 87500((A(BC))D) 34500可见不同的计算次序会导致不同的计算代价，我们要做的就是让计算代价最小。【输入】第1行输入连乘矩阵的个数n，第2行依次输入连乘矩阵的大小。【输出】输出包括两行，第1行输出最小的计算量，第2行输出矩阵连乘完全加括号的形式。【输入样例1】450 10 40 30 5【输出样例1】1050(A1) 【输入样例2】35 6 3 4【输出样例2】150((A[1]A[2])A[3]) C语言实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;stdio.h&gt;int N;int p[100],m[100][100],s[100][100];int MatrixChain(int *p,int n)&#123; for(int i=1;i&lt;=n;i++) m[i][i]=0; for(int r=2;r&lt;=n;r++)&#123; for(int i=1;i&lt;=n-r+1;i++)&#123; int j=i+(r-1); m[i][j]=m[i][i]+m[i+1][j]+p[i-1]*p[i]*p[j]; s[i][j]=i; for(int k=i+1;k&lt;j;k++)&#123; int t=m[i][k]+m[k+1][j]+p[i-1]*p[k]*p[j]; if(t&lt;m[i][j])&#123; m[i][j]=t; s[i][j]=k; &#125; &#125; &#125; &#125;\treturn 0;&#125;void Traceback(int i,int j)&#123; if(i==j) &#123; printf(&quot;A%d&quot;,i); &#125; else &#123; printf(&quot;(&quot;); Traceback(i,s[i][j]); Traceback(s[i][j]+1,j); printf(&quot;)&quot;); &#125;&#125;int main()&#123;\tprintf(&quot;请输入矩阵数量:&quot;);\tscanf(&quot;%d&quot;,&amp;N);\tN=N+1;\tprintf(&quot;请输入各矩阵纬度(用空格分隔):&quot;);\tfor(int i=0;i&lt;N;i++) scanf(&quot;%d&quot;,&amp;p[i]);\tMatrixChain(p,N-1); Traceback(1,N-1);\tprintf(&quot; &quot;);\treturn 0;&#125; 运行截图运行截图示例1运行截图示例2"},{"title":"算法—马拦过河卒","path":"/posts/3422505860/","content":"算法—马拦过河卒算法描述【题目描述】棋盘上A点有一个过河卒，需要走到目标B点。卒行走的规则：可以向下、或者向右。同时在棋盘上的某一点有一个对方的马（如C点），该马所在的点和所有跳跃一步可达的点称为对方马的控制点，如图中的C点和P1，……，P8，卒不能通过对方马的控制点。棋盘用坐标表示，A点(0,0)、B点(n, m) (n,m为不超过20的整数),同样马的位置坐标是需要给出的，C≠A且C≠B。现在要求你计算出卒从A点能够到达B点的路径的条数。（假设马的位置是固定不动的，并不是卒走一步马走一步。）【输入】给出n、m和C点的坐标。【输出】从A点能够到达B点的路径的条数。【输入样例】8 6 0 4【输出样例】1617 C语言实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt; int mmp[20][20];int vis[20][20];int step;int ma[9][2]=&#123;0,0,1,2,1,-2,-1,2,-1,-2,2,1,2,-1,-2,1,-2,-1&#125;;int n,m;int b,c; void bfs(int x,int y)&#123; if(x==n&amp;&amp;y==m) step++; int next[2][2]=&#123;1,0,0,1&#125;; int i; int dx,dy; for(i=0;i&lt;2;i++) &#123; dx=x+next[i][1]; dy=y+next[i][0]; if(dx&lt;0||dx&gt;n||dy&lt;0||dy&gt;m) continue; if(!vis[dx][dy]&amp;&amp;mmp[dx][dy]==0) &#123; vis[dx][dy]=1; bfs(dx,dy); //回溯 vis[dx][dy]=0;\t//回溯前清场 &#125; &#125;&#125;int main()&#123; int i; int dx,dy;\tprintf(&quot;请输入目标B点坐标和马的坐标C:&quot;); scanf(&quot;%d %d %d %d&quot;,&amp;n,&amp;m,&amp;b,&amp;c) ; memset(vis,0,sizeof(vis)); memset(mmp,0,sizeof(mmp)); for(i=0;i&lt;=8;i++) &#123; dx=b+ma[i][0]; dy=c+ma[i][1]; if(dx&lt;0||dx&gt;n||dy&lt;0||dy&gt;m) continue; else mmp[dx][dy]=1; &#125; vis[0][0]=1; bfs(0,0);\tprintf(&quot;从A到B的路径数为:&quot;); printf(&quot;%d &quot;,step); return 0;&#125; 运行截图"},{"title":"算法—加密字符串相似度计算","path":"/posts/2083461370/","content":"加密字符串相似度计算算法描述【问题描述】现有4个加密的字符串(中间不含空格)，需要分析研究它们的相似度，两个字符串的相似度用其最长公共子系列的长度表示，例如，字符串“ABDECFG”和字符串“ADCGEFA”的一个最长公共子序列为 “ADEF”，所以这两个字符串的相似度为4。现在需要对输入的4个字符串，分别计算它们的相似度，找出相似度最高的一对字符串，若存在多对相似度最高的字符串，应全部输出。【输入】 分4行输入4个字符串。【输出】 按行依次输出相似度最高的一对字符串、它们的相似度、对应的最长公共子序列，若有多组最高相似度相同，应全部输出。【输入样例】ABDECFEBADCEBGHADCFEBBECEBFBD【输出样例】ABDECFEB ADCFEB 6 ADCFEB 输出样例说明：以上4个字符串，共可以构成6组，依次计算它们的相似度如果，因此，相似度最高的是字符串ABDECFEB和ADCFEB，相似度为6，对应的一个最长公共子序列为ADCFEB。ABDECFEB ADCEBGH 5 ADCEBABDECFEB ADCFEB 6 ADCFEBABDECFEB BECEBFBD 5 BECFBADCEBGH ADCFEB 5 ADCEBADCEBGH BECEBFBD 3 CEBADCFEB BECEBFBD 3 CFB C语言实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/*动态规划算法加递归时间复杂度为n方*/#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define MAXLEN 100char s[MAXLEN][MAXLEN];int len[MAXLEN],b[MAXLEN][MAXLEN],c[MAXLEN][MAXLEN];void LCSLength(char *x, char *y, int m, int n, int c[][MAXLEN], int b[][MAXLEN])&#123; int i, j; for (i=0; i&lt;=m;i++) c[i][0]=0; for (j=1; j&lt;=n;j++) c[0][j]=0; for (i=1;i&lt;=m;i++) for (j=1;j&lt;=n;j++) &#123;if (x[i-1]==y[j-1]) &#123;c[i][j]=c[i-1][j-1]+1; b[i][j]=0; &#125; else if(c[i-1][j]&gt;=c[i][j-1]) &#123;c[i][j]=c[i-1][j]; b[i][j]=1; &#125; else &#123;c[i][j]=c[i][j-1]; b[i][j]=-1; &#125; &#125;&#125;void PrintLCS(int b[][MAXLEN], char *x, int i, int j)&#123; if (i==0||j==0) return; if (b[i][j]==0) &#123; PrintLCS(b,x,i-1,j-1); printf(&quot;%c&quot;,x[i-1]); &#125; else if(b[i][j]==1) PrintLCS(b,x,i-1,j); else PrintLCS(b,x,i,j-1);&#125;int main()&#123; printf(&quot;输入: &quot;); for(int i=0;i&lt;4;i++) scanf(&quot;%s&quot;,&amp;s[i]); //为字符串数组s[]赋初值 for(i=0;i&lt;4;i++) len[i]=strlen(s[i]); int maxn=c[len[0]][len[0]]; //c是记录最长公共子序列长度的数组 for(i=0;i&lt;4;i++) for(int j=i+1;j&lt;4;j++) &#123; LCSLength(s[i],s[j],len[i], len[j], c, b); maxn=(maxn&gt;c[len[i]][len[j]])?maxn:c[len[i]][len[j]];//获取公共位数最大值 &#125; printf(&quot;输出：&quot;); for(i=0;i&lt;4;i++) for(int j=i+1;j&lt;4;j++) &#123; LCSLength(s[i], s[j],len[i], len[j], c, b); if(maxn==c[len[i]][len[j]]) &#123; printf(&quot;%s &quot;,s[i]); printf(&quot;%s &quot;,s[j]); printf(&quot;%d &quot;, c[len[i]][len[j]]);//打印公共位数 PrintLCS(b, s[i], len[i], len[j]);//打印子序列 printf(&quot; &quot;); &#125; &#125; return 0;&#125; 运行截图"},{"title":"算法—数字地图","path":"/posts/3256024956/","content":"数字地图算法描述【问题描述】Jacky在网上发布了通过无人机航拍的某海域的地图，该海域有很多岛屿，为了能更好地分析该区域的航拍地图，地图被数字化为0到9组成矩阵,0表示该位置为大海，数字1到9都表示陆地(海拔不同)，假设在地图坐标m[x][y]处降落，现在要统计降落所在岛屿的面积（有多少个方格），降落点上下左右相连接的陆地为同一岛屿。例如，在如下4行4列的数字化地图中，降落点坐标为(3,3)，则所在岛屿的面积为9 。5 1 0 07 9 1 00 0 7 30 0 4 9 【输入】第1行为两整数m,n(m行，n列)，表示数字化地图m行n列，第2行输入降落地点的坐标x,y，再后面接着输入m行n列的矩阵。【输出】只有1行，为降落点所在岛屿的面积。【输入样例】4 43 35 1 0 02 6 2 00 0 1 90 0 7 5【输出样例】9 C语言实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/*回溯法——深度优先搜索时间复杂度为n方*/#include &lt;stdio.h&gt;#define max 1000int map[max][max];int vis[max][max];//记录i,j位置是否遍历过int m,n,x,y,num=0; int dfs(int x,int y)&#123; //深度优先算法 int i,nx,ny; int dx[4]=&#123;1,0,-1,0&#125;; int dy[4]=&#123;0,1,0,-1&#125;; for (i=0;i&lt;4;i++) &#123; nx=x+dx[i]; ny=y+dy[i]; if (nx&gt;=0 &amp;&amp; nx&lt;m &amp;&amp; ny&gt;=0 &amp;&amp; ny&lt;n &amp;&amp; map[nx][ny]!=0 &amp;&amp; vis[nx][ny]==0)&#123; vis[nx][ny]=1; if(map[nx][ny]!=map[x][y]) &#123; num++;&#125; dfs(nx,ny);//递归 &#125; else continue; &#125; return num;&#125;int main() &#123; int i,j,max1;\tnum=0;\tprintf(&quot;请输入岛的大小(m*n):&quot;); scanf(&quot;%d %d&quot;,&amp;m,&amp;n);\tprintf(&quot;请输入落地点(x*y):&quot;); scanf(&quot;%d %d&quot;,&amp;x,&amp;y);\tfor(i=0;i&lt;m;i++) for(j=0;j&lt;n;j++)&#123; scanf(&quot;%d&quot;,&amp;map[i][j]); &#125;\tfor(i=0;i&lt;m;i++) for(j=0;j&lt;n;j++) vis[i][j]=0;\tif (vis[x][y]==0 &amp;&amp; map[x][y]!=0) &#123; vis[x][y]=1; num=1; max1=dfs(x,y);\t&#125;\tprintf(&quot;所在岛屿面积为:%d &quot;,max1); return 0;&#125; 运行截图"},{"title":"JAVA面向对象三大特征--封装","path":"/posts/1511018263/","content":"JAVA面向对象三大特征—封装封装是面向对象编程中的三大特征之一，在对封装性进行解释时我们有必要先了解一些面向对象的思想，以及相关的概念。当我们想要去描述一系列的关系时我们要用到的最基本结构就是类，其中存在着成员变量和方法，用于记录属性和表达行为。 一、名词解读为了解释封装的概念和作用，需要先来了解一下几个相关的概念，这有助于我们接下来的理解。 1.权限修饰符当我们在一个类中定义成员变量时，会指定一个变量的类型，除此之外，还会有修饰符的部分，在此给出定义成员变量的规范格式： 123// 定义变量[修饰符] 变量类型 变量名称;[修饰符] 变量类型 变量名称 = 初始值; 修饰符起到的作用从字面就可以解释，起到一个修饰和限定的作用，可以使用在成员变量之前的修饰符可以是：public、protected、private、final、static。修饰符与修饰符之间的顺序没有强制要求，其中public、protected、private被称为权限修饰符，可以用来限定类的属性和方法的访问权限，指明在哪些包的哪些类中能够调用到这些属性或方法，是一种一定会存在的修饰符。需要注意的是，这三个单词不能同时出现，当这三个单词都不出现的时候会被认为是默认访问权限，所以权限修饰符一共有四种：private、默认、protected、public。 2.权限对应关系表 private：私有权限，只能在定义的类中访问，在其他类中创建的实例均无法访问 默认：同包可访问权限，在没有声明权限修饰符时为默认权限，允许在同包的其他类访问 protected：受保护权限，允许有继承关系的子类访问 public：公共权限，允许任何类访问 3.属性访问由于权限修饰符在封装特性中的作用只是实现封装性的一种途径，所以在这里只演示private与public的作用，权限修饰符的其他作用将在后续的文章中继续介绍。 1234567src└──edu └──sandtower └──bean │ Person.java └──test │ Test.java 以上为实体类与测试类所在的目录结构，Person实体类所在包：edu.sandtower.bean，Test测试类所在包：edu.sandtower.test，相应代码如下： 123456789package edu.sandtower.bean;public class Person&#123; // 声明公开属性 public String name; // 声明私有属性 private double money;&#125; 123456789101112package edu.sandtower.test;import edu.sandtower.bean.Person;public class Test&#123; public static void main(String[] args)&#123; // 在test包中的Test类中创建Person实例 Person person = new Person(); person.name = &quot;小张&quot;;// 编译通过，可以访问name属性 person.money = 500.0;// 编译失败，无法访问money属性 &#125;&#125; 从上面的例子可以看出，虽然依然是使用Person自己的实例在进行属性的调用，但是我们是在另外一个包中的类发生的调用，所以是不能够访问到private修饰的属性的，在刚开始学习时一定要注意区分。 二、概念阐释1.封装有什么用通过使用权限修饰符，我们可以限定类的成员的被访问权限，那为什么要这样做呢？在很多场景下，我们需要确保我们对属性值的操作均是有效操作，不能违背某些规则。比如，我们定义了一个Person类，具有name和money两个属性，在买东西时需要扣掉相应的金额，原始写法如下： 1234public class Person&#123; public String name; public double money;&#125; 1234567891011public class Test&#123; public static void main(String[] args)&#123; Person person = new Person(); person.money = 500;// 初始金额500元 System.out.println(&quot;购买一张桌子，花费200元&quot;); person.money -= 200; System.out.println(&quot;购买二手PSP，花费350元&quot;); person.money -= 350; System.out.println(&quot;目前余额为：&quot; + person.money);// -50 &#125;&#125; 可以看到，经过代码操作以后可能会导致money的属性为负。看官甲：你自己不加判断赖代码？没错，这个问题我们可以增加判断代码来解决，由于这个操作是对money属性值的操作，我们将它封装成一个方法写在实体类中，于是有了改进之后的代码： class Person{ &#96;public String name; public double money; // 定义一个方法，用于设置money属性的值 public void setMoney(double money)&#123; if(money &gt;= 0)&#123; this.money = money; &#125; &#125; }&#96;&#96;&#96; class Test&#123;123456789101112131415161718 public static void main(String[] args)&#123; Person person = new Person(); person.money = 500;// 初始金额500元 System.out.println(&quot;购买一张桌子，花费200元&quot;); person.setMoney(person.money - 200); System.out.println(&quot;购买二手PSP，花费350元&quot;); person.setMoney(person.money - 350); System.out.println(&quot;目前余额为：&quot; + person.money);// 300 &#125;&#125;```经过上面的改进，我们可以确保money的值不为负数，同时可以看到，当在实体类中定义方法后，使用者需要修改属性值时直接调用方法就可以保证不出问题。但是由于属性值依然可以被直接访问，还不能保证万无一失，于是我们利用权限修饰符使得变量不能被直接访问，同时需要定义一个能够取得属性值的方法。`public class Person\\&#123; public String name; // 声明money属性为private权限 private double money; &#x2F;&#x2F; 定义一个方法，用于设置money属性的值public void setMoney(double money){ if(money &gt;&#x3D; 0){ this.money &#x3D; money; }}&#x2F;&#x2F; 定义一个方法，用于获取money属性的值public double getMoney(){ return this.money;} 1234\\&#125;```none public class Test{ public static void main(String[] args){ Person person &#x3D; new Person(); person.setMoney(500);&#x2F;&#x2F; 初始金额500元，此时已经不能使用对象.属性的方法赋值 System.out.println(“购买一张桌子，花费200元”); person.setMoney(person.getMoney() - 200); System.out.println(“购买二手PSP，花费350元”); person.setMoney(person.getMoney() - 300); System.out.println(“目前余额为：” + person.getMoney());&#x2F;&#x2F; 300 }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354通过以上的案例，我们可以看到进行封装有以下几个作用：防止类的属性被外部代码随意的修改和访问，保证数据的完备性 将对属性的操作转换为方法，更加灵活和安全 使用封装可以隐藏实现的细节：使用者只需要作用，不需要知道过程 在类的定义结构中修改，提高了代码的可维护性，同时又可以不影响外部的使用 通过封装方法可以有效减少耦合 耦合：模块与模块之间，代码与代码之间的关联程度，对属性封装后，和调用相关的代码就会变得相对简单，可以降低耦合### 2.如何进行封装在进行封装时都是出于对属性保护的考虑，可以按照以下两个步骤来进行：使用权限修饰符 使用private作用在属性上，关闭直接访问的入口 使用public作用在方法上，提供调用的入口 定义与属性存取相关的方法 在属性关闭后，我们需要通过方法来获取属性的值以及对属性值进行修改。由于有了方法结构，我们就可以对存入的数据进行判断，对不符合逻辑的数据进行处理。### 3.常规封装方法明白了封装的作用后，我们可以通过自定义方法的方式完成对属性的封装。封装方法和类中定义的其他方法在结构上没有任何的区别，同样都是普通的方法，区别主要在于体现在用途方面：普通方法主要表达该类所能产生的行为 封装方法主要为属性的访问和使用提供了一个入口，作用相对单一 在进入到框架的学习之后，很多对实体类属性自动赋值的操作都是通过调用封装方法实现的，所以我们必须要知道常规封装方法的名称定义和类型设置规则。 对于属性来说我们只会进行两种操作：存和取。那么相应的封装方法应该有一对儿get代表取用：既然是取值，那么就要把属性值进行返回，方法的返回值类型与属性类型相同 set代表存储：既然是存值，那么就要在参数列表中接收想要存入的值，类型与属性类型相同 对于命名方面只要遵从驼峰命名法就好，以get或set开头，大写属性名称的首字母，其余不变，看下面一个例子：```nonepublic class Person&#123; // 使用private声明属性 private String name; private double money; // 使用public声明方法，作为操作属性的入口 public void setName(String name)&#123; this.name = name; &#125; public String getName()&#123; return this.name; &#125; public void setMoney(double money)&#123; // 如有需要，可以在方法中可以自定义其他逻辑 this.money = money; &#125; public double getMoney()&#123; return this.money; &#125;&#125; 由于常规封装方法定义的格式和名称都相对固定，所以一般的编译器都自带自动生成封装方法的功能，这样既方便又能降低出错率，大家一定要掌握。 Eclipse： 属性定义完成后，选择source菜单 -&gt; Generate Getters and Setters… 点击Select All（选择所有属性） -&gt; Generate"},{"title":"Maven的下载与环境配置(Windows)","path":"/posts/896528036/","content":"Maven的下载与环境配置(Windows)一、Maven的主要内容 二、Maven的简介Maven[‘meven]这个词可以翻译为”专家”内行”。作为Apache组织中的一个颇为成功的开源项目，Maven主要服务于基于java平台的项目构建，依赖管理和项目信息管理。 无论是小型的开源类库项目，还是大型的企业级应用;无论是传统的瀑布式开发，还是流行的敏捷开发，Maven都能大显身手。 本文将教你掌握Maven的安装以及配置方法。 三、Maven的下载在maven的官网可以下载，点击跳转maven官网下载页选择Files-&gt;Link-&gt;apache-maven-3.x.x-bin.zip点击下载即可。下载解压后，文件目录结构如下： 四、Maven常用配置！！！在配置之前请务必将JDK安装好。 1.环境变量配置选择此电脑（右键）--&gt; 属性 \\--&gt; 高级系统设置进入如下页面：新手注意这里分为用户变量和系统变量，对于一台电脑（系统）来说，你是使用它的用户，而同一台电脑可以被另外一个用户使用，所以当更换用户时，你在用户变量配置的环境就消失了，为了方便使用，我们一般将环境变量全部配置在系统变量下，如图所示：点击新建后我们添加Maven的HOME（在后文解释为什么要建立HOME）在变量名一栏中输入MAVEN_HOME在变量值中输入maven的解压的地址，我使用的是自己文件的解压地址，请你换成你自己的,获取解压地址的方法如下：如图复制了之后在变量值中填入D:\\Workspace\\Maven\\apache-maven-3.8.3-bin\\apache-maven-3.8.3(替换成你自己的) 编辑Path接下来编辑Path，配置Path的目的是，当在cmd输入指令的时候，系统会在Path中寻找你的指令是否存在，所以配置Path的步骤最为关键在编辑界面中添加%MAVEN_HOME%\\bin 注：其实前面的HOME不配置都可以，只要把在Path中的%MAVEN_HOME%\\bin换成变量值\\bin是一样的，只不过变量值的路径一般都很长，为了增加可读性，我们会建立一个HOME 测试win+r输入cmd回车在cmd窗口输入mvn -v查看显示如下即为安装成功： 2.修改配置文件通常我们需要修改解压目录下conf/settings.xml文件，这样可以更好的适合我们的使用。 此处注意：所有的修改一定要在注释标签外面，不然修改无效。Maven很多标签都是给的例子，都是注释掉的。 文末附上我的整个Settings.xml文件配置。 本地仓库位置的修改 在标签内添加自己的本地位置路径 1234567 &lt;!-- localRepository | The path to the local repository maven will use to store artifacts. | | Default: $&#123;user.home&#125;/.m2/repository &lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt; --&gt;&lt;localRepository&gt;D:\\tools\\repository&lt;/localRepository&gt; 修改maven默认的JDK版本 在标签下添加一个标签，修改maven默认的JDK版本。 123456789101112&lt;profile&gt; &lt;id&gt;JDK-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;/profile&gt; 添加国内镜像源 添加标签下，添加国内镜像源，这样下载jar包速度很快。默认的中央仓库有时候甚至连接不通。一般使用阿里云镜像库即可。这里我就都加上了，Maven会默认从这几个开始下载，没有的话就会去中央仓库了。 1234567891011121314151617181920212223&lt;!-- 阿里云仓库 --&gt;&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt;&lt;/mirror&gt;&lt;!-- 中央仓库1 --&gt;&lt;mirror&gt; &lt;id&gt;repo1&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://repo1.maven.org/maven2/&lt;/url&gt;&lt;/mirror&gt;&lt;!-- 中央仓库2 --&gt;&lt;mirror&gt; &lt;id&gt;repo2&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://repo2.maven.org/maven2/&lt;/url&gt;&lt;/mirror&gt; 五、常用IDE下配置Maven目前常用的开发工具如idea，eclipse都自身集成了一个版本的Maven。但是通常我们使用自己已经配置好的Maven。 IDEA下配置Maven跟着图片选择然后1：此处修改为自己解压的Maven目录 2：勾选Override，修改为自己目录下的settings.xml目录 3：修改为自己的本地仓库地址，一般会自动识别。 此处勾选，当修改pom文件时，Maven就能帮我们自动导包了。 Eclipse下配置Maven将eclipse使用的Maven修改为自己的。点击add后选择自己Maven的安装目录即可。添加好之后记得勾选。将所有的settings修改为自己Maven目录下的conf&#x2F;settings.xml.点击Update Settings按钮，下面的Local Respository会自动识别出来。 附：完整的Settings.xml文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!--Licensed to the Apache Software Foundation (ASF) under oneor more contributor license agreements. See the NOTICE filedistributed with this work for additional informationregarding copyright ownership. The ASF licenses this fileto you under the Apache License, Version 2.0 (the&quot;License&quot;); you may not use this file except in compliancewith the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing,software distributed under the License is distributed on an&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANYKIND, either express or implied. See the License for thespecific language governing permissions and limitationsunder the License.--&gt;&lt;!-- | This is the configuration file for Maven. It can be specified at two levels: | | 1. User Level. This settings.xml file provides configuration for a single user, | and is normally provided in $&#123;user.home&#125;/.m2/settings.xml. | | NOTE: This location can be overridden with the CLI option: | | -s /path/to/user/settings.xml | | 2. Global Level. This settings.xml file provides configuration for all Maven | users on a machine (assuming they&#x27;re all using the same Maven | installation). It&#x27;s normally provided in | $&#123;maven.conf&#125;/settings.xml. | | NOTE: This location can be overridden with the CLI option: | | -gs /path/to/global/settings.xml | | The sections in this sample file are intended to give you a running start at | getting the most out of your Maven installation. Where appropriate, the default | values (values used when the setting is not specified) are provided. | |--&gt;&lt;settings xmlns=&quot;http://maven.apache.org/SETTINGS/1.2.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.2.0 https://maven.apache.org/xsd/settings-1.2.0.xsd&quot;&gt; &lt;!-- localRepository | The path to the local repository maven will use to store artifacts. | | Default: $&#123;user.home&#125;/.m2/repository &lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt; --&gt; &lt;localRepository&gt;D:\\tools\\repository&lt;/localRepository&gt; &lt;!-- interactiveMode | This will determine whether maven prompts you when it needs input. If set to false, | maven will use a sensible default value, perhaps based on some other setting, for | the parameter in question. | | Default: true &lt;interactiveMode&gt;true&lt;/interactiveMode&gt; --&gt; &lt;!-- offline | Determines whether maven should attempt to connect to the network when executing a build. | This will have an effect on artifact downloads, artifact deployment, and others. | | Default: false &lt;offline&gt;false&lt;/offline&gt; --&gt; &lt;!-- pluginGroups | This is a list of additional group identifiers that will be searched when resolving plugins by their prefix, i.e. | when invoking a command line like &quot;mvn prefix:goal&quot;. Maven will automatically add the group identifiers | &quot;org.apache.maven.plugins&quot; and &quot;org.codehaus.mojo&quot; if these are not already contained in the list. |--&gt; &lt;pluginGroups&gt; &lt;!-- pluginGroup | Specifies a further group identifier to use for plugin lookup. &lt;pluginGroup&gt;com.your.plugins&lt;/pluginGroup&gt; --&gt; &lt;/pluginGroups&gt; &lt;!-- proxies | This is a list of proxies which can be used on this machine to connect to the network. | Unless otherwise specified (by system property or command-line switch), the first proxy | specification in this list marked as active will be used. |--&gt; &lt;proxies&gt; &lt;!-- proxy | Specification for one proxy, to be used in connecting to the network. | &lt;proxy&gt; &lt;id&gt;optional&lt;/id&gt; &lt;active&gt;true&lt;/active&gt; &lt;protocol&gt;http&lt;/protocol&gt; &lt;username&gt;proxyuser&lt;/username&gt; &lt;password&gt;proxypass&lt;/password&gt; &lt;host&gt;proxy.host.net&lt;/host&gt; &lt;port&gt;80&lt;/port&gt; &lt;nonProxyHosts&gt;local.net|some.host.com&lt;/nonProxyHosts&gt; &lt;/proxy&gt; --&gt; &lt;/proxies&gt; &lt;!-- servers | This is a list of authentication profiles, keyed by the server-id used within the system. | Authentication profiles can be used whenever maven must make a connection to a remote server. |--&gt; &lt;servers&gt; &lt;!-- server | Specifies the authentication information to use when connecting to a particular server, identified by | a unique name within the system (referred to by the &#x27;id&#x27; attribute below). | | NOTE: You should either specify username/password OR privateKey/passphrase, since these pairings are | used together. | &lt;server&gt; &lt;id&gt;deploymentRepo&lt;/id&gt; &lt;username&gt;repouser&lt;/username&gt; &lt;password&gt;repopwd&lt;/password&gt; &lt;/server&gt; --&gt; &lt;!-- Another sample, using keys to authenticate. &lt;server&gt; &lt;id&gt;siteServer&lt;/id&gt; &lt;privateKey&gt;/path/to/private/key&lt;/privateKey&gt; &lt;passphrase&gt;optional; leave empty if not used.&lt;/passphrase&gt; &lt;/server&gt; --&gt; &lt;/servers&gt; &lt;!-- mirrors | This is a list of mirrors to be used in downloading artifacts from remote repositories. | | It works like this: a POM may declare a repository to use in resolving certain artifacts. | However, this repository may have problems with heavy traffic at times, so people have mirrored | it to several places. | | That repository definition will have a unique id, so we can create a mirror reference for that | repository, to be used as an alternate download site. The mirror site will be the preferred | server for that repository. |--&gt; &lt;mirrors&gt; &lt;!-- mirror | Specifies a repository mirror site to use instead of a given repository. The repository that | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used | for inheritance and direct lookup purposes, and must be unique across the set of mirrors. | &lt;mirror&gt; &lt;id&gt;mirrorId&lt;/id&gt; &lt;mirrorOf&gt;repositoryId&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://my.repository.com/repo/path&lt;/url&gt; &lt;/mirror&gt; --&gt; &lt;mirror&gt; &lt;id&gt;maven-default-http-blocker&lt;/id&gt; &lt;mirrorOf&gt;external:http:*&lt;/mirrorOf&gt; &lt;name&gt;Pseudo repository to mirror external repositories initially using HTTP.&lt;/name&gt; &lt;url&gt;http://0.0.0.0/&lt;/url&gt; &lt;blocked&gt;true&lt;/blocked&gt; &lt;/mirror&gt; &lt;!-- 闃块噷浜戜粨搴?--&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt; &lt;/mirror&gt; &lt;!-- 涓ぎ浠撳簱1 --&gt; &lt;mirror&gt; &lt;id&gt;repo1&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://repo1.maven.org/maven2/&lt;/url&gt; &lt;/mirror&gt; &lt;!-- 涓ぎ浠撳簱2 --&gt; &lt;mirror&gt; &lt;id&gt;repo2&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://repo2.maven.org/maven2/&lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt; &lt;!-- profiles | This is a list of profiles which can be activated in a variety of ways, and which can modify | the build process. Profiles provided in the settings.xml are intended to provide local machine- | specific paths and repository locations which allow the build to work in the local environment. | | For example, if you have an integration testing plugin - like cactus - that needs to know where | your Tomcat instance is installed, you can provide a variable here such that the variable is | dereferenced during the build process to configure the cactus plugin. | | As noted above, profiles can be activated in a variety of ways. One way - the activeProfiles | section of this document (settings.xml) - will be discussed later. Another way essentially | relies on the detection of a system property, either matching a particular value for the property, | or merely testing its existence. Profiles can also be activated by JDK version prefix, where a | value of &#x27;1.4&#x27; might activate a profile when the build is executed on a JDK version of &#x27;1.4.2_07&#x27;. | Finally, the list of active profiles can be specified directly from the command line. | | NOTE: For profiles defined in the settings.xml, you are restricted to specifying only artifact | repositories, plugin repositories, and free-form properties to be used as configuration | variables for plugins in the POM. | |--&gt; &lt;profiles&gt; &lt;profile&gt; &lt;id&gt;JDK-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;!-- profile | Specifies a set of introductions to the build process, to be activated using one or more of the | mechanisms described above. For inheritance purposes, and to activate profiles via &lt;activatedProfiles/&gt; | or the command line, profiles have to have an ID that is unique. | | An encouraged best practice for profile identification is to use a consistent naming convention | for profiles, such as &#x27;env-dev&#x27;, &#x27;env-test&#x27;, &#x27;env-production&#x27;, &#x27;user-jdcasey&#x27;, &#x27;user-brett&#x27;, etc. | This will make it more intuitive to understand what the set of introduced profiles is attempting | to accomplish, particularly when you only have a list of profile id&#x27;s for debug. | | This profile example uses the JDK version to trigger activation, and provides a JDK-specific repo. &lt;profile&gt; &lt;id&gt;jdk-1.4&lt;/id&gt; &lt;activation&gt; &lt;jdk&gt;1.4&lt;/jdk&gt; &lt;/activation&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;jdk14&lt;/id&gt; &lt;name&gt;Repository for JDK 1.4 builds&lt;/name&gt; &lt;url&gt;http://www.myhost.com/maven/jdk14&lt;/url&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;snapshotPolicy&gt;always&lt;/snapshotPolicy&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;/profile&gt; --&gt; &lt;!-- | Here is another profile, activated by the system property &#x27;target-env&#x27; with a value of &#x27;dev&#x27;, | which provides a specific path to the Tomcat instance. To use this, your plugin configuration | might hypothetically look like: | | ... | &lt;plugin&gt; | &lt;groupId&gt;org.myco.myplugins&lt;/groupId&gt; | &lt;artifactId&gt;myplugin&lt;/artifactId&gt; | | &lt;configuration&gt; | &lt;tomcatLocation&gt;$&#123;tomcatPath&#125;&lt;/tomcatLocation&gt; | &lt;/configuration&gt; | &lt;/plugin&gt; | ... | | NOTE: If you just wanted to inject this configuration whenever someone set &#x27;target-env&#x27; to | anything, you could just leave off the &lt;value/&gt; inside the activation-property. | &lt;profile&gt; &lt;id&gt;env-dev&lt;/id&gt; &lt;activation&gt; &lt;property&gt; &lt;name&gt;target-env&lt;/name&gt; &lt;value&gt;dev&lt;/value&gt; &lt;/property&gt; &lt;/activation&gt; &lt;properties&gt; &lt;tomcatPath&gt;/path/to/tomcat/instance&lt;/tomcatPath&gt; &lt;/properties&gt; &lt;/profile&gt; --&gt; &lt;/profiles&gt; &lt;!-- activeProfiles | List of profiles that are active for all builds. | &lt;activeProfiles&gt; &lt;activeProfile&gt;alwaysActiveProfile&lt;/activeProfile&gt; &lt;activeProfile&gt;anotherAlwaysActiveProfile&lt;/activeProfile&gt; &lt;/activeProfiles&gt; --&gt;&lt;/settings&gt;"},{"title":"用JAVA实现银行家算法","path":"/posts/56575920/","content":"用Java实现银行家算法实验目的银行家算法是避免死锁的一种重要方法，本实验要求用高级语言编写和调试一个简单的银行家算法程序。加深了解有关资源申请、避免死锁等概念，并体会和了解死锁和避免死锁的具体实施方法。 实验内容1)设计进程对各类资源最大申请表示及初值确定。2)设定系统提供资源初始状况。3)设定每次某个进程对各类资源的申请表示。4)编制程序，依据银行家算法，决定其申请是否得到满足。 代码解释Banker类-T0时刻资源分配进行变量定义：对进程数量M，资源种类数量N，各资源总数All[]，m个进程对n类资源的最大需求量Max[][]，m个进程已经得到n类资源的资源量Allocation[][],m个进程还需要n类资源的资源量Need[][],系统可用资源数系统可用资源数Available[][]。还有一个进程完成标志位Finish[]。 12345678910111213class Banker&#123;\tint ID[], //进程代号 M, //m个进程 N, //n类资源 All[], //系统各资源数量 Max[][], //m个进程对n类资源的最大需求量 Allocation[][],\t//m个进程已经得到n类资源的资源量 Need[][], //m个进程还需要n类资源的资源量 Available[][];\t//系统可用资源数 boolean Finish[];\t//标记进程是否完成\tint a=0;//Available的第一个下标 无参构造函数：在无参函数中进行变量的初始化，需要手动输入的变量为M,N，All[]，Max[][]，Allocation[][]。当输入了初始值后，Need[][]和Available[][]就可以通过need 的计算公式：Need&#x3D;[i][j]&#x3D; Max[i][j]- Allocation[i][j]Available[][]：Available[a][n] &#x3D; All[n] - Allocation[m][n]（遍历） 1234567891011121314151617181920212223242526272829303132public Banker() &#123;\t//无参构造器 @SuppressWarnings(&quot;resource&quot;) Scanner input = new Scanner(System.in); System.out.println(&quot;请输入进程数&quot;); M = input.nextInt();//m个进程 System.out.println(&quot;请输入资源种类数&quot;); N = input.nextInt();//n类资源 //初始化数组 ID = new int[M]; //进程代号 All = new int[N]; //系统各资源数量 Max = new int[M][N]; //m个进程对n类资源的最大需求量 Allocation = new int[M][N];\t//m个进程已经得到n类资源的资源量 Need = new int[M][N]; //m个进程还需要n类资源的资源量 Available = new int[M+1][N]; //系统可用资源数 Finish = new boolean[M];\t//标记进程是否完成 System.out.println(&quot;请输入系统初始可用资源数&quot;); for(int i=0; i&lt;N; i++)//系统初始可用资源数 All[i] = input.nextInt(); System.out.println(&quot;请输入&quot;+M+&quot;个进程对&quot;+N+&quot;类资源的最大需求量&quot;); for(int i=0; i&lt;M; i++)&#123;//m个进程对n类资源的最大需求量 ID[i] = i; for(int j=0; j&lt;N; j++) Max[i][j] = input.nextInt(); &#125; System.out.println(&quot;请输入&quot;+M+&quot;个进程已经得到的&quot;+N+&quot;类资源的资源量&quot;); for(int i=0; i&lt;M; i++)\t//m个进程已经得到n类资源的资源量 for(int j=0; j&lt;N; j++) Allocation[i][j] = input.nextInt(); Need_Resources(); Available_Resources(); Print_Banker();\t&#125; 初始化Need和Available矩阵： 12345678910111213141516private void Need_Resources() &#123;//初始化Need矩阵 // TODO Auto-generated method stub for(int i=0; i&lt;M; i++)//m个进程还需要n类资源的资源量 for(int j=0; j&lt;N; j++) Need[i][j] = Max[i][j] - Allocation[i][j];\t&#125;\tprivate void Available_Resources() &#123;//更新系统当前可用资源数 // TODO Auto-generated method stub for(int n=0; n&lt;N; n++)&#123;//系统目前可用资源数 Available[a][n] = All[n]; for(int m=0; m&lt;M; m++)&#123; Available[a][n] -= Allocation[m][n]; &#125; &#125;\t&#125; 就此，所有矩阵初始化完毕，对T0时刻的资源分配图进行打印，如图所示： 1234567891011121314151617181920212223242526272829303132private void Print_Banker() &#123;//T0时刻的资源分配图 System.out.println(&quot; T0时刻资源分配图：&quot;); System.out.print(&quot;资源\\t资源数量 &quot;); for(int i=0; i&lt;N; i++) System.out.printf(&quot;S%d\\t%d &quot;, i, All[i]); System.out.print(&quot; 进程\\t Max\\tAllocation\\tNeed\\tAvailable\\tFinish &quot;); for(int i=0; i&lt;M; i++)&#123; System.out.print(&quot;P&quot;+ID[i]); System.out.print(&quot;\\t&quot;); for(int j=0; j&lt;Max[ID[i]].length; j++)&#123; System.out.printf(&quot;%d &quot;, Max[ID[i]][j]); &#125; System.out.print(&quot;\\t&quot;); for(int j=0; j&lt;Allocation[ID[i]].length; j++)&#123; System.out.printf(&quot;%d &quot;, Allocation[ID[i]][j]); &#125; System.out.print(&quot;\\t\\t&quot;); for(int j=0; j&lt;Need[ID[i]].length; j++)&#123; System.out.printf(&quot;%d &quot;, Need[ID[i]][j]); &#125; System.out.print(&quot;\\t&quot;); if(i == 0)&#123; for(int j=0; j&lt;N; j++)&#123; System.out.printf(&quot;%d &quot;, Available[i][j]); &#125; &#125; System.out.print(&quot;\\t&quot;); System.out.print(&quot;\\t&quot;); System.out.print(Finish[i]); System.out.println(); &#125;\t&#125; 安全性检查对T0时刻资源分配情况进行安全性分析，为每个进程进行可满足性检查。Need[i][j] &gt; Available[a][j]遍历每个资源，都满足可满足性，则进入试分配，若不满足，将该进程的标志位flag2置为false，跳出for循环。试分配，先将进程的Finish标志位置为true，代表这个进程已经被分配资源执行完毕。更新Available：Available[a][j] &#x3D; Available[a-1][j] + Allocation[i][j];当所有进程都通过试分配(a &#x3D;&#x3D; M)后，打印分配过资源的安全序列Print_Banker_Se() 12345678910111213141516171819202122232425262728293031323334353637public void Security_examine()&#123;//安全性检测 boolean flag1,\t//所有进程 flag2;\t//每个进程 flag1 = true; while(flag1)&#123; flag1 = false; for(int i=0; i&lt;M; i++)&#123; flag2 = true; for(int j=0; flag2 &amp;&amp; j&lt;N; j++)&#123; if(Need[i][j] &gt; Available[a][j] || Finish[i])&#123;//存在一个条件不满足或者该进程已经完成 flag2 = false; &#125; &#125; if(flag2 &amp;&amp; !Finish[i])&#123;//该进程（第i个进程）可执行 flag1 = true; Finish[i] = true; ID[a] = i; a++;//以此判断所有进程是否都执行，安全检查 for(int j=0; flag2 &amp;&amp; j&lt;N; j++)&#123; Available[a][j] = Available[a-1][j] + Allocation[i][j]; &#125; &#125; &#125; &#125; System.out.println(&quot; T0时刻的安全性：&quot;); if(a == M)&#123; Print_Banker_Se(); System.out.println(&quot; 安全序列：&quot;); for(int i=0; i&lt;M; i++)&#123; System.out.print(&quot;-&gt;P&quot;+ID[i]); &#125; System.out.println(&quot; &quot;); &#125; else&#123; System.out.println(&quot;系统不安全&quot;); &#125;\t&#125; Banker类-银行家算法申请资源：某个进程发起请求向量Request(,,*)，系统按银行家算法进行检查。① Request[i] &gt; Need[n][i]② Request[i] &gt; Available[0][i]满足以上两条说明不满足正确性检查和可满足性检查，将标志位flag置为false，报告分配不安全。若通过了正确性和可满足性检测就将这条进程的已分配Allocation加上申请量，并重新对Need和Available矩阵进行新的初始化。并打印此时初状态资源分配表。 安全性检查：通过主程序调用键盘输入控制进入安全性检查部分，思想和源码与T0时刻的安全性检查雷同，再次不在赘述。安全性检查 123456789101112131415161718192021222324252627282930313233343536public void Reallocation()&#123;//申请资源 @SuppressWarnings(&quot;resource&quot;) Scanner input = new Scanner(System.in); int[] Request = new int[N]; boolean flag = true; System.out.print(&quot; 输入进程代号：&quot;); int n = input.nextInt(); System.out.print(&quot;输入请求资源数：&quot;); for(int j=0; j&lt;N; j++) Request[j] = input.nextInt(); for(int i=0; i&lt;N; i++)&#123;//合理性检查,可用性检查 if(Request[i] &gt; Need[n][i] || Request[i] &gt; Available[0][i]) flag = false; &#125; if(flag)&#123; for(int i=0; i&lt;N; i++)&#123; Allocation[n][i] += Request[i]; &#125; Init(); Print_Banker(); &#125; else&#123; System.out.println(&quot;分配不安全 &quot;); &#125; &#125;\tprivate void Init() &#123; // TODO Auto-generated method stub a = 0; Need_Resources();//再次初始化 Available_Resources(); for(int i=0; i&lt;M; i++)&#123;//ID初始化 ID[i] = i; Finish[i] = false; &#125;\t&#125; 主函数使用无参构造器new了一个banker对象，打印菜单，并控制调用安全性检测、银行家算法（请求再分配资源）以及退出。 1234567891011121314151617181920212223public class TestBankerClass &#123;\tpublic static void main(String[] args) &#123; // TODO Auto-generated method stub Banker banker = new Banker(); int n; boolean flag=true; Scanner input = new Scanner(System.in); System.out.println(&quot; *************菜单****************&quot;); System.out.println(&quot;进行安全性检查：1 请求再分配资源：2 退出：其他&quot;); System.out.println(&quot;*********************************&quot;); while(flag)&#123; System.out.print(&quot;输入操作代号：&quot;); n = input.nextInt(); switch(n)&#123; case 1:\tbanker.Security_examine();break; case 2:\tbanker.Reallocation();break; default:flag = false; System.out.print(&quot; 操作结束！！！！&quot;); &#125; &#125; input.close();//关闭流\t&#125;&#125; 输入示例例1： 1234567891011121314151617181920212223242526初始化：5310 5 77 5 33 2 29 0 22 2 24 3 30 1 02 0 03 0 22 1 10 0 2再分配：11 0 243 3 000 2 0 例2： 123456789101112131415161718初始化：3310 8 78 7 55 2 56 6 23 2 02 0 21 3 2再分配：01 0 010 1 1 运行结果例1： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107T0时刻资源分配图：资源\t资源数量S0\t10S1\t5S2\t7进程 Max\tAllocation\tNeed\tAvailable\tFinishP0\t7 5 3 0 1 0 7 4 3 3 3 2 falseP1\t3 2 2 2 0 0 1 2 2 falseP2\t9 0 2 3 0 2 6 0 0 falseP3\t2 2 2 2 1 1 0 1 1 falseP4\t4 3 3 0 0 2 4 3 1 false*************菜单****************进行安全性检查：1请求再分配资源：2退出：其他*********************************输入操作代号：1T0时刻的安全性：进程 Work\tNeed\tAllocation\tWork+Allocation\tFinishP1\t3 3 2 1 2 2 2 0 0 5 3 2 trueP3\t5 3 2 0 1 1 2 1 1 7 4 3 trueP4\t7 4 3 4 3 1 0 0 2 7 4 5 trueP0\t7 4 5 7 4 3 0 1 0 7 5 5 trueP2\t7 5 5 6 0 0 3 0 2 10 5 7 true安全序列：-&gt;P1-&gt;P3-&gt;P4-&gt;P0-&gt;P2输入操作代号：2输入进程代号：1输入请求资源数：1 0 2T0时刻资源分配图：资源\t资源数量S0\t10S1\t5S2\t7进程 Max\tAllocation\tNeed\tAvailable\tFinishP0\t7 5 3 0 1 0 7 4 3 2 3 0 falseP1\t3 2 2 3 0 2 0 2 0 falseP2\t9 0 2 3 0 2 6 0 0 falseP3\t2 2 2 2 1 1 0 1 1 falseP4\t4 3 3 0 0 2 4 3 1 false输入操作代号：1T0时刻的安全性：进程 Work\tNeed\tAllocation\tWork+Allocation\tFinishP1\t2 3 0 0 2 0 3 0 2 5 3 2 trueP3\t5 3 2 0 1 1 2 1 1 7 4 3 trueP4\t7 4 3 4 3 1 0 0 2 7 4 5 trueP0\t7 4 5 7 4 3 0 1 0 7 5 5 trueP2\t7 5 5 6 0 0 3 0 2 10 5 7 true安全序列：-&gt;P1-&gt;P3-&gt;P4-&gt;P0-&gt;P2输入操作代号：2输入进程代号：4输入请求资源数：3 3 0分配不安全输入操作代号：1T0时刻的安全性：进程 Work\tNeed\tAllocation\tWork+Allocation\tFinishP1\t2 3 0 0 2 0 3 0 2 5 3 2 trueP3\t5 3 2 0 1 1 2 1 1 7 4 3 trueP4\t7 4 3 4 3 1 0 0 2 7 4 5 trueP0\t7 4 5 7 4 3 0 1 0 7 5 5 trueP2\t7 5 5 6 0 0 3 0 2 10 5 7 true安全序列：-&gt;P1-&gt;P3-&gt;P4-&gt;P0-&gt;P2输入操作代号：2输入进程代号：0输入请求资源数：0 2 0T0时刻资源分配图：资源\t资源数量S0\t10S1\t5S2\t7进程 Max\tAllocation\tNeed\tAvailable\tFinishP0\t7 5 3 0 3 0 7 2 3 2 1 0 falseP1\t3 2 2 3 0 2 0 2 0 falseP2\t9 0 2 3 0 2 6 0 0 falseP3\t2 2 2 2 1 1 0 1 1 falseP4\t4 3 3 0 0 2 4 3 1 false输入操作代号：1T0时刻的安全性：系统不安全输入操作代号：4操作结束！！！！ 完整代码TestBankerClass类： 123456789101112131415161718192021222324252627package bankerTest;import java.util.Scanner;public class TestBankerClass &#123;\tpublic static void main(String[] args) &#123; // TODO Auto-generated method stub Banker banker = new Banker(); int n; boolean flag=true; Scanner input = new Scanner(System.in); System.out.println(&quot; *************菜单****************&quot;); System.out.println(&quot;进行安全性检查：1 请求再分配资源：2 退出：其他&quot;); System.out.println(&quot;*********************************&quot;); while(flag)&#123; System.out.print(&quot;输入操作代号：&quot;); n = input.nextInt(); switch(n)&#123; case 1:\tbanker.Security_examine();break; case 2:\tbanker.Reallocation();break; default:flag = false; System.out.print(&quot; 操作结束！！！！&quot;); &#125; &#125; input.close();//关闭流\t&#125;&#125; Banker类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202package bankerTest;import java.util.Scanner;class Banker&#123;\t//定义数组\tint ID[], //进程代号 M, //m个进程 N, //n类资源 All[], //系统各资源数量 Max[][], //m个进程对n类资源的最大需求量 Allocation[][],\t//m个进程已经得到n类资源的资源量 Need[][], //m个进程还需要n类资源的资源量 Available[][];\t//系统可用资源数\tboolean Finish[];\t//标记进程是否完成\tint a=0; //Available的第一个下标\tpublic Banker() &#123;\t//无参构造器 @SuppressWarnings(&quot;resource&quot;)//忽视输入流未关闭的报错 Scanner input = new Scanner(System.in); System.out.println(&quot;请输入进程数&quot;); M = input.nextInt();//m个进程 System.out.println(&quot;请输入资源种类数&quot;); N = input.nextInt();//n类资源 //初始化数组 ID = new int[M]; //进程代号 All = new int[N]; //系统各资源数量 Max = new int[M][N]; //m个进程对n类资源的最大需求量 Allocation = new int[M][N];\t//m个进程已经得到n类资源的资源量 Need = new int[M][N]; //m个进程还需要n类资源的资源量 Available = new int[M+1][N]; //系统可用资源数 Finish = new boolean[M];\t//标记进程是否完成 System.out.println(&quot;请输入系统初始可用资源数&quot;); for(int i=0; i&lt;N; i++)//系统初始可用资源数 All[i] = input.nextInt(); System.out.println(&quot;请输入&quot;+M+&quot;个进程对&quot;+N+&quot;类资源的最大需求量&quot;); for(int i=0; i&lt;M; i++)&#123;//m个进程对n类资源的最大需求量 ID[i] = i; for(int j=0; j&lt;N; j++) Max[i][j] = input.nextInt(); &#125; System.out.println(&quot;请输入&quot;+M+&quot;个进程已经得到的&quot;+N+&quot;类资源的资源量&quot;); for(int i=0; i&lt;M; i++)\t//m个进程已经得到n类资源的资源量 for(int j=0; j&lt;N; j++) Allocation[i][j] = input.nextInt(); Need_Resources(); Available_Resources(); Print_Banker();\t&#125;\tprivate void Need_Resources() &#123;//初始化Need矩阵 // TODO Auto-generated method stub for(int i=0; i&lt;M; i++)//m个进程还需要n类资源的资源量 for(int j=0; j&lt;N; j++) Need[i][j] = Max[i][j] - Allocation[i][j];\t&#125;\tprivate void Available_Resources() &#123;//更新系统当前可用资源数 // TODO Auto-generated method stub for(int n=0; n&lt;N; n++)&#123;//系统目前可用资源数 Available[a][n] = All[n]; for(int m=0; m&lt;M; m++)&#123; Available[a][n] -= Allocation[m][n]; &#125; &#125;\t&#125;\tprivate void Print_Banker() &#123;//T0时刻的资源分配图 System.out.println(&quot; T0时刻资源分配图：&quot;); System.out.print(&quot;资源\\t资源数量 &quot;); for(int i=0; i&lt;N; i++) System.out.printf(&quot;S%d\\t%d &quot;, i, All[i]); System.out.print(&quot; 进程\\t Max\\tAllocation\\tNeed\\tAvailable\\tFinish &quot;); for(int i=0; i&lt;M; i++)&#123; System.out.print(&quot;P&quot;+ID[i]); System.out.print(&quot;\\t&quot;); for(int j=0; j&lt;Max[ID[i]].length; j++)&#123; System.out.printf(&quot;%d &quot;, Max[ID[i]][j]); &#125; System.out.print(&quot;\\t&quot;); for(int j=0; j&lt;Allocation[ID[i]].length; j++)&#123; System.out.printf(&quot;%d &quot;, Allocation[ID[i]][j]); &#125; System.out.print(&quot;\\t\\t&quot;); for(int j=0; j&lt;Need[ID[i]].length; j++)&#123; System.out.printf(&quot;%d &quot;, Need[ID[i]][j]); &#125; System.out.print(&quot;\\t&quot;); if(i == 0)&#123; for(int j=0; j&lt;N; j++)&#123; System.out.printf(&quot;%d &quot;, Available[i][j]); &#125; &#125; System.out.print(&quot;\\t&quot;); System.out.print(&quot;\\t&quot;); System.out.print(Finish[i]); System.out.println(); &#125;\t&#125;\tpublic void Security_examine()&#123;//安全性检测 boolean flag1,\t//所有进程 flag2;\t//每个进程 flag1 = true; while(flag1)&#123; flag1 = false; for(int i=0; i&lt;M; i++)&#123; flag2 = true; for(int j=0; flag2 &amp;&amp; j&lt;N; j++)&#123; if(Need[i][j] &gt; Available[a][j] || Finish[i])&#123;//存在一个条件不满足或者该进程已经完成 flag2 = false; &#125; &#125; if(flag2 &amp;&amp; !Finish[i])&#123;//该进程（第i个进程）可执行 flag1 = true; Finish[i] = true; ID[a] = i; a++;//以此判断所有进程是否都执行，安全检查 for(int j=0; flag2 &amp;&amp; j&lt;N; j++)&#123; Available[a][j] = Available[a-1][j] + Allocation[i][j]; &#125; &#125; &#125; &#125; System.out.println(&quot; T0时刻的安全性：&quot;); if(a == M)&#123; Print_Banker_Se(); System.out.println(&quot; 安全序列：&quot;); for(int i=0; i&lt;M; i++)&#123; System.out.print(&quot;-&gt;P&quot;+ID[i]); &#125; System.out.println(&quot; &quot;); &#125; else&#123; System.out.println(&quot;系统不安全&quot;); &#125;\t&#125; public void Reallocation()&#123;//申请资源 @SuppressWarnings(&quot;resource&quot;) Scanner input = new Scanner(System.in); int[] Request = new int[N]; boolean flag = true; System.out.print(&quot; 输入进程代号：&quot;); int n = input.nextInt(); System.out.print(&quot;输入请求资源数：&quot;); for(int j=0; j&lt;N; j++) Request[j] = input.nextInt(); for(int i=0; i&lt;N; i++)&#123;//合理性检查,可用性检查 if(Request[i] &gt; Need[n][i] || Request[i] &gt; Available[0][i]) flag = false; &#125; if(flag)&#123; for(int i=0; i&lt;N; i++)&#123; Allocation[n][i] += Request[i]; &#125; Init(); Print_Banker(); &#125; else&#123; System.out.println(&quot;分配不安全 &quot;); &#125; &#125;\tprivate void Init() &#123; // TODO Auto-generated method stub a = 0; Need_Resources();//再次初始化 Available_Resources(); for(int i=0; i&lt;M; i++)&#123;//ID初始化 ID[i] = i; Finish[i] = false; &#125;\t&#125;\tprivate void Print_Banker_Se() &#123; System.out.print(&quot; 进程\\t Work\\tNeed\\tAllocation\\tWork+Allocation\\tFinish &quot;); for(int i=0; i&lt;M; i++)&#123; System.out.print(&quot;P&quot;+ID[i]); System.out.print(&quot;\\t&quot;); for(int j=0; j&lt;Available[i].length; j++)&#123; System.out.printf(&quot;%d &quot;, Available[i][j]); &#125; System.out.print(&quot;\\t&quot;); for(int j=0; j&lt;Need[ID[i]].length; j++)&#123; System.out.printf(&quot;%d &quot;, Need[ID[i]][j]); &#125; System.out.print(&quot;\\t&quot;); for(int j=0; j&lt;Allocation[ID[i]].length; j++)&#123; System.out.printf(&quot;%d &quot;, Allocation[ID[i]][j]); &#125; System.out.print(&quot;\\t\\t&quot;); for(int j=0; j&lt;Available[i+1].length; j++)&#123; System.out.printf(&quot;%d &quot;, Available[i+1][j]); &#125; System.out.print(&quot;\\t&quot;); System.out.print(&quot;\\t&quot;); System.out.print(Finish[i]); System.out.println(); &#125;\t&#125;\t&#125;"},{"title":"专栏","path":"/wiki/index.html","content":"本页面还在改进优化中"},{"title":"关于枣糕同学","path":"/about/index.html","content":"本站是枣糕同学的个人站 博主目前在深圳大学计算机与软件学院读研，热衷技术，希望能做出一些更有意思的东西。 后续有作品会发布在本站，希望大家喜欢~ 博主最近在做的事情 生活技术2024 年 10 月 18 日最近本博客的基础完成的差不多了，等域名备案下来，准备把博客部署在服务器上2024 年 9 月 1 日入学深圳大学2024 年 10 月 24 日在 kang 的协助下学会了本地主机和服务器之间的文件传输，但是试图用FTP协议进行文件传输失败了，改成使用SFTP协议进行文件传输，成功了。2024 年 10 月 22 日今天备案成功，顺便研究了一下怎么使用git工具进行分支管理，顺便学习了一下git的一些常用命令，现在已经可以使用git工具进行分支管理了。2024 年 10 月 18 日最近本博客的基础完成的差不多了，等域名备案下来，准备把博客部署在服务器上2021 年 某 月 某 日在 kang 的指导下开始了自己的技术生涯"}]