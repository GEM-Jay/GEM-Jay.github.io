[{"title":"Blog主题美化-sakura","path":"/2024/10/16/Blog主题美化-sakura/","content":"sakura主题美化（本站作者前博客，已经不再使用）本站正在积极优化中，优化完成后将贴出心得优化参考链接： Mashiro.本站原作者 cungudafa.一个很厉害的小姐姐 hojun.从sakura主题魔改本站的大佬 感谢以上大佬代码的开源，枣糕也备受开源精神的感染 感谢在本站优化过程中为枣糕提供帮助的小伙伴： kang.我的好朋友兼本站优化指导 更新日志2021&#x2F;4&#x2F;24 23:58 关于-我？今日更新:“关于—我”下的botui BOTUI:一款自动回复文字、图片、视频的JS聊天机器人框架BotUI，可以自由设置多种选项、触发关键词、输入框等内容，聊天内容或范围也可以自由设置，回复内容可以是文字、图片（GIF亦可）、视频，我在博客中引用了此框架。 优化后图片:详情跳转至关于—我本次优化参考了cungudafa姐姐的教程教程链接修改了主目录\\source\\about\\index.md及sakura/js/botui.js, 具体修改内容参考cungudafa的教程链接 修改了各分类页的图片和内容框架，不过不是很满意，仍在施工中 2021&#x2F;4&#x2F;25 23:58 添加视频HEXO添加视频 添加了分类页的播放器 2021&#x2F;10&#x2F;17 22:26 给文字标题添加css动画博客搁置了好久了，今天来更新一下主题美化首先看看效果： 修改前 修改后 1.给文章标题添加css动画横线修改 themes\\Sakura\\layout\\_widget\\common-article.ejs编辑文章通用属性目录themes\\Sakura\\layout\\_widget\\common-article.ejs 找到如下部分在&lt;p class=&quot;entry-census&quot;&gt;前添加： 1&lt;span class=&quot;toppic-line&quot;&gt;&lt;/span&gt; 添加自定义CSS将添加到style.css里头的自定义 CSS 样式就好啦~直接复制下列代码粘贴到style.css 12345/*标题横线动画*/.single-center header.single-header .toppic-line&#123;position:relative;bottom:0;left:0;display:block;width:100%;height:2px;background-color:#fff;animation:lineWidth 2.5s;animation-fill-mode:forwards;&#125;@keyframes lineWidth&#123;0%&#123;width:0;&#125;100%&#123;width:100%;&#125;&#125; 2.给标题文字添加CSS动画这部分比较简单直接添加自定义css即可 添加自定义CSS 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/*标题动画*/.entry-title &#123;\t-moz-animation: fadeInUp 2s; -webkit-animation:fadeInUp 2s;\tanimation: fadeInUp 2s;&#125;@-moz-keyframes fadeInUp &#123;\t0% &#123; -moz-transform: translateY(200%); transform: translateY(200%); opacity: 0\t&#125;\t50% &#123; -moz-transform: translateY(200%); transform: translateY(200%); opacity: 0\t&#125;\t100% &#123; -moz-transform: translateY(0%); transform: translateY(0%); opacity: 1\t&#125;&#125;@-webkit-keyframes fadeInUp &#123;\t0% &#123; -webkit-transform: translateY(200%); transform: translateY(200%); opacity: 0\t&#125;\t50% &#123; -webkit-transform: translateY(200%); transform: translateY(200%); opacity: 0\t&#125;\t100% &#123; -webkit-transform: translateY(0%); transform: translateY(0%); opacity: 1\t&#125;&#125;@keyframes fadeInUp &#123;\t0% &#123; -moz-transform: translateY(200%); -ms-transform: translateY(200%); -webkit-transform: translateY(200%); transform: translateY(200%); opacity: 0\t&#125;\t50% &#123; -moz-transform: translateY(200%); -ms-transform: translateY(200%); -webkit-transform: translateY(200%); transform: translateY(200%); opacity: 0\t&#125;\t100% &#123; -moz-transform: translateY(0%); -ms-transform: translateY(0%); -webkit-transform: translateY(0%); transform: translateY(0%); opacity: 1\t&#125;&#125;"},{"title":"算法—贪婪算法之田忌赛马","path":"/2024/10/16/算法—贪婪算法之田忌赛马/","content":"贪婪算法之田忌赛马贪婪算法之田忌赛马【问题描述】中国古代的历史故事“田忌赛马”是为大家所熟知的。话说齐王和田忌又要赛马了，他们各派出N匹马，每场比赛，输的一方将要给赢的一方200两黄金，如果是平局的话，双方都不必拿出钱。现在每匹马的速度值是固定而且已知的，而齐王出马也不管田忌的出马顺序。请问田忌该如何安排自己的马去对抗齐王的马，才能赢取最多的钱？ 输入第一行为一个正整数n (n &lt;&#x3D; 2000) ，表示双方马的数量。第二行有N个整数表示田忌的马的速度。第三行的N个整数为齐王的马的速度。 输出仅有一行，为田忌赛马可能赢得的最多的钱，结果有可能为负。 输入示例392 83 7195 87 74 输出示例200 C语言的实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;stdio.h&gt;#define MAX 1000int t[MAX],w[MAX];void sort(int n,int t[])&#123;\tint i,j,temp;\tfor(i=1;i&lt;=n;i++) for(j=1;j&lt;=n-i;j++) &#123; if(t[j]&gt;t[j+1]) &#123; temp=t[j]; t[j]=t[j+1]; t[j+1]=temp; &#125; &#125;&#125;int main()&#123;\tint n;\tprintf(&quot;请输入双方赛马数量n:&quot;);\tscanf(&quot;%d&quot;,&amp;n);\tprintf(&quot;请录入田忌赛马速度:&quot;);\tfor(int i=1;i&lt;=n;i++)\t&#123; scanf(&quot;%d&quot;,&amp;t[i]);\t&#125;\tprintf(&quot;请录入齐王赛马速度:&quot;);\tfor(i=1;i&lt;=n;i++)\t&#123; scanf(&quot;%d&quot;,&amp;w[i]);\t&#125;\tsort(n,t);\tsort(n,w);\tint tj_min=1,tj_max=n,qw_min=1,qw_max=n,count=0,sum;\twhile(n--)\t&#123; if(t[tj_max]&gt;w[qw_max]) &#123; count++; tj_max--; qw_max--; &#125; else if(t[tj_max]&lt;w[qw_max]) &#123; count--; tj_min++; qw_max--; &#125; else &#123; if(t[tj_min]&gt;w[qw_min]) &#123; count++; tj_min++; qw_min++; &#125; else &#123; if(t[tj_min]&lt;w[qw_max]) count--; tj_min++; qw_max--; &#125; &#125;\t&#125;\tsum=count*200;\tprintf(&quot;最终田忌最多可以拿到%d的奖金 &quot;,sum);\treturn 0;&#125; 运行截图"},{"title":"算法—贪婪算法之背包问题","path":"/2024/10/16/算法—贪婪算法之背包问题/","content":"贪婪算法之背包问题算法描述设有编号为1、2、…、n的n个物品，它们的重量分别为w1、w2、…、wn，价值分别为v1、v2、…、vn，其中wi、vi（1≤i≤n）均为正数。 有一个背包可以携带的最大重量不超过W。求解目标：在不超过背包负重的前提下，使背包装入的总价值最大（即效益最大化），与0&#x2F;1背包问题的区别是，这里的每个物品可以取一部分装入背包。 C语言的实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;stdio.h&gt;#define MAX 101void sort(int n,float w[],float v[])&#123;\tint i,j;\tfloat temp1,temp2;\tfor(i=1;i&lt;=n;i++) for(j=1;j&lt;=n-i;j++) &#123; temp1=v[j]/w[j]; temp2=v[j+1]/w[j+1]; if(temp1&lt;temp2) &#123; float temp; temp=w[j]; w[j]=w[j+1]; w[j+1]=temp; temp=v[j]; v[j]=v[j+1]; v[j+1]=temp; &#125; &#125;&#125;int main()&#123;\tfloat p[MAX],w[MAX],v[MAX];\tint n;\tfloat M;\tprintf(&quot;请输入物品总数n和背包最大容纳重量M:&quot;);\tscanf(&quot;%d %f&quot;,&amp;n,&amp;M);\tfor(int i=1;i&lt;=n;i++)\t&#123; printf(&quot;请输入第%d件物品的重量和价值:&quot;,i); scanf(&quot;%f %f&quot;,&amp;w[i],&amp;v[i]);\t&#125;\tsort(n,w,v);\tfloat c=M;\tfor(i=1;i&lt;=n;i++)\t&#123; p[i]=0;\t&#125;\tfor(i=1;i&lt;=n;i++)\t&#123; if(c&gt;=w[i]) &#123; p[i]=1; c=c-w[i]; &#125; else &#123; p[i]=c/w[i]; break; &#125;\t&#125;\tfor(i=1;i&lt;=n;i++)\t&#123; printf(&quot;重量为%.0f,价值量为%.0f,的物品，放入的比例为%.2f &quot;,w[i],v[i],p[i]);\t&#125;\treturn 0;&#125; 运行截图"},{"title":"算法—动态规划算法求数塔问题","path":"/2024/10/16/算法—动态规划算法求数塔问题/","content":"动态规划算法求数塔问题算法描述【实验目的】1.掌握动态算法的思想和求解问题的步骤；2.用动态规划算法策略求解数塔问题；3.用动态规划算法策略求解收获花生问题。 【实验内容】1．动态规划算法求解数塔问题 【问题描述】数塔问题有如下图所示的一个数塔，从顶部出发，在每一结点可以选择向左走或是向右走，一直走到底层，要求找出一条路径，使路径上的数值和最大。 【算法设计】给出算法设计思想，并用动态规划算法实现。 C语言的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;stdio.h&gt;#define MAX 1000int data[MAX][MAX];int dp[MAX][MAX];int n;void tower_walk()&#123;\tfor(int i=1;i&lt;=n;i++)\t&#123; dp[n][i]=data[n][i];\t&#125;\tint temp_max;\tfor(i=n;i&gt;=1;i--)\t&#123; for(int j=1;j&lt;=i;j++) &#123; if(dp[i+1][j]&gt;dp[i+1][j+1]) temp_max=dp[i+1][j]; else if(dp[i+1][j]&lt;dp[i+1][j+1]) temp_max=dp[i+1][j+1]; else temp_max=dp[i+1][j]; //\ttemp_max=max(dp[i+1][j],dp[i+1][j+1]); dp[i][j]=temp_max+data[i][j]; &#125;\t&#125;&#125;int\tprint_tower()&#123;\tprintf(&quot;最大路径和是:%d &quot;,dp[1][1]);\tint node_value;\tprintf(&quot;最大路径是:%d&quot;,data[1][1]);\tint j=1;\tfor(int i=2;i&lt;=n;i++)\t&#123; node_value=dp[i-1][j]-data[i-1][j]; if(node_value==dp[i][j+1]) ++j; printf(&quot;--&gt;%d&quot;,data[i][j]);\t&#125;\tprintf(&quot; &quot;);\treturn 0;&#125;int main()&#123;\tprintf(&quot;请输入塔的层数n:&quot;);\tscanf(&quot;%d&quot;,&amp;n);\tprintf(&quot;请输入塔每个节点的数据(第i层有i个节点): &quot;);\tfor(int i=1;i&lt;=n;i++)\t&#123; for(int j=1;j&lt;=i;j++) &#123; scanf(&quot;%d&quot;,&amp;data[i][j]); &#125;\t&#125;\ttower_walk();\tprint_tower();\treturn 0;&#125; 运行截图"},{"title":"算法—动态规划算法求收花生问题","path":"/2024/10/16/算法—动态规划算法求收花生问题/","content":"动态规划算法求收花生问题算法描述【问题描述】收获花生问题咚咚想摘点花生送给她喜欢的米老鼠。她来到一片有网格状道路的矩形花生地(如下图)，从西北角进去，东南角出来。地里每个道路的交叉点上都有种着一株花生苗，上面有若干颗花生，经过一株花生苗就能摘走该它上面所有的花生。咚咚只能向东或向南走，不能向西或向北走。问咚咚最多能够摘到多少颗花生。 【输入】第一行是一个整数T，代表一共有多少组数据。1&lt;&#x3D;T &lt;&#x3D; 100接下来是T组数据。每组数据的第一行是两个整数，分别代表花生苗的行数R和列数 C ( 1&lt;&#x3D; R,C &lt;&#x3D;100)每组数据的接下来R行数据，从北向南依次描述每行花生苗的情况。每行数据有 C 个整数，按从西向东的顺序描述了该行每株花生苗上的花生数目 M ( 0&lt;&#x3D; M &lt;&#x3D; 1000)。 【输出】【样例输入】22 21 13 42 32 3 41 6 5【样例输出】816 对每组输入数据，输出一行，内容为能摘到得最多的花生颗数。 【问题分析】根据题意只能向东或者向南走，不能向西或向北走。所以这道题不用判断是不是访问过，直接选取最大的经过的数来代替，然后把最后一个数输出就大功告成了。以下是具体思路图片。 【算法设计】给出算法设计思想，并用动态规划算法实现。 C语言的实现123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;#define MAX 1000int w[MAX][MAX];int f[MAX][MAX];int t,n,m;int main()&#123;\tprintf(&quot;请输入数据组数t的值:&quot;); scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; printf(&quot;请输入行数n和列数m的值:&quot;); scanf(&quot;%d %d&quot;,&amp;n,&amp;m); printf(&quot;请输入每个节点上的花生数量 &quot;); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) scanf(&quot;%d&quot;,&amp;w[i][j]); for(i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++)&#123; if(f[i-1][j]&gt;f[i][j-1]) f[i][j] = f[i-1][j]+w[i][j]; else f[i][j] = f[i][j-1]+w[i][j]; &#125; printf(&quot;可以摘到的花生的总和的最大值是:%d &quot;,f[n][m]); &#125;\treturn 0;&#125; 运行截图"},{"title":"算法—动态规划算法求最长公共子序列问题","path":"/2024/10/16/算法—动态规划算法求最长公共子序列问题/","content":"动态规划算法求最长公共子序列问题问题描述【问题描述】字符序列的子序列是指从给定字符序列中随意地（不一定连续）去掉若干个字符（可能一个也不去掉）后所形成的字符序列。给定两个字符序列A和B，如果字符序列Z既是A的子序列，又是B的子序列，则称序列Z是A和B的公共子序列。该问题是求两序列A和B的最长公共子序列（LCS）。【问题分析】dp[i][j]为子序列（a0，a1，…，ai-1）和（b0，b1，…，bj-1）的最长公共子序列的长度。对应的状态转移方程如下： C语言的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;stdio.h&gt;#include&lt;string.h&gt;char str1[100];char str2[100];int c[100][100]; int b[100][100];void print_LCS(int lenght1, int lenght2)&#123;\tif(lenght1 == 0 || lenght2 == 0)&#123; return; &#125;\tif(b[lenght1][lenght2] == 1)&#123; print_LCS(lenght1-1,lenght2-1); printf(&quot;%c&quot;,str1[lenght1-1]); &#125; else if(b[lenght1][lenght2] == 2)&#123; print_LCS(lenght1-1,lenght2); &#125;else&#123; print_LCS(lenght1,lenght2-1); &#125; &#125;void LCS(char str1[], char str2[])&#123; int str1_lenght, str2_lenght; str1_lenght = strlen(str1); str2_lenght = strlen(str2); if(str1_lenght == 0 || str2_lenght == 0)&#123; printf(&quot;%s &quot;, &quot;No sub seqence&quot;); return;\t&#125; int i, j;\tfor(i = 0; i &lt;= str1_lenght; i++)&#123; c[i][0] = 0;\t&#125; for(j = 0; j &lt;= str2_lenght; j++)&#123; c[0][j] = 0; &#125; for(i = 1; i &lt;= str1_lenght; i++)&#123; for(j = 1; j &lt;= str2_lenght; j++)&#123; if (str1[i-1] == str2[j-1])&#123; c[i][j] = c[i-1][j-1] + 1; b[i][j] = 1; &#125; else if(c[i-1][j] &gt; c[i][j-1])&#123; c[i][j] = c[i-1][j]; b[i][j] = 2; &#125; else&#123; c[i][j] = c[i][j-1]; b[i][j] = 3; &#125; &#125; &#125; if(c[str1_lenght][str2_lenght] &lt;= 0)&#123; printf(&quot;%s &quot;,&quot;No sub squence&quot;); return; &#125; printf(&quot;size = %d &quot;, c[str1_lenght][str2_lenght]); print_LCS(str1_lenght,str2_lenght); printf(&quot; &quot;);&#125;int main()&#123; printf(&quot;请输入第一个字符串:&quot;); scanf(&quot;%s&quot;, str1); printf(&quot;请输入第二个字符串:&quot;); scanf(&quot;%s&quot;, str2); LCS(str1,str2); return 0;&#125; 运行截图"},{"title":"算法—动态规划算法求最大子段和","path":"/2024/10/16/算法—动态规划算法求最大子段和/","content":"动态规划算法求最大子段和问题描述【问题描述】给定由n个整数组成的序列a1,a2,…,an，求该序列子段和的最大值。当所有整数均为负值时定义其最大子段和为0。依此定义， 例如， 当(a1,a2, a3, a4, a5,a6)&#x3D;(-2, 11, -4, 13, -5, -2)时，最大子段和为20。【问题分析】 【算法设计】给出算法设计思想，并用动态规划算法实现。 C语言的实现1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;#define MAX 100int a[MAX]; int MaxSum(int a[],int n)&#123;\tint temp = 0;\tint maxsum = 0;\tfor(int i=1;i&lt;=n;i++)&#123; if(temp&lt;0) temp=a[i]; else temp=temp+a[i]; if(temp &gt; maxsum)&#123; maxsum = temp; &#125;\t&#125;\treturn maxsum;\t&#125;int main()&#123;\tint n;\tprintf(&quot;请输入n的值:&quot;);\tscanf(&quot;%d&quot;,&amp;n);\tprintf(&quot;请依次输入元素:&quot;);\tfor(int i=1;i&lt;=n;i++)&#123; scanf(&quot;%d&quot;,&amp;a[i]);\t&#125;\tprintf(&quot;最大子段和为:%d &quot;,MaxSum(a,n)); return 0;&#125; 运行截图"},{"title":"算法—回溯法求解01背包问题","path":"/2024/10/16/算法—回溯法求解01背包问题/","content":"回溯法求解01背包问题算法描述【问题描述】有n个重量分别为{w1，w2，…，wn}的物品，它们的价值分别为{v1，v2，…，vn}，给定一个容量为W的背包。设计从这些物品中选取一部分物品放入该背包的方案，每个物品要么选中要么不选中，要求选中的物品不仅能够放到背包中，而且满足重量限制具有最大的价值。 C语言实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;stdio.h&gt;float w[100],p[100];int x1[100],x[100],m,n;float max=0,total=0;int knap(int i)&#123;\tint j;\tfloat sum=0;\tif(i==n+1)\t&#123; for(j=1;j&lt;=n;j++) sum=sum+x1[j]*p[j]; if(sum&gt;max) &#123; max=sum; for(j=1;j&lt;=n;j++) x[j]=x1[j]; &#125; return 0;\t&#125;\tx1[i]=0;\tknap(i+1);\tif(total+w[i]&lt;=m)\t&#123; x1[i]=1; total=total+w[i]; knap(i+1); x1[i]=0; total=total-w[i];\t&#125;\treturn 0;&#125;int main()&#123;\tint s=0,sum=0,i;\tprintf(&quot;请输入背包的总容量m和物品件数n的值:&quot;);\tscanf(&quot;%d %d&quot;,&amp;m,&amp;n);\tfor(i=1;i&lt;=n;i++)\t&#123; printf(&quot;请输入第%d件物品的重量和价值:&quot;,i); scanf(&quot;%f %f&quot;,&amp;w[i],&amp;p[i]); s+=w[i]; sum+=p[i];\t&#125;\tif(s&lt;=m)\t&#123; printf(&quot;%d %d&quot;,m,sum); printf(&quot;最大价值为%d&quot;,sum); return 0;\t&#125;\telse knap(1);\tfor(i=1;i&lt;=n;i++) printf(&quot;x%d=%d &quot;,i+1,x[i]);\tprintf(&quot;最大价值为%.2f&quot;, max);\treturn 0;&#125; 运行截图"},{"title":"算法—回溯法求解七巧板涂色问题","path":"/2024/10/16/算法—回溯法求解七巧板涂色问题/","content":"回溯法求解七巧板涂色问题算法描述【问题描述】有如图所示的七巧板，试编写一源程序如下，使用至多四种不同颜色对七巧板进行涂色(每块涂一种颜色)，要求相邻区域的颜色互不相同，打印输出所有可能的涂色方案。【问题分析】为了让算法能识别不同区域间的相邻关 系，我们把七巧板上每一个区域看成一个顶点若两个区域相邻，则相应的顶点间用一条边相连，这样该问题就转化为图一个图的搜索问题了。 C语言实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;int m, pointnum, edgenum, sum = 0;int Graph[100][100], x[100];void InPut() &#123; int pos1, pos2; printf(&quot;请输入点的个数和色数(p m)：&quot;); scanf(&quot;%d%d&quot;,&amp;pointnum,&amp;m); printf(&quot;请输入边的个数: &quot;); scanf(&quot;%d&quot;,&amp;edgenum); printf(&quot;输入边的起始点信息(起点 终点)： &quot;); for(int i = 1; i &lt;= edgenum; ++i) &#123; scanf(&quot;%d%d&quot;,&amp;pos1,&amp;pos2); Graph[pos1][pos2] = Graph[pos2][pos1] = 1; &#125;&#125;int IsOk(int i) &#123; for(int j = 1; j &lt; i; ++j) if(Graph[i][j] == 1 &amp;&amp; x[j] == x[i]) return 0; return 1;&#125;void BackTrack(int i) &#123; if(i &gt; pointnum) &#123; sum += 1; printf(&quot;方法 %d:&quot;,sum); for(int j = 1; j &lt;= pointnum; ++j) &#123; printf(&quot; %d&quot;,x[j]); &#125; printf(&quot; &quot;); &#125; else &#123; for(int j = 1; j &lt;= m; ++j) &#123; x[i] = j; if(IsOk(i)) BackTrack(i + 1); x[i] = 0; &#125; &#125;&#125;int main() &#123; InPut(); BackTrack(1); printf(&quot;一共有%d种绘色方案&quot;,sum);&#125; 运行截图"},{"title":"算法—矩阵最长滑翔路径","path":"/2024/10/16/算法—矩阵最长滑翔路径/","content":"算法——矩阵最长滑翔路径算法描述【问题描述】在一个C行R列的矩阵M中，其元素M[i][j]可以滑翔到相邻的上下左右的四个元素中的一个(当然不能超出矩阵的边界)，当且仅当相邻的元素比它要小，因为只能从高处滑翔到低处，每滑翔到一个元素，路径长度加1，现在要求你编程计算该矩阵中最长的滑翔路径长度是多少。要求输入矩阵的行列数和各元素的值，计算输出该矩阵中最长的滑翔路径长度。并给出路径。【输入样例】5 51 2 3 4 516 17 18 19 615 24 25 20 714 23 22 21 813 12 11 10 9【输出样例】2525 24……1 C语言实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;stdio.h&gt;#include&lt;string.h&gt;int G[100][100],len[100][100],have[100][100];int n,m,mov[2][4]=&#123;0,0,1,-1,1,-1,0,0&#125;;bool bound(int p,int q) &#123; return p&gt;n||p&lt;1||q&gt;m||q&lt;1;&#125;int DFS(int p,int q)&#123; if(have[p][q]) return len[p][q]; int ans=1; for(int i=0;i&lt;4;i++) &#123; int np=p+mov[0][i],nq=q+mov[1][i]; if(bound(np,nq)) continue; if(G[p][q]&gt;G[np][nq])&#123; if(ans&gt;DFS(np,nq)+1) ans=ans; else &#123; ans=DFS(np,nq)+1; &#125; &#125; &#125; len[p][q]=ans; have[p][q]=1; return ans; &#125;int main()&#123;\tint i,j,maxi,maxj;\tprintf(&quot;请输入行列数(用空格分隔): &quot;); scanf(&quot;%d %d&quot;,&amp;n,&amp;m);\tG[0][0]=0;\tprintf(&quot;请输入矩阵的值: &quot;); for(i=1;i&lt;=n;i++) for(j=1;j&lt;=m;j++) &#123; scanf(&quot;%d&quot;,&amp;G[i][j]); have[i][j]=0; &#125; int ans=0; for(i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) &#123; len[i][j]=DFS(i,j); if(ans&gt;len[i][j]) ans=ans; else &#123; ans=len[i][j]; maxi=i; maxj=j; &#125; &#125; printf(&quot;最长滑翔长度是%d &quot;,ans);\tfor(i=ans;i&gt;1;i--) printf(&quot;%d-&quot;,i);\tprintf(&quot;1&quot;); return 0;&#125; 运行截图"},{"title":"Mysql基础命令","path":"/2024/10/16/Mysql基础命令/","content":"mysql基基础——常用命令一、MySQL——常用命令1、创建数据库（Create）12345678mysql&gt; create database db_name; -- 创建数据库mysql&gt; show databases; -- 显示所有的数据库mysql&gt; drop database db_name; -- 删除数据库mysql&gt; use db_name; -- 选择数据库mysql&gt; create table tb_name (字段名 varchar(20), 字段名 char(1)); -- 创建数据表模板mysql&gt; show tables; -- 显示数据表mysql&gt; desc tb_name； -- 显示表结构mysql&gt; drop table tb_name； -- 删除表 例如：创建学生表 1234567create table Student( Sno char(10) primary key, Sname char(20) unique, Ssex char(2), Sage smallint, Sdept char(20))； 2、插入数据（Insert）insert into 语句用于向表格中插入新的行: 1234/*第一种形式无需指定要插入数据的列名，只需提供被插入的值即可：*/mysql&gt; insert into tb_name values (value1,value2,value3,...);/*第二种形式需要指定列名及被插入的值：*/mysql&gt; insert into tb_name (column1,column2,column3,...) values (value1,value2,value3,...); 例如：插入数据 1234mysql&gt; insert into Student values ( 20180001,张三,男,20,CS）;mysql&gt; insert into Student values ( 20180002,李四,男,19,CS）;mysql&gt; insert into Student (Sno,Sname,Ssex,Sage,Sdept) values ( 20180003,王五,男,18,MA）;mysql&gt; insert into Student (Sno,Sname,Ssex,Sage,Sdept) values ( 20180004,赵六,男,20,IS）; 3、查询数据（Select）select语句除了可以查看数据库中的表格和视图的信息外,还可以查看 SQL Server的系统信息、复制、创建数据表。其查询功能强大，是SQL语言的灵魂语句，也是SQL中使用频率最高的语句。 基本select语句：一个基本的select语句可分解成三个部分：查找什么数据（select）、从哪里查找（from）、查找的条件是什么（where）。 select 语句的一般格式如下： 1234567select &lt;目标列表达式列表&gt;[into 新表名]from 表名或视图名[where &lt;条件&gt;][group by &lt;分组表达式&gt;][having &lt;条件&gt;][order by &lt;排序表达式&gt;[ASC|DESC]] (一)查询指定的列1.查询表中所有列在select语句指定列的位置上使用*号时，表示查询表的所有列。 1select * from tb_name 2.查询表中指定的列查询多列时，列名之间要用逗号隔开。 1select tb_name.&lt;字符型字段&gt;,&lt;字符型字段&gt;... from tb_name; 3.指定查询结果中的列标题通过指定列标题（也叫列别名）可使输出结果更容易被人理解。指定列标题时，可在列名之后使用AS子句；也可使用:列别名&#x3D;&lt;表达式&gt;的形式指定列标题。 AS子句的格式为：列名或计算表达式 [AS] 列标题 1select &lt;字符型字段&gt; as 列标题1,&lt;字符型字段&gt; as 列标题2, &lt;字符型字段&gt; as 列标题3 from bt_name； 4.查询经过计算的列（即表达式的值）使用select对列进行查询时，不仅可以直接以列的原始值作为结果，而且还可以将列值进行计算后所得值作为查询结果，即select子句可以查询表达式的值,表达式可由列名、常量及算术运算符组成。查询结果计算列显示“无列名”,一般要给计算列加列标题。其中：表达式中可以使用的运算符有：加+、减-、乘*、除&#x2F;、取余% 1select &lt;字符型字段&gt;,&lt;字符型字段&gt;,列标题 = &lt;字符型字段&gt; * n from tb_name； (二)选择行：选择表中的部分行或全部行作为查询的结果1select [all|distinct] [top n[percent]]&lt;目标列表达式列表&gt; from 表名 1. 消除查询结果中的重复行对于关系数据库来说，表中的每一行都必须是不同的(即无重复行)。但当对表进行查询时若只选择其中的某些列，查询结果中就可能会出现重复行。在select语句中使用distinct关键字可以消除结果集中的重复行 1select distinct &lt;字符型字段&gt;[,&lt;字符型字段&gt;,...] from tb_name； 2. 限制查询结果中的返回行数使用top选项可限制查询结果的返回行数，即返回指定个数的记录数。其中：n是一个正整数，表示返回查询结果集的前n行；若带percent关键字，则表示返回结果集的前n%行。 12celect top n from tb_name; /*查询前 n 的数据*/celect top n percent from tb_name; /*查询前 n% tb_name的数据*/ (三)查询满足条件的行: 用where子句实现条件查询通过where子句实现,该子句必须紧跟在From子句之后 1select [all|distinct] [top n[percent]]&lt;目标列表达式列表&gt; from 表名 where &lt;条件&gt;； 说明：在查询条件中可使用以下运算符或表达式运算符 运算符标识比较运算符 &lt;&#x3D;，&lt;，&#x3D;，&gt;，&gt;&#x3D;，!&#x3D;，&lt;&gt;，!&gt;，!&lt;范围运算符 between… and，not between… and列举运算符 in，not in模糊匹配运算符 like，not like空值运算符 is null，is not null逻辑运算符 and，or，not 1.使用比较运算符1select * from tb_name where &lt;字符型字段&gt; &gt;=n; 2.指定范围用于指定范围的关键字有两个：between…and和 not between…and。 1select * from tb_name where [not] between &lt;表达式1&gt; and &lt;表达式2&gt;; 其中：between关键字之后的是范围的下限（即低值）,and关键字之后的是范围的上限（即高值）用于查找字段值在（或不在）指定范围的行。 3.使用列举使用in关键字可以指定一个值的集合，集合中列出所有可能的值，当表达式的值与集合中的任一元素个匹配时，即返回true，否则返回false。 1select * from tb_name where &lt;字符型字段&gt; [not] in(值1,值2,...,值n); 4.使用通配符进行模糊查询可用like 子句进行字符串的模糊匹配查询，like子句将返回逻辑值（true或False）。like子句的格式： select * from tb_name where &lt;字符型字段&gt; [not] like &lt;匹配串&gt;；其含义是：查找指定字段值与匹配串相匹配的记录。匹配串中通常含有通配符%和_（下划线）。其中: %：代表任意长度（包括0）的字符串 5.使用null的查询当需要判定一个表达式的值是否为空值时，使用 is null关键字。当不使用not时，若表达式的值为空值，则返回true，否则返回false；当使用not时，结果刚好相反。 1select * from tb_name where &lt;字符型字段&gt; is [not] null; 6.多重条件查询(使用逻辑运算符)逻辑运算符and（与：两个条件都要满足）和or（或：满足其中一个条件即可）可用来联接多个查询条件。and的优先级高于or,但若使用括号可以改变优先级。 1select * from tb_name where &lt;字符型字段&gt; = &#x27;volues&#x27; and &lt;字符型字段&gt; &gt; n; (四)对查询结果排序order by子句可用于对查询结果按照一个或多个字段的值（或表达式的值）进行升序（ASC）或降序（DESC）排列，默认为升序。 1order by &#123;排序表达式[ASC|DESC]&#125;[,...n]； 其中：排序表达式既可以是单个的一个字段，也可以是由字段、函数、常量等组成的表达式，或一个正整数。模板：select * from tb_name order by &lt;排序表达式&gt; &lt;排序方法&gt;； (五)使用统计函数(又称集函数，聚合函数)在对表进行检索时，经常需要对结果进行计算或统计，T-SQL提供了一些统计函数（也称集函数或聚合函数），用来增强检索功能。统计函数用于计算表中的数据，即利用这些函数对一组数据进行计算，并返回单一的值。常用统计函数表 函数名 功能 AVG 求平均值 count 求记录个数，返回int类型整数 max 求最大值 min 求最小值 sum 求和 1. SUM和AVG功能：求指定的数值型表达式的和或平均值。 1select avg(&lt;字符型字段&gt;) as 平均数,sum(&lt;字符型字段&gt;) as 总数 from tb_name where &lt;字符型字段&gt; =&#x27;字符串&#x27;; 2. Max和Min功能：求指定表达式的最大值或最小值。 1select max(&lt;字符型字段&gt;) as 最大值,min(&lt;字符型字段&gt;) as 最小值 from tb_name; 3. count该函数有两种格式：count(_)和count([all]|[distinct] 字段名），为避免出错，查询记录个数一般使用count(_)，而查询某字段有几种取值用count(distinct 字段名）。 (1).count(*):功能：统计记录总数。 1select count(*) as 总数 from tb_name; (2).count([all]|[distinct] 字段名）功能：统计指定字段值不为空的记录个数，字段的数据类型可以是text、image、ntext、uniqueidentifier之外的任何类型。 1select count(&lt;字符型字段&gt;) as 总数 from tb_name; (六)对查询结果分组group by子句用于将查询结果表按某一列或多列值进行分组，列值相等的为一组，每组统计出一个结果。该子句常与统计函数一起使用进行分组统计。 1group by 分组字段[,...n][having &lt;条件表达式&gt;]； 1.在使用group by子句后select列表中只能包含：group by子句中所指定的分组字段及统计函数。 2.having子句的用法having子句必须与group by 子句配合使用，用于对分组后的结果进行筛选（筛选条件中常含有统计函数）。 3. 分组查询时不含统计函数的条件通常使用where子句；含有统计函数的条件,则只能用having子句。 1select &lt;字符型字段&gt;,count(*) as 列标题 from tb_name where &lt;字符型字段&gt;=&#x27;字符串&#x27; group by &lt;字符型字段&gt;； 4、修改数据(Update）Update 语句用于修改表中的数据。 1update tb_name set 列名称 = 新值 where 列名称 = 某值； 5、删除数据(Delete)删除单行 1delete from tb_name where 列名称 = 某值； 删除所有行可以在不删除表的情况下删除所有的行。这意味着表的结构、属性和索引都是完整的： 1delete * from tb_name 或 delete from tb_name； 二、MySQL——alter命令alter add命令用来增加表的字段。alter add命令格式：alter table 表名 add字段 类型 其他; 例如，在表MyClass中添加了一个字段passtest，类型为int(4)，默认值为0： 1mysql&gt; alter table MyClass add passtest int(4) default &#x27;0&#x27;; 添加两个字段 1mysql&gt; alter table Person add age int,add address varchar(11); 删除两个字段 1mysql&gt; alter table Person drop column age,drop column address; 修改字段的注释 1mysql&gt; alter table `student` modify column `id` comment &#x27;学号&#x27;; 1)加索引mysql&gt; alter table 表名 add index 索引名 (字段名1[，字段名2 …]); 1mysql&gt; alter table employee add index emp_name (name); 2)加主关键字的索引mysql&gt; alter table 表名 add primary key (字段名); 1mysql&gt; alter table employee add primary key(id); 3)加唯一限制条件的索引mysql&gt; alter table 表名 add unique 索引名 (字段名); 1mysql&gt; alter table employee add unique emp_name2(cardnumber); 4)删除某个索引mysql&gt; alter table 表名 drop index 索引名; 1mysql&gt;alter table employee drop index emp_name; 5)添加字段1mysql&gt; ALTER TABLE table_name ADD field_name field_type; 6)修改原字段名称及类型1mysql&gt; ALTER TABLE table_name CHANGE old_field_name new_field_name field_type; 7)删除字段1MySQL ALTER TABLE table_name DROP field_name; 三、MySQL – 应用学生-课程数据库 学生表：Student（Sno，Sname，Ssex，Sage，Sdept） 课程表：Course（Cno，Cname，Cpno，Ccredit） 学生选课表：SC（Sno，Cno，Grade） 关系的主码加下划线表示。各个表中的数据示例如图所示： 一、建立一个“学生”表Student1234567create table Student( Sno char(9) peimary key, /*列级完整性约束条件，Sno是主码*/ Sname char(20) unique, /* Sname取唯一值*/ Ssex char(2), Sage smallint, Sdept char(20)); 二、建立一个“课程”表Course1234567create table Course( Sno char(4) primary key, /*列级完整性约束条件，Cname不能取空值*/ Sname char(40) not null, /*Cpno的含义是先修课*/ Cpno char(4) Ccredit smallint, foreign key (Cpnoo) references Course(Cno) /*表级完整性约束条件，Cpno是外码，被参照表是Course，被参照列是Cno*/); 三、建立学生选课表SC12345678create table SC( Sno char(9), Cno char(4), Grade smallint, frimary key (Sno,Cno), /*主码由两个属性构成，必须作为表级完整性进行定义*/ foreign key (Sno) references Student(Sno), /*表级完整性约束条件，Sno是外码，被参照表是Student*/ foreign key (Cno) references Course(Cno) /*表级完整性约束条件，Cno是外码，被参照表是Course */); 本文转载于MySQL基础 — 常用命令"},{"title":"算法—加法接力赛","path":"/2024/10/16/算法—加法接力赛/","content":"算法—加法接力赛算法描述【问题描述】正在上一年级的小卡卡最近开始学习数的加法运算，一天老师为了测试大家对加法的掌握情况，让同学们做了一个有趣的加法接力赛游戏。老师在黑板上从左到右写下了n个大于零的整数，老师接下来找出n个同学完成下面的计算任务。第一个同学在黑板上抄下最左边的数字，第二个同学负责将第一个同学写下的数字，加上老师写下的左边第二个数字所得到的数写在了黑板上。以此类推，第m个同学将前面第m-1个同学所写下的数字加上老师在黑板上写下的从左边数的第m个数字所得之和，并将结果写到黑板上。当计算完成这n个数字之后，老师又让同学从最右边开始按相同的方法再次计算出n个数值。最后老师让同学们找出这所有数字当中共有多少个是相同的。例如：老师在黑板上写下了7个数，从左到右依次为：3，6，2，1，4，5，2，则同学们第一次从左边开始计算所得到的7个数值应该是：3，9，11，12，16，21，23；而第二次从右边开始计算所得到的7个数值应该是：2，7，11，12，14，20，23；于是第一次与第二次计算出的数值中相同的有3个，它们分别是：11、12与23。【输入】共两行，第一行为n（1&lt;n&lt;100），第二行为n个数，用空格隔开， 每个数的大小在0～200之间。 【输出】第一次与第二次计算出的数值中相同的个数。【输入样例】73 6 2 1 4 5 2【输出样例】3 C语言的实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;stdio.h&gt;#define MAX 100int a[MAX],sum[MAX],sum1[MAX],same[MAX];int i,j,k,n,s,t;void try1()&#123;\tfor(i=1;i&lt;=n;i++) same[i]=0;\tfor(i=1;i&lt;=n;i++)&#123; for(j=1;j&lt;=n;j++)&#123; if(sum[i]==sum1[j]) same[i]=sum[i]; &#125;\t&#125;\tt=0;\tfor(i=1;i&lt;=n;i++)&#123; if(same[i]!=0)&#123; t++; printf(&quot;%d &quot;,same[i]); &#125;\t&#125;\tprintf(&quot; &quot;);\tprintf(&quot;共%d个数相同 &quot;,t);&#125;int main()&#123;\ta[0]=0;\tprintf(&quot;请输入数字总量n:&quot;);\tscanf(&quot;%d&quot;,&amp;n);\tprintf(&quot;请从左到右录入数字(以空格分隔):&quot;);\tfor(i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);\tprintf(&quot;第一次运行: &quot;);\ts=0;\tfor(i=0;i&lt;n;i++)&#123; sum[i+1]=s+a[i+1]; s=sum[i+1];\t&#125;\tfor(i=1;i&lt;=n;i++) printf(&quot;%d &quot;,sum[i]);\tprintf(&quot; 第二次运行: &quot;);\ts=0;\tfor(i=n;i&gt;0;i--)&#123; sum1[n-i+1]=s+a[i]; s=sum1[n-i+1];\t&#125;\tfor(i=1;i&lt;=n;i++) printf(&quot;%d &quot;,sum1[i]);\tprintf(&quot; &quot;);\ttry1();\treturn 0;&#125; 运行截图"},{"title":"算法—矩阵连乘","path":"/2024/10/16/算法—矩阵连乘/","content":"算法—矩阵连乘算法描述【问题描述】给定n个矩阵{A1,A2,…,An}，其中Ai与Ai+1是可乘的，i&#x3D;1,2…,n-1。现在需要研究的问题是如何确定矩阵连乘积的计算次序，使得计算矩阵连乘所需的乘法次数最少。矩阵连乘问题满足结合律, 其计算次序可以用加括号的方式确定，若矩阵连乘已完全加括号，则其计算次序完全确定。例如，有四个矩阵A,B,C,D，它们的维数分别是：A&#x3D;50×10，B&#x3D;10×40, C&#x3D;40×30, D&#x3D;30×5。ABCD矩阵连乘共有五种完全加括号的方式，计算次序和乘法次数如下：(A((BC)D)) 16000 (A(B(CD))) 10500((AB)(CD)) 36000 (((AB)C)D) 87500((A(BC))D) 34500可见不同的计算次序会导致不同的计算代价，我们要做的就是让计算代价最小。【输入】第1行输入连乘矩阵的个数n，第2行依次输入连乘矩阵的大小。【输出】输出包括两行，第1行输出最小的计算量，第2行输出矩阵连乘完全加括号的形式。【输入样例1】450 10 40 30 5【输出样例1】1050(A1) 【输入样例2】35 6 3 4【输出样例2】150((A[1]A[2])A[3]) C语言实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;stdio.h&gt;int N;int p[100],m[100][100],s[100][100];int MatrixChain(int *p,int n)&#123; for(int i=1;i&lt;=n;i++) m[i][i]=0; for(int r=2;r&lt;=n;r++)&#123; for(int i=1;i&lt;=n-r+1;i++)&#123; int j=i+(r-1); m[i][j]=m[i][i]+m[i+1][j]+p[i-1]*p[i]*p[j]; s[i][j]=i; for(int k=i+1;k&lt;j;k++)&#123; int t=m[i][k]+m[k+1][j]+p[i-1]*p[k]*p[j]; if(t&lt;m[i][j])&#123; m[i][j]=t; s[i][j]=k; &#125; &#125; &#125; &#125;\treturn 0;&#125;void Traceback(int i,int j)&#123; if(i==j) &#123; printf(&quot;A%d&quot;,i); &#125; else &#123; printf(&quot;(&quot;); Traceback(i,s[i][j]); Traceback(s[i][j]+1,j); printf(&quot;)&quot;); &#125;&#125;int main()&#123;\tprintf(&quot;请输入矩阵数量:&quot;);\tscanf(&quot;%d&quot;,&amp;N);\tN=N+1;\tprintf(&quot;请输入各矩阵纬度(用空格分隔):&quot;);\tfor(int i=0;i&lt;N;i++) scanf(&quot;%d&quot;,&amp;p[i]);\tMatrixChain(p,N-1); Traceback(1,N-1);\tprintf(&quot; &quot;);\treturn 0;&#125; 运行截图运行截图示例1运行截图示例2"},{"title":"算法—马拦过河卒","path":"/2024/10/16/算法—马拦过河卒/","content":"算法—马拦过河卒算法描述【题目描述】棋盘上A点有一个过河卒，需要走到目标B点。卒行走的规则：可以向下、或者向右。同时在棋盘上的某一点有一个对方的马（如C点），该马所在的点和所有跳跃一步可达的点称为对方马的控制点，如图中的C点和P1，……，P8，卒不能通过对方马的控制点。棋盘用坐标表示，A点(0,0)、B点(n, m) (n,m为不超过20的整数),同样马的位置坐标是需要给出的，C≠A且C≠B。现在要求你计算出卒从A点能够到达B点的路径的条数。（假设马的位置是固定不动的，并不是卒走一步马走一步。）【输入】给出n、m和C点的坐标。【输出】从A点能够到达B点的路径的条数。【输入样例】8 6 0 4【输出样例】1617 C语言实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt; int mmp[20][20];int vis[20][20];int step;int ma[9][2]=&#123;0,0,1,2,1,-2,-1,2,-1,-2,2,1,2,-1,-2,1,-2,-1&#125;;int n,m;int b,c; void bfs(int x,int y)&#123; if(x==n&amp;&amp;y==m) step++; int next[2][2]=&#123;1,0,0,1&#125;; int i; int dx,dy; for(i=0;i&lt;2;i++) &#123; dx=x+next[i][1]; dy=y+next[i][0]; if(dx&lt;0||dx&gt;n||dy&lt;0||dy&gt;m) continue; if(!vis[dx][dy]&amp;&amp;mmp[dx][dy]==0) &#123; vis[dx][dy]=1; bfs(dx,dy); //回溯 vis[dx][dy]=0;\t//回溯前清场 &#125; &#125;&#125;int main()&#123; int i; int dx,dy;\tprintf(&quot;请输入目标B点坐标和马的坐标C:&quot;); scanf(&quot;%d %d %d %d&quot;,&amp;n,&amp;m,&amp;b,&amp;c) ; memset(vis,0,sizeof(vis)); memset(mmp,0,sizeof(mmp)); for(i=0;i&lt;=8;i++) &#123; dx=b+ma[i][0]; dy=c+ma[i][1]; if(dx&lt;0||dx&gt;n||dy&lt;0||dy&gt;m) continue; else mmp[dx][dy]=1; &#125; vis[0][0]=1; bfs(0,0);\tprintf(&quot;从A到B的路径数为:&quot;); printf(&quot;%d &quot;,step); return 0;&#125; 运行截图"},{"title":"算法—加密字符串相似度计算","path":"/2024/10/16/算法—加密字符串相似度计算/","content":"加密字符串相似度计算算法描述【问题描述】现有4个加密的字符串(中间不含空格)，需要分析研究它们的相似度，两个字符串的相似度用其最长公共子系列的长度表示，例如，字符串“ABDECFG”和字符串“ADCGEFA”的一个最长公共子序列为 “ADEF”，所以这两个字符串的相似度为4。现在需要对输入的4个字符串，分别计算它们的相似度，找出相似度最高的一对字符串，若存在多对相似度最高的字符串，应全部输出。【输入】 分4行输入4个字符串。【输出】 按行依次输出相似度最高的一对字符串、它们的相似度、对应的最长公共子序列，若有多组最高相似度相同，应全部输出。【输入样例】ABDECFEBADCEBGHADCFEBBECEBFBD【输出样例】ABDECFEB ADCFEB 6 ADCFEB 输出样例说明：以上4个字符串，共可以构成6组，依次计算它们的相似度如果，因此，相似度最高的是字符串ABDECFEB和ADCFEB，相似度为6，对应的一个最长公共子序列为ADCFEB。ABDECFEB ADCEBGH 5 ADCEBABDECFEB ADCFEB 6 ADCFEBABDECFEB BECEBFBD 5 BECFBADCEBGH ADCFEB 5 ADCEBADCEBGH BECEBFBD 3 CEBADCFEB BECEBFBD 3 CFB C语言实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/*动态规划算法加递归时间复杂度为n方*/#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define MAXLEN 100char s[MAXLEN][MAXLEN];int len[MAXLEN],b[MAXLEN][MAXLEN],c[MAXLEN][MAXLEN];void LCSLength(char *x, char *y, int m, int n, int c[][MAXLEN], int b[][MAXLEN])&#123; int i, j; for (i=0; i&lt;=m;i++) c[i][0]=0; for (j=1; j&lt;=n;j++) c[0][j]=0; for (i=1;i&lt;=m;i++) for (j=1;j&lt;=n;j++) &#123;if (x[i-1]==y[j-1]) &#123;c[i][j]=c[i-1][j-1]+1; b[i][j]=0; &#125; else if(c[i-1][j]&gt;=c[i][j-1]) &#123;c[i][j]=c[i-1][j]; b[i][j]=1; &#125; else &#123;c[i][j]=c[i][j-1]; b[i][j]=-1; &#125; &#125;&#125;void PrintLCS(int b[][MAXLEN], char *x, int i, int j)&#123; if (i==0||j==0) return; if (b[i][j]==0) &#123; PrintLCS(b,x,i-1,j-1); printf(&quot;%c&quot;,x[i-1]); &#125; else if(b[i][j]==1) PrintLCS(b,x,i-1,j); else PrintLCS(b,x,i,j-1);&#125;int main()&#123; printf(&quot;输入: &quot;); for(int i=0;i&lt;4;i++) scanf(&quot;%s&quot;,&amp;s[i]); //为字符串数组s[]赋初值 for(i=0;i&lt;4;i++) len[i]=strlen(s[i]); int maxn=c[len[0]][len[0]]; //c是记录最长公共子序列长度的数组 for(i=0;i&lt;4;i++) for(int j=i+1;j&lt;4;j++) &#123; LCSLength(s[i],s[j],len[i], len[j], c, b); maxn=(maxn&gt;c[len[i]][len[j]])?maxn:c[len[i]][len[j]];//获取公共位数最大值 &#125; printf(&quot;输出：&quot;); for(i=0;i&lt;4;i++) for(int j=i+1;j&lt;4;j++) &#123; LCSLength(s[i], s[j],len[i], len[j], c, b); if(maxn==c[len[i]][len[j]]) &#123; printf(&quot;%s &quot;,s[i]); printf(&quot;%s &quot;,s[j]); printf(&quot;%d &quot;, c[len[i]][len[j]]);//打印公共位数 PrintLCS(b, s[i], len[i], len[j]);//打印子序列 printf(&quot; &quot;); &#125; &#125; return 0;&#125; 运行截图"},{"title":"算法—数字地图","path":"/2024/10/16/算法—数字地图/","content":"数字地图算法描述【问题描述】Jacky在网上发布了通过无人机航拍的某海域的地图，该海域有很多岛屿，为了能更好地分析该区域的航拍地图，地图被数字化为0到9组成矩阵,0表示该位置为大海，数字1到9都表示陆地(海拔不同)，假设在地图坐标m[x][y]处降落，现在要统计降落所在岛屿的面积（有多少个方格），降落点上下左右相连接的陆地为同一岛屿。例如，在如下4行4列的数字化地图中，降落点坐标为(3,3)，则所在岛屿的面积为9 。5 1 0 07 9 1 00 0 7 30 0 4 9 【输入】第1行为两整数m,n(m行，n列)，表示数字化地图m行n列，第2行输入降落地点的坐标x,y，再后面接着输入m行n列的矩阵。【输出】只有1行，为降落点所在岛屿的面积。【输入样例】4 43 35 1 0 02 6 2 00 0 1 90 0 7 5【输出样例】9 C语言实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/*回溯法——深度优先搜索时间复杂度为n方*/#include &lt;stdio.h&gt;#define max 1000int map[max][max];int vis[max][max];//记录i,j位置是否遍历过int m,n,x,y,num=0; int dfs(int x,int y)&#123; //深度优先算法 int i,nx,ny; int dx[4]=&#123;1,0,-1,0&#125;; int dy[4]=&#123;0,1,0,-1&#125;; for (i=0;i&lt;4;i++) &#123; nx=x+dx[i]; ny=y+dy[i]; if (nx&gt;=0 &amp;&amp; nx&lt;m &amp;&amp; ny&gt;=0 &amp;&amp; ny&lt;n &amp;&amp; map[nx][ny]!=0 &amp;&amp; vis[nx][ny]==0)&#123; vis[nx][ny]=1; if(map[nx][ny]!=map[x][y]) &#123; num++;&#125; dfs(nx,ny);//递归 &#125; else continue; &#125; return num;&#125;int main() &#123; int i,j,max1;\tnum=0;\tprintf(&quot;请输入岛的大小(m*n):&quot;); scanf(&quot;%d %d&quot;,&amp;m,&amp;n);\tprintf(&quot;请输入落地点(x*y):&quot;); scanf(&quot;%d %d&quot;,&amp;x,&amp;y);\tfor(i=0;i&lt;m;i++) for(j=0;j&lt;n;j++)&#123; scanf(&quot;%d&quot;,&amp;map[i][j]); &#125;\tfor(i=0;i&lt;m;i++) for(j=0;j&lt;n;j++) vis[i][j]=0;\tif (vis[x][y]==0 &amp;&amp; map[x][y]!=0) &#123; vis[x][y]=1; num=1; max1=dfs(x,y);\t&#125;\tprintf(&quot;所在岛屿面积为:%d &quot;,max1); return 0;&#125; 运行截图"},{"title":"JAVA面向对象三大特征--封装","path":"/2024/10/16/JAVA面向对象三大特征-封装/","content":"JAVA面向对象三大特征—封装封装是面向对象编程中的三大特征之一，在对封装性进行解释时我们有必要先了解一些面向对象的思想，以及相关的概念。当我们想要去描述一系列的关系时我们要用到的最基本结构就是类，其中存在着成员变量和方法，用于记录属性和表达行为。 一、名词解读为了解释封装的概念和作用，需要先来了解一下几个相关的概念，这有助于我们接下来的理解。 1.权限修饰符当我们在一个类中定义成员变量时，会指定一个变量的类型，除此之外，还会有修饰符的部分，在此给出定义成员变量的规范格式： 123// 定义变量[修饰符] 变量类型 变量名称;[修饰符] 变量类型 变量名称 = 初始值; 修饰符起到的作用从字面就可以解释，起到一个修饰和限定的作用，可以使用在成员变量之前的修饰符可以是：public、protected、private、final、static。修饰符与修饰符之间的顺序没有强制要求，其中public、protected、private被称为权限修饰符，可以用来限定类的属性和方法的访问权限，指明在哪些包的哪些类中能够调用到这些属性或方法，是一种一定会存在的修饰符。需要注意的是，这三个单词不能同时出现，当这三个单词都不出现的时候会被认为是默认访问权限，所以权限修饰符一共有四种：private、默认、protected、public。 2.权限对应关系表 private：私有权限，只能在定义的类中访问，在其他类中创建的实例均无法访问 默认：同包可访问权限，在没有声明权限修饰符时为默认权限，允许在同包的其他类访问 protected：受保护权限，允许有继承关系的子类访问 public：公共权限，允许任何类访问 3.属性访问由于权限修饰符在封装特性中的作用只是实现封装性的一种途径，所以在这里只演示private与public的作用，权限修饰符的其他作用将在后续的文章中继续介绍。 1234567src└──edu └──sandtower └──bean │ Person.java └──test │ Test.java 以上为实体类与测试类所在的目录结构，Person实体类所在包：edu.sandtower.bean，Test测试类所在包：edu.sandtower.test，相应代码如下： 123456789package edu.sandtower.bean;public class Person&#123; // 声明公开属性 public String name; // 声明私有属性 private double money;&#125; 123456789101112package edu.sandtower.test;import edu.sandtower.bean.Person;public class Test&#123; public static void main(String[] args)&#123; // 在test包中的Test类中创建Person实例 Person person = new Person(); person.name = &quot;小张&quot;;// 编译通过，可以访问name属性 person.money = 500.0;// 编译失败，无法访问money属性 &#125;&#125; 从上面的例子可以看出，虽然依然是使用Person自己的实例在进行属性的调用，但是我们是在另外一个包中的类发生的调用，所以是不能够访问到private修饰的属性的，在刚开始学习时一定要注意区分。 二、概念阐释1.封装有什么用通过使用权限修饰符，我们可以限定类的成员的被访问权限，那为什么要这样做呢？在很多场景下，我们需要确保我们对属性值的操作均是有效操作，不能违背某些规则。比如，我们定义了一个Person类，具有name和money两个属性，在买东西时需要扣掉相应的金额，原始写法如下： 1234public class Person&#123; public String name; public double money;&#125; 1234567891011public class Test&#123; public static void main(String[] args)&#123; Person person = new Person(); person.money = 500;// 初始金额500元 System.out.println(&quot;购买一张桌子，花费200元&quot;); person.money -= 200; System.out.println(&quot;购买二手PSP，花费350元&quot;); person.money -= 350; System.out.println(&quot;目前余额为：&quot; + person.money);// -50 &#125;&#125; 可以看到，经过代码操作以后可能会导致money的属性为负。看官甲：你自己不加判断赖代码？没错，这个问题我们可以增加判断代码来解决，由于这个操作是对money属性值的操作，我们将它封装成一个方法写在实体类中，于是有了改进之后的代码： class Person{ &#96;public String name; public double money; // 定义一个方法，用于设置money属性的值 public void setMoney(double money)&#123; if(money &gt;= 0)&#123; this.money = money; &#125; &#125; }&#96;&#96;&#96; class Test&#123;123456789101112131415161718 public static void main(String[] args)&#123; Person person = new Person(); person.money = 500;// 初始金额500元 System.out.println(&quot;购买一张桌子，花费200元&quot;); person.setMoney(person.money - 200); System.out.println(&quot;购买二手PSP，花费350元&quot;); person.setMoney(person.money - 350); System.out.println(&quot;目前余额为：&quot; + person.money);// 300 &#125;&#125;```经过上面的改进，我们可以确保money的值不为负数，同时可以看到，当在实体类中定义方法后，使用者需要修改属性值时直接调用方法就可以保证不出问题。但是由于属性值依然可以被直接访问，还不能保证万无一失，于是我们利用权限修饰符使得变量不能被直接访问，同时需要定义一个能够取得属性值的方法。`public class Person\\&#123; public String name; // 声明money属性为private权限 private double money; &#x2F;&#x2F; 定义一个方法，用于设置money属性的值public void setMoney(double money){ if(money &gt;&#x3D; 0){ this.money &#x3D; money; }}&#x2F;&#x2F; 定义一个方法，用于获取money属性的值public double getMoney(){ return this.money;} 1234\\&#125;```none public class Test{ public static void main(String[] args){ Person person &#x3D; new Person(); person.setMoney(500);&#x2F;&#x2F; 初始金额500元，此时已经不能使用对象.属性的方法赋值 System.out.println(“购买一张桌子，花费200元”); person.setMoney(person.getMoney() - 200); System.out.println(“购买二手PSP，花费350元”); person.setMoney(person.getMoney() - 300); System.out.println(“目前余额为：” + person.getMoney());&#x2F;&#x2F; 300 }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354通过以上的案例，我们可以看到进行封装有以下几个作用：防止类的属性被外部代码随意的修改和访问，保证数据的完备性 将对属性的操作转换为方法，更加灵活和安全 使用封装可以隐藏实现的细节：使用者只需要作用，不需要知道过程 在类的定义结构中修改，提高了代码的可维护性，同时又可以不影响外部的使用 通过封装方法可以有效减少耦合 耦合：模块与模块之间，代码与代码之间的关联程度，对属性封装后，和调用相关的代码就会变得相对简单，可以降低耦合### 2.如何进行封装在进行封装时都是出于对属性保护的考虑，可以按照以下两个步骤来进行：使用权限修饰符 使用private作用在属性上，关闭直接访问的入口 使用public作用在方法上，提供调用的入口 定义与属性存取相关的方法 在属性关闭后，我们需要通过方法来获取属性的值以及对属性值进行修改。由于有了方法结构，我们就可以对存入的数据进行判断，对不符合逻辑的数据进行处理。### 3.常规封装方法明白了封装的作用后，我们可以通过自定义方法的方式完成对属性的封装。封装方法和类中定义的其他方法在结构上没有任何的区别，同样都是普通的方法，区别主要在于体现在用途方面：普通方法主要表达该类所能产生的行为 封装方法主要为属性的访问和使用提供了一个入口，作用相对单一 在进入到框架的学习之后，很多对实体类属性自动赋值的操作都是通过调用封装方法实现的，所以我们必须要知道常规封装方法的名称定义和类型设置规则。 对于属性来说我们只会进行两种操作：存和取。那么相应的封装方法应该有一对儿get代表取用：既然是取值，那么就要把属性值进行返回，方法的返回值类型与属性类型相同 set代表存储：既然是存值，那么就要在参数列表中接收想要存入的值，类型与属性类型相同 对于命名方面只要遵从驼峰命名法就好，以get或set开头，大写属性名称的首字母，其余不变，看下面一个例子：```nonepublic class Person&#123; // 使用private声明属性 private String name; private double money; // 使用public声明方法，作为操作属性的入口 public void setName(String name)&#123; this.name = name; &#125; public String getName()&#123; return this.name; &#125; public void setMoney(double money)&#123; // 如有需要，可以在方法中可以自定义其他逻辑 this.money = money; &#125; public double getMoney()&#123; return this.money; &#125;&#125; 由于常规封装方法定义的格式和名称都相对固定，所以一般的编译器都自带自动生成封装方法的功能，这样既方便又能降低出错率，大家一定要掌握。 Eclipse： 属性定义完成后，选择source菜单 -&gt; Generate Getters and Setters… 点击Select All（选择所有属性） -&gt; Generate"},{"title":"Maven的下载与环境配置(Windows)","path":"/2024/10/16/Download and Environment Configuration of Maven/","content":"Maven的下载与环境配置(Windows)一、Maven的主要内容 二、Maven的简介Maven[‘meven]这个词可以翻译为”专家”内行”。作为Apache组织中的一个颇为成功的开源项目，Maven主要服务于基于java平台的项目构建，依赖管理和项目信息管理。 无论是小型的开源类库项目，还是大型的企业级应用;无论是传统的瀑布式开发，还是流行的敏捷开发，Maven都能大显身手。 本文将教你掌握Maven的安装以及配置方法。 三、Maven的下载在maven的官网可以下载，点击跳转maven官网下载页选择Files-&gt;Link-&gt;apache-maven-3.x.x-bin.zip点击下载即可。下载解压后，文件目录结构如下： 四、Maven常用配置！！！在配置之前请务必将JDK安装好。 1.环境变量配置选择此电脑（右键）--&gt; 属性 \\--&gt; 高级系统设置进入如下页面：新手注意这里分为用户变量和系统变量，对于一台电脑（系统）来说，你是使用它的用户，而同一台电脑可以被另外一个用户使用，所以当更换用户时，你在用户变量配置的环境就消失了，为了方便使用，我们一般将环境变量全部配置在系统变量下，如图所示：点击新建后我们添加Maven的HOME（在后文解释为什么要建立HOME）在变量名一栏中输入MAVEN_HOME在变量值中输入maven的解压的地址，我使用的是自己文件的解压地址，请你换成你自己的,获取解压地址的方法如下：如图复制了之后在变量值中填入D:\\Workspace\\Maven\\apache-maven-3.8.3-bin\\apache-maven-3.8.3(替换成你自己的) 编辑Path接下来编辑Path，配置Path的目的是，当在cmd输入指令的时候，系统会在Path中寻找你的指令是否存在，所以配置Path的步骤最为关键在编辑界面中添加%MAVEN_HOME%\\bin 注：其实前面的HOME不配置都可以，只要把在Path中的%MAVEN_HOME%\\bin换成变量值\\bin是一样的，只不过变量值的路径一般都很长，为了增加可读性，我们会建立一个HOME 测试win+r输入cmd回车在cmd窗口输入mvn -v查看显示如下即为安装成功： 2.修改配置文件通常我们需要修改解压目录下conf/settings.xml文件，这样可以更好的适合我们的使用。 此处注意：所有的修改一定要在注释标签外面，不然修改无效。Maven很多标签都是给的例子，都是注释掉的。 文末附上我的整个Settings.xml文件配置。 本地仓库位置的修改 在标签内添加自己的本地位置路径 1234567 &lt;!-- localRepository | The path to the local repository maven will use to store artifacts. | | Default: $&#123;user.home&#125;/.m2/repository &lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt; --&gt;&lt;localRepository&gt;D:\\tools\\repository&lt;/localRepository&gt; 修改maven默认的JDK版本 在标签下添加一个标签，修改maven默认的JDK版本。 123456789101112&lt;profile&gt; &lt;id&gt;JDK-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;/profile&gt; 添加国内镜像源 添加标签下，添加国内镜像源，这样下载jar包速度很快。默认的中央仓库有时候甚至连接不通。一般使用阿里云镜像库即可。这里我就都加上了，Maven会默认从这几个开始下载，没有的话就会去中央仓库了。 1234567891011121314151617181920212223&lt;!-- 阿里云仓库 --&gt;&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt;&lt;/mirror&gt;&lt;!-- 中央仓库1 --&gt;&lt;mirror&gt; &lt;id&gt;repo1&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://repo1.maven.org/maven2/&lt;/url&gt;&lt;/mirror&gt;&lt;!-- 中央仓库2 --&gt;&lt;mirror&gt; &lt;id&gt;repo2&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://repo2.maven.org/maven2/&lt;/url&gt;&lt;/mirror&gt; 五、常用IDE下配置Maven目前常用的开发工具如idea，eclipse都自身集成了一个版本的Maven。但是通常我们使用自己已经配置好的Maven。 IDEA下配置Maven跟着图片选择然后1：此处修改为自己解压的Maven目录 2：勾选Override，修改为自己目录下的settings.xml目录 3：修改为自己的本地仓库地址，一般会自动识别。 此处勾选，当修改pom文件时，Maven就能帮我们自动导包了。 Eclipse下配置Maven将eclipse使用的Maven修改为自己的。点击add后选择自己Maven的安装目录即可。添加好之后记得勾选。将所有的settings修改为自己Maven目录下的conf&#x2F;settings.xml.点击Update Settings按钮，下面的Local Respository会自动识别出来。 附：完整的Settings.xml文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!--Licensed to the Apache Software Foundation (ASF) under oneor more contributor license agreements. See the NOTICE filedistributed with this work for additional informationregarding copyright ownership. The ASF licenses this fileto you under the Apache License, Version 2.0 (the&quot;License&quot;); you may not use this file except in compliancewith the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing,software distributed under the License is distributed on an&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANYKIND, either express or implied. See the License for thespecific language governing permissions and limitationsunder the License.--&gt;&lt;!-- | This is the configuration file for Maven. It can be specified at two levels: | | 1. User Level. This settings.xml file provides configuration for a single user, | and is normally provided in $&#123;user.home&#125;/.m2/settings.xml. | | NOTE: This location can be overridden with the CLI option: | | -s /path/to/user/settings.xml | | 2. Global Level. This settings.xml file provides configuration for all Maven | users on a machine (assuming they&#x27;re all using the same Maven | installation). It&#x27;s normally provided in | $&#123;maven.conf&#125;/settings.xml. | | NOTE: This location can be overridden with the CLI option: | | -gs /path/to/global/settings.xml | | The sections in this sample file are intended to give you a running start at | getting the most out of your Maven installation. Where appropriate, the default | values (values used when the setting is not specified) are provided. | |--&gt;&lt;settings xmlns=&quot;http://maven.apache.org/SETTINGS/1.2.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.2.0 https://maven.apache.org/xsd/settings-1.2.0.xsd&quot;&gt; &lt;!-- localRepository | The path to the local repository maven will use to store artifacts. | | Default: $&#123;user.home&#125;/.m2/repository &lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt; --&gt; &lt;localRepository&gt;D:\\tools\\repository&lt;/localRepository&gt; &lt;!-- interactiveMode | This will determine whether maven prompts you when it needs input. If set to false, | maven will use a sensible default value, perhaps based on some other setting, for | the parameter in question. | | Default: true &lt;interactiveMode&gt;true&lt;/interactiveMode&gt; --&gt; &lt;!-- offline | Determines whether maven should attempt to connect to the network when executing a build. | This will have an effect on artifact downloads, artifact deployment, and others. | | Default: false &lt;offline&gt;false&lt;/offline&gt; --&gt; &lt;!-- pluginGroups | This is a list of additional group identifiers that will be searched when resolving plugins by their prefix, i.e. | when invoking a command line like &quot;mvn prefix:goal&quot;. Maven will automatically add the group identifiers | &quot;org.apache.maven.plugins&quot; and &quot;org.codehaus.mojo&quot; if these are not already contained in the list. |--&gt; &lt;pluginGroups&gt; &lt;!-- pluginGroup | Specifies a further group identifier to use for plugin lookup. &lt;pluginGroup&gt;com.your.plugins&lt;/pluginGroup&gt; --&gt; &lt;/pluginGroups&gt; &lt;!-- proxies | This is a list of proxies which can be used on this machine to connect to the network. | Unless otherwise specified (by system property or command-line switch), the first proxy | specification in this list marked as active will be used. |--&gt; &lt;proxies&gt; &lt;!-- proxy | Specification for one proxy, to be used in connecting to the network. | &lt;proxy&gt; &lt;id&gt;optional&lt;/id&gt; &lt;active&gt;true&lt;/active&gt; &lt;protocol&gt;http&lt;/protocol&gt; &lt;username&gt;proxyuser&lt;/username&gt; &lt;password&gt;proxypass&lt;/password&gt; &lt;host&gt;proxy.host.net&lt;/host&gt; &lt;port&gt;80&lt;/port&gt; &lt;nonProxyHosts&gt;local.net|some.host.com&lt;/nonProxyHosts&gt; &lt;/proxy&gt; --&gt; &lt;/proxies&gt; &lt;!-- servers | This is a list of authentication profiles, keyed by the server-id used within the system. | Authentication profiles can be used whenever maven must make a connection to a remote server. |--&gt; &lt;servers&gt; &lt;!-- server | Specifies the authentication information to use when connecting to a particular server, identified by | a unique name within the system (referred to by the &#x27;id&#x27; attribute below). | | NOTE: You should either specify username/password OR privateKey/passphrase, since these pairings are | used together. | &lt;server&gt; &lt;id&gt;deploymentRepo&lt;/id&gt; &lt;username&gt;repouser&lt;/username&gt; &lt;password&gt;repopwd&lt;/password&gt; &lt;/server&gt; --&gt; &lt;!-- Another sample, using keys to authenticate. &lt;server&gt; &lt;id&gt;siteServer&lt;/id&gt; &lt;privateKey&gt;/path/to/private/key&lt;/privateKey&gt; &lt;passphrase&gt;optional; leave empty if not used.&lt;/passphrase&gt; &lt;/server&gt; --&gt; &lt;/servers&gt; &lt;!-- mirrors | This is a list of mirrors to be used in downloading artifacts from remote repositories. | | It works like this: a POM may declare a repository to use in resolving certain artifacts. | However, this repository may have problems with heavy traffic at times, so people have mirrored | it to several places. | | That repository definition will have a unique id, so we can create a mirror reference for that | repository, to be used as an alternate download site. The mirror site will be the preferred | server for that repository. |--&gt; &lt;mirrors&gt; &lt;!-- mirror | Specifies a repository mirror site to use instead of a given repository. The repository that | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used | for inheritance and direct lookup purposes, and must be unique across the set of mirrors. | &lt;mirror&gt; &lt;id&gt;mirrorId&lt;/id&gt; &lt;mirrorOf&gt;repositoryId&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://my.repository.com/repo/path&lt;/url&gt; &lt;/mirror&gt; --&gt; &lt;mirror&gt; &lt;id&gt;maven-default-http-blocker&lt;/id&gt; &lt;mirrorOf&gt;external:http:*&lt;/mirrorOf&gt; &lt;name&gt;Pseudo repository to mirror external repositories initially using HTTP.&lt;/name&gt; &lt;url&gt;http://0.0.0.0/&lt;/url&gt; &lt;blocked&gt;true&lt;/blocked&gt; &lt;/mirror&gt; &lt;!-- 闃块噷浜戜粨搴?--&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt; &lt;/mirror&gt; &lt;!-- 涓ぎ浠撳簱1 --&gt; &lt;mirror&gt; &lt;id&gt;repo1&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://repo1.maven.org/maven2/&lt;/url&gt; &lt;/mirror&gt; &lt;!-- 涓ぎ浠撳簱2 --&gt; &lt;mirror&gt; &lt;id&gt;repo2&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://repo2.maven.org/maven2/&lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt; &lt;!-- profiles | This is a list of profiles which can be activated in a variety of ways, and which can modify | the build process. Profiles provided in the settings.xml are intended to provide local machine- | specific paths and repository locations which allow the build to work in the local environment. | | For example, if you have an integration testing plugin - like cactus - that needs to know where | your Tomcat instance is installed, you can provide a variable here such that the variable is | dereferenced during the build process to configure the cactus plugin. | | As noted above, profiles can be activated in a variety of ways. One way - the activeProfiles | section of this document (settings.xml) - will be discussed later. Another way essentially | relies on the detection of a system property, either matching a particular value for the property, | or merely testing its existence. Profiles can also be activated by JDK version prefix, where a | value of &#x27;1.4&#x27; might activate a profile when the build is executed on a JDK version of &#x27;1.4.2_07&#x27;. | Finally, the list of active profiles can be specified directly from the command line. | | NOTE: For profiles defined in the settings.xml, you are restricted to specifying only artifact | repositories, plugin repositories, and free-form properties to be used as configuration | variables for plugins in the POM. | |--&gt; &lt;profiles&gt; &lt;profile&gt; &lt;id&gt;JDK-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;!-- profile | Specifies a set of introductions to the build process, to be activated using one or more of the | mechanisms described above. For inheritance purposes, and to activate profiles via &lt;activatedProfiles/&gt; | or the command line, profiles have to have an ID that is unique. | | An encouraged best practice for profile identification is to use a consistent naming convention | for profiles, such as &#x27;env-dev&#x27;, &#x27;env-test&#x27;, &#x27;env-production&#x27;, &#x27;user-jdcasey&#x27;, &#x27;user-brett&#x27;, etc. | This will make it more intuitive to understand what the set of introduced profiles is attempting | to accomplish, particularly when you only have a list of profile id&#x27;s for debug. | | This profile example uses the JDK version to trigger activation, and provides a JDK-specific repo. &lt;profile&gt; &lt;id&gt;jdk-1.4&lt;/id&gt; &lt;activation&gt; &lt;jdk&gt;1.4&lt;/jdk&gt; &lt;/activation&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;jdk14&lt;/id&gt; &lt;name&gt;Repository for JDK 1.4 builds&lt;/name&gt; &lt;url&gt;http://www.myhost.com/maven/jdk14&lt;/url&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;snapshotPolicy&gt;always&lt;/snapshotPolicy&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;/profile&gt; --&gt; &lt;!-- | Here is another profile, activated by the system property &#x27;target-env&#x27; with a value of &#x27;dev&#x27;, | which provides a specific path to the Tomcat instance. To use this, your plugin configuration | might hypothetically look like: | | ... | &lt;plugin&gt; | &lt;groupId&gt;org.myco.myplugins&lt;/groupId&gt; | &lt;artifactId&gt;myplugin&lt;/artifactId&gt; | | &lt;configuration&gt; | &lt;tomcatLocation&gt;$&#123;tomcatPath&#125;&lt;/tomcatLocation&gt; | &lt;/configuration&gt; | &lt;/plugin&gt; | ... | | NOTE: If you just wanted to inject this configuration whenever someone set &#x27;target-env&#x27; to | anything, you could just leave off the &lt;value/&gt; inside the activation-property. | &lt;profile&gt; &lt;id&gt;env-dev&lt;/id&gt; &lt;activation&gt; &lt;property&gt; &lt;name&gt;target-env&lt;/name&gt; &lt;value&gt;dev&lt;/value&gt; &lt;/property&gt; &lt;/activation&gt; &lt;properties&gt; &lt;tomcatPath&gt;/path/to/tomcat/instance&lt;/tomcatPath&gt; &lt;/properties&gt; &lt;/profile&gt; --&gt; &lt;/profiles&gt; &lt;!-- activeProfiles | List of profiles that are active for all builds. | &lt;activeProfiles&gt; &lt;activeProfile&gt;alwaysActiveProfile&lt;/activeProfile&gt; &lt;activeProfile&gt;anotherAlwaysActiveProfile&lt;/activeProfile&gt; &lt;/activeProfiles&gt; --&gt;&lt;/settings&gt;"},{"title":"用JAVA实现银行家算法","path":"/2024/10/16/Implementing the Banker's Algorithm in Java/","content":"用Java实现银行家算法实验目的银行家算法是避免死锁的一种重要方法，本实验要求用高级语言编写和调试一个简单的银行家算法程序。加深了解有关资源申请、避免死锁等概念，并体会和了解死锁和避免死锁的具体实施方法。 实验内容1)设计进程对各类资源最大申请表示及初值确定。2)设定系统提供资源初始状况。3)设定每次某个进程对各类资源的申请表示。4)编制程序，依据银行家算法，决定其申请是否得到满足。 代码解释Banker类-T0时刻资源分配进行变量定义：对进程数量M，资源种类数量N，各资源总数All[]，m个进程对n类资源的最大需求量Max[][]，m个进程已经得到n类资源的资源量Allocation[][],m个进程还需要n类资源的资源量Need[][],系统可用资源数系统可用资源数Available[][]。还有一个进程完成标志位Finish[]。 12345678910111213class Banker&#123;\tint ID[], //进程代号 M, //m个进程 N, //n类资源 All[], //系统各资源数量 Max[][], //m个进程对n类资源的最大需求量 Allocation[][],\t//m个进程已经得到n类资源的资源量 Need[][], //m个进程还需要n类资源的资源量 Available[][];\t//系统可用资源数 boolean Finish[];\t//标记进程是否完成\tint a=0;//Available的第一个下标 无参构造函数：在无参函数中进行变量的初始化，需要手动输入的变量为M,N，All[]，Max[][]，Allocation[][]。当输入了初始值后，Need[][]和Available[][]就可以通过need 的计算公式：Need&#x3D;[i][j]&#x3D; Max[i][j]- Allocation[i][j]Available[][]：Available[a][n] &#x3D; All[n] - Allocation[m][n]（遍历） 1234567891011121314151617181920212223242526272829303132public Banker() &#123;\t//无参构造器 @SuppressWarnings(&quot;resource&quot;) Scanner input = new Scanner(System.in); System.out.println(&quot;请输入进程数&quot;); M = input.nextInt();//m个进程 System.out.println(&quot;请输入资源种类数&quot;); N = input.nextInt();//n类资源 //初始化数组 ID = new int[M]; //进程代号 All = new int[N]; //系统各资源数量 Max = new int[M][N]; //m个进程对n类资源的最大需求量 Allocation = new int[M][N];\t//m个进程已经得到n类资源的资源量 Need = new int[M][N]; //m个进程还需要n类资源的资源量 Available = new int[M+1][N]; //系统可用资源数 Finish = new boolean[M];\t//标记进程是否完成 System.out.println(&quot;请输入系统初始可用资源数&quot;); for(int i=0; i&lt;N; i++)//系统初始可用资源数 All[i] = input.nextInt(); System.out.println(&quot;请输入&quot;+M+&quot;个进程对&quot;+N+&quot;类资源的最大需求量&quot;); for(int i=0; i&lt;M; i++)&#123;//m个进程对n类资源的最大需求量 ID[i] = i; for(int j=0; j&lt;N; j++) Max[i][j] = input.nextInt(); &#125; System.out.println(&quot;请输入&quot;+M+&quot;个进程已经得到的&quot;+N+&quot;类资源的资源量&quot;); for(int i=0; i&lt;M; i++)\t//m个进程已经得到n类资源的资源量 for(int j=0; j&lt;N; j++) Allocation[i][j] = input.nextInt(); Need_Resources(); Available_Resources(); Print_Banker();\t&#125; 初始化Need和Available矩阵： 12345678910111213141516private void Need_Resources() &#123;//初始化Need矩阵 // TODO Auto-generated method stub for(int i=0; i&lt;M; i++)//m个进程还需要n类资源的资源量 for(int j=0; j&lt;N; j++) Need[i][j] = Max[i][j] - Allocation[i][j];\t&#125;\tprivate void Available_Resources() &#123;//更新系统当前可用资源数 // TODO Auto-generated method stub for(int n=0; n&lt;N; n++)&#123;//系统目前可用资源数 Available[a][n] = All[n]; for(int m=0; m&lt;M; m++)&#123; Available[a][n] -= Allocation[m][n]; &#125; &#125;\t&#125; 就此，所有矩阵初始化完毕，对T0时刻的资源分配图进行打印，如图所示： 1234567891011121314151617181920212223242526272829303132private void Print_Banker() &#123;//T0时刻的资源分配图 System.out.println(&quot; T0时刻资源分配图：&quot;); System.out.print(&quot;资源\\t资源数量 &quot;); for(int i=0; i&lt;N; i++) System.out.printf(&quot;S%d\\t%d &quot;, i, All[i]); System.out.print(&quot; 进程\\t Max\\tAllocation\\tNeed\\tAvailable\\tFinish &quot;); for(int i=0; i&lt;M; i++)&#123; System.out.print(&quot;P&quot;+ID[i]); System.out.print(&quot;\\t&quot;); for(int j=0; j&lt;Max[ID[i]].length; j++)&#123; System.out.printf(&quot;%d &quot;, Max[ID[i]][j]); &#125; System.out.print(&quot;\\t&quot;); for(int j=0; j&lt;Allocation[ID[i]].length; j++)&#123; System.out.printf(&quot;%d &quot;, Allocation[ID[i]][j]); &#125; System.out.print(&quot;\\t\\t&quot;); for(int j=0; j&lt;Need[ID[i]].length; j++)&#123; System.out.printf(&quot;%d &quot;, Need[ID[i]][j]); &#125; System.out.print(&quot;\\t&quot;); if(i == 0)&#123; for(int j=0; j&lt;N; j++)&#123; System.out.printf(&quot;%d &quot;, Available[i][j]); &#125; &#125; System.out.print(&quot;\\t&quot;); System.out.print(&quot;\\t&quot;); System.out.print(Finish[i]); System.out.println(); &#125;\t&#125; 安全性检查对T0时刻资源分配情况进行安全性分析，为每个进程进行可满足性检查。Need[i][j] &gt; Available[a][j]遍历每个资源，都满足可满足性，则进入试分配，若不满足，将该进程的标志位flag2置为false，跳出for循环。试分配，先将进程的Finish标志位置为true，代表这个进程已经被分配资源执行完毕。更新Available：Available[a][j] &#x3D; Available[a-1][j] + Allocation[i][j];当所有进程都通过试分配(a &#x3D;&#x3D; M)后，打印分配过资源的安全序列Print_Banker_Se() 12345678910111213141516171819202122232425262728293031323334353637public void Security_examine()&#123;//安全性检测 boolean flag1,\t//所有进程 flag2;\t//每个进程 flag1 = true; while(flag1)&#123; flag1 = false; for(int i=0; i&lt;M; i++)&#123; flag2 = true; for(int j=0; flag2 &amp;&amp; j&lt;N; j++)&#123; if(Need[i][j] &gt; Available[a][j] || Finish[i])&#123;//存在一个条件不满足或者该进程已经完成 flag2 = false; &#125; &#125; if(flag2 &amp;&amp; !Finish[i])&#123;//该进程（第i个进程）可执行 flag1 = true; Finish[i] = true; ID[a] = i; a++;//以此判断所有进程是否都执行，安全检查 for(int j=0; flag2 &amp;&amp; j&lt;N; j++)&#123; Available[a][j] = Available[a-1][j] + Allocation[i][j]; &#125; &#125; &#125; &#125; System.out.println(&quot; T0时刻的安全性：&quot;); if(a == M)&#123; Print_Banker_Se(); System.out.println(&quot; 安全序列：&quot;); for(int i=0; i&lt;M; i++)&#123; System.out.print(&quot;-&gt;P&quot;+ID[i]); &#125; System.out.println(&quot; &quot;); &#125; else&#123; System.out.println(&quot;系统不安全&quot;); &#125;\t&#125; Banker类-银行家算法申请资源：某个进程发起请求向量Request(,,*)，系统按银行家算法进行检查。① Request[i] &gt; Need[n][i]② Request[i] &gt; Available[0][i]满足以上两条说明不满足正确性检查和可满足性检查，将标志位flag置为false，报告分配不安全。若通过了正确性和可满足性检测就将这条进程的已分配Allocation加上申请量，并重新对Need和Available矩阵进行新的初始化。并打印此时初状态资源分配表。 安全性检查：通过主程序调用键盘输入控制进入安全性检查部分，思想和源码与T0时刻的安全性检查雷同，再次不在赘述。安全性检查 123456789101112131415161718192021222324252627282930313233343536public void Reallocation()&#123;//申请资源 @SuppressWarnings(&quot;resource&quot;) Scanner input = new Scanner(System.in); int[] Request = new int[N]; boolean flag = true; System.out.print(&quot; 输入进程代号：&quot;); int n = input.nextInt(); System.out.print(&quot;输入请求资源数：&quot;); for(int j=0; j&lt;N; j++) Request[j] = input.nextInt(); for(int i=0; i&lt;N; i++)&#123;//合理性检查,可用性检查 if(Request[i] &gt; Need[n][i] || Request[i] &gt; Available[0][i]) flag = false; &#125; if(flag)&#123; for(int i=0; i&lt;N; i++)&#123; Allocation[n][i] += Request[i]; &#125; Init(); Print_Banker(); &#125; else&#123; System.out.println(&quot;分配不安全 &quot;); &#125; &#125;\tprivate void Init() &#123; // TODO Auto-generated method stub a = 0; Need_Resources();//再次初始化 Available_Resources(); for(int i=0; i&lt;M; i++)&#123;//ID初始化 ID[i] = i; Finish[i] = false; &#125;\t&#125; 主函数使用无参构造器new了一个banker对象，打印菜单，并控制调用安全性检测、银行家算法（请求再分配资源）以及退出。 1234567891011121314151617181920212223public class TestBankerClass &#123;\tpublic static void main(String[] args) &#123; // TODO Auto-generated method stub Banker banker = new Banker(); int n; boolean flag=true; Scanner input = new Scanner(System.in); System.out.println(&quot; *************菜单****************&quot;); System.out.println(&quot;进行安全性检查：1 请求再分配资源：2 退出：其他&quot;); System.out.println(&quot;*********************************&quot;); while(flag)&#123; System.out.print(&quot;输入操作代号：&quot;); n = input.nextInt(); switch(n)&#123; case 1:\tbanker.Security_examine();break; case 2:\tbanker.Reallocation();break; default:flag = false; System.out.print(&quot; 操作结束！！！！&quot;); &#125; &#125; input.close();//关闭流\t&#125;&#125; 输入示例例1： 1234567891011121314151617181920212223242526初始化：5310 5 77 5 33 2 29 0 22 2 24 3 30 1 02 0 03 0 22 1 10 0 2再分配：11 0 243 3 000 2 0 例2： 123456789101112131415161718初始化：3310 8 78 7 55 2 56 6 23 2 02 0 21 3 2再分配：01 0 010 1 1 运行结果例1： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107T0时刻资源分配图：资源\t资源数量S0\t10S1\t5S2\t7进程 Max\tAllocation\tNeed\tAvailable\tFinishP0\t7 5 3 0 1 0 7 4 3 3 3 2 falseP1\t3 2 2 2 0 0 1 2 2 falseP2\t9 0 2 3 0 2 6 0 0 falseP3\t2 2 2 2 1 1 0 1 1 falseP4\t4 3 3 0 0 2 4 3 1 false*************菜单****************进行安全性检查：1请求再分配资源：2退出：其他*********************************输入操作代号：1T0时刻的安全性：进程 Work\tNeed\tAllocation\tWork+Allocation\tFinishP1\t3 3 2 1 2 2 2 0 0 5 3 2 trueP3\t5 3 2 0 1 1 2 1 1 7 4 3 trueP4\t7 4 3 4 3 1 0 0 2 7 4 5 trueP0\t7 4 5 7 4 3 0 1 0 7 5 5 trueP2\t7 5 5 6 0 0 3 0 2 10 5 7 true安全序列：-&gt;P1-&gt;P3-&gt;P4-&gt;P0-&gt;P2输入操作代号：2输入进程代号：1输入请求资源数：1 0 2T0时刻资源分配图：资源\t资源数量S0\t10S1\t5S2\t7进程 Max\tAllocation\tNeed\tAvailable\tFinishP0\t7 5 3 0 1 0 7 4 3 2 3 0 falseP1\t3 2 2 3 0 2 0 2 0 falseP2\t9 0 2 3 0 2 6 0 0 falseP3\t2 2 2 2 1 1 0 1 1 falseP4\t4 3 3 0 0 2 4 3 1 false输入操作代号：1T0时刻的安全性：进程 Work\tNeed\tAllocation\tWork+Allocation\tFinishP1\t2 3 0 0 2 0 3 0 2 5 3 2 trueP3\t5 3 2 0 1 1 2 1 1 7 4 3 trueP4\t7 4 3 4 3 1 0 0 2 7 4 5 trueP0\t7 4 5 7 4 3 0 1 0 7 5 5 trueP2\t7 5 5 6 0 0 3 0 2 10 5 7 true安全序列：-&gt;P1-&gt;P3-&gt;P4-&gt;P0-&gt;P2输入操作代号：2输入进程代号：4输入请求资源数：3 3 0分配不安全输入操作代号：1T0时刻的安全性：进程 Work\tNeed\tAllocation\tWork+Allocation\tFinishP1\t2 3 0 0 2 0 3 0 2 5 3 2 trueP3\t5 3 2 0 1 1 2 1 1 7 4 3 trueP4\t7 4 3 4 3 1 0 0 2 7 4 5 trueP0\t7 4 5 7 4 3 0 1 0 7 5 5 trueP2\t7 5 5 6 0 0 3 0 2 10 5 7 true安全序列：-&gt;P1-&gt;P3-&gt;P4-&gt;P0-&gt;P2输入操作代号：2输入进程代号：0输入请求资源数：0 2 0T0时刻资源分配图：资源\t资源数量S0\t10S1\t5S2\t7进程 Max\tAllocation\tNeed\tAvailable\tFinishP0\t7 5 3 0 3 0 7 2 3 2 1 0 falseP1\t3 2 2 3 0 2 0 2 0 falseP2\t9 0 2 3 0 2 6 0 0 falseP3\t2 2 2 2 1 1 0 1 1 falseP4\t4 3 3 0 0 2 4 3 1 false输入操作代号：1T0时刻的安全性：系统不安全输入操作代号：4操作结束！！！！ 完整代码TestBankerClass类： 123456789101112131415161718192021222324252627package bankerTest;import java.util.Scanner;public class TestBankerClass &#123;\tpublic static void main(String[] args) &#123; // TODO Auto-generated method stub Banker banker = new Banker(); int n; boolean flag=true; Scanner input = new Scanner(System.in); System.out.println(&quot; *************菜单****************&quot;); System.out.println(&quot;进行安全性检查：1 请求再分配资源：2 退出：其他&quot;); System.out.println(&quot;*********************************&quot;); while(flag)&#123; System.out.print(&quot;输入操作代号：&quot;); n = input.nextInt(); switch(n)&#123; case 1:\tbanker.Security_examine();break; case 2:\tbanker.Reallocation();break; default:flag = false; System.out.print(&quot; 操作结束！！！！&quot;); &#125; &#125; input.close();//关闭流\t&#125;&#125; Banker类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202package bankerTest;import java.util.Scanner;class Banker&#123;\t//定义数组\tint ID[], //进程代号 M, //m个进程 N, //n类资源 All[], //系统各资源数量 Max[][], //m个进程对n类资源的最大需求量 Allocation[][],\t//m个进程已经得到n类资源的资源量 Need[][], //m个进程还需要n类资源的资源量 Available[][];\t//系统可用资源数\tboolean Finish[];\t//标记进程是否完成\tint a=0; //Available的第一个下标\tpublic Banker() &#123;\t//无参构造器 @SuppressWarnings(&quot;resource&quot;)//忽视输入流未关闭的报错 Scanner input = new Scanner(System.in); System.out.println(&quot;请输入进程数&quot;); M = input.nextInt();//m个进程 System.out.println(&quot;请输入资源种类数&quot;); N = input.nextInt();//n类资源 //初始化数组 ID = new int[M]; //进程代号 All = new int[N]; //系统各资源数量 Max = new int[M][N]; //m个进程对n类资源的最大需求量 Allocation = new int[M][N];\t//m个进程已经得到n类资源的资源量 Need = new int[M][N]; //m个进程还需要n类资源的资源量 Available = new int[M+1][N]; //系统可用资源数 Finish = new boolean[M];\t//标记进程是否完成 System.out.println(&quot;请输入系统初始可用资源数&quot;); for(int i=0; i&lt;N; i++)//系统初始可用资源数 All[i] = input.nextInt(); System.out.println(&quot;请输入&quot;+M+&quot;个进程对&quot;+N+&quot;类资源的最大需求量&quot;); for(int i=0; i&lt;M; i++)&#123;//m个进程对n类资源的最大需求量 ID[i] = i; for(int j=0; j&lt;N; j++) Max[i][j] = input.nextInt(); &#125; System.out.println(&quot;请输入&quot;+M+&quot;个进程已经得到的&quot;+N+&quot;类资源的资源量&quot;); for(int i=0; i&lt;M; i++)\t//m个进程已经得到n类资源的资源量 for(int j=0; j&lt;N; j++) Allocation[i][j] = input.nextInt(); Need_Resources(); Available_Resources(); Print_Banker();\t&#125;\tprivate void Need_Resources() &#123;//初始化Need矩阵 // TODO Auto-generated method stub for(int i=0; i&lt;M; i++)//m个进程还需要n类资源的资源量 for(int j=0; j&lt;N; j++) Need[i][j] = Max[i][j] - Allocation[i][j];\t&#125;\tprivate void Available_Resources() &#123;//更新系统当前可用资源数 // TODO Auto-generated method stub for(int n=0; n&lt;N; n++)&#123;//系统目前可用资源数 Available[a][n] = All[n]; for(int m=0; m&lt;M; m++)&#123; Available[a][n] -= Allocation[m][n]; &#125; &#125;\t&#125;\tprivate void Print_Banker() &#123;//T0时刻的资源分配图 System.out.println(&quot; T0时刻资源分配图：&quot;); System.out.print(&quot;资源\\t资源数量 &quot;); for(int i=0; i&lt;N; i++) System.out.printf(&quot;S%d\\t%d &quot;, i, All[i]); System.out.print(&quot; 进程\\t Max\\tAllocation\\tNeed\\tAvailable\\tFinish &quot;); for(int i=0; i&lt;M; i++)&#123; System.out.print(&quot;P&quot;+ID[i]); System.out.print(&quot;\\t&quot;); for(int j=0; j&lt;Max[ID[i]].length; j++)&#123; System.out.printf(&quot;%d &quot;, Max[ID[i]][j]); &#125; System.out.print(&quot;\\t&quot;); for(int j=0; j&lt;Allocation[ID[i]].length; j++)&#123; System.out.printf(&quot;%d &quot;, Allocation[ID[i]][j]); &#125; System.out.print(&quot;\\t\\t&quot;); for(int j=0; j&lt;Need[ID[i]].length; j++)&#123; System.out.printf(&quot;%d &quot;, Need[ID[i]][j]); &#125; System.out.print(&quot;\\t&quot;); if(i == 0)&#123; for(int j=0; j&lt;N; j++)&#123; System.out.printf(&quot;%d &quot;, Available[i][j]); &#125; &#125; System.out.print(&quot;\\t&quot;); System.out.print(&quot;\\t&quot;); System.out.print(Finish[i]); System.out.println(); &#125;\t&#125;\tpublic void Security_examine()&#123;//安全性检测 boolean flag1,\t//所有进程 flag2;\t//每个进程 flag1 = true; while(flag1)&#123; flag1 = false; for(int i=0; i&lt;M; i++)&#123; flag2 = true; for(int j=0; flag2 &amp;&amp; j&lt;N; j++)&#123; if(Need[i][j] &gt; Available[a][j] || Finish[i])&#123;//存在一个条件不满足或者该进程已经完成 flag2 = false; &#125; &#125; if(flag2 &amp;&amp; !Finish[i])&#123;//该进程（第i个进程）可执行 flag1 = true; Finish[i] = true; ID[a] = i; a++;//以此判断所有进程是否都执行，安全检查 for(int j=0; flag2 &amp;&amp; j&lt;N; j++)&#123; Available[a][j] = Available[a-1][j] + Allocation[i][j]; &#125; &#125; &#125; &#125; System.out.println(&quot; T0时刻的安全性：&quot;); if(a == M)&#123; Print_Banker_Se(); System.out.println(&quot; 安全序列：&quot;); for(int i=0; i&lt;M; i++)&#123; System.out.print(&quot;-&gt;P&quot;+ID[i]); &#125; System.out.println(&quot; &quot;); &#125; else&#123; System.out.println(&quot;系统不安全&quot;); &#125;\t&#125; public void Reallocation()&#123;//申请资源 @SuppressWarnings(&quot;resource&quot;) Scanner input = new Scanner(System.in); int[] Request = new int[N]; boolean flag = true; System.out.print(&quot; 输入进程代号：&quot;); int n = input.nextInt(); System.out.print(&quot;输入请求资源数：&quot;); for(int j=0; j&lt;N; j++) Request[j] = input.nextInt(); for(int i=0; i&lt;N; i++)&#123;//合理性检查,可用性检查 if(Request[i] &gt; Need[n][i] || Request[i] &gt; Available[0][i]) flag = false; &#125; if(flag)&#123; for(int i=0; i&lt;N; i++)&#123; Allocation[n][i] += Request[i]; &#125; Init(); Print_Banker(); &#125; else&#123; System.out.println(&quot;分配不安全 &quot;); &#125; &#125;\tprivate void Init() &#123; // TODO Auto-generated method stub a = 0; Need_Resources();//再次初始化 Available_Resources(); for(int i=0; i&lt;M; i++)&#123;//ID初始化 ID[i] = i; Finish[i] = false; &#125;\t&#125;\tprivate void Print_Banker_Se() &#123; System.out.print(&quot; 进程\\t Work\\tNeed\\tAllocation\\tWork+Allocation\\tFinish &quot;); for(int i=0; i&lt;M; i++)&#123; System.out.print(&quot;P&quot;+ID[i]); System.out.print(&quot;\\t&quot;); for(int j=0; j&lt;Available[i].length; j++)&#123; System.out.printf(&quot;%d &quot;, Available[i][j]); &#125; System.out.print(&quot;\\t&quot;); for(int j=0; j&lt;Need[ID[i]].length; j++)&#123; System.out.printf(&quot;%d &quot;, Need[ID[i]][j]); &#125; System.out.print(&quot;\\t&quot;); for(int j=0; j&lt;Allocation[ID[i]].length; j++)&#123; System.out.printf(&quot;%d &quot;, Allocation[ID[i]][j]); &#125; System.out.print(&quot;\\t\\t&quot;); for(int j=0; j&lt;Available[i+1].length; j++)&#123; System.out.printf(&quot;%d &quot;, Available[i+1][j]); &#125; System.out.print(&quot;\\t&quot;); System.out.print(&quot;\\t&quot;); System.out.print(Finish[i]); System.out.println(); &#125;\t&#125;\t&#125;"}]