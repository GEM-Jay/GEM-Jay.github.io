[{"title":"抽象类/内部类和接口","path":"/posts/3557321101/","content":"今日内容 抽象类 接口 内部类 教学目标 能够写出抽象类的格式 能够写出抽象方法的格式 能说出抽象类的应用场景 写出定义接口的格式 写出实现接口的格式 说出接口中成员的特点 能说出接口的应用场景 能说出接口中为什么会出现带有方法体的方法 能完成适配器设计模式 第一章 抽象类1.1 概述1.1.1 抽象类引入​\t父类中的方法，被它的子类们重写，子类各自的实现都不尽相同。那么父类的方法声明和方法主体，只有声明还有意义，而方法主体则没有存在的意义了(因为子类对象会调用自己重写的方法)。换句话说，父类可能知道子类应该有哪个功能，但是功能具体怎么实现父类是不清楚的（由子类自己决定），父类只需要提供一个没有方法体的定义即可，具体实现交给子类自己去实现。我们把没有方法体的方法称为抽象方法。Java语法规定，包含抽象方法的类就是抽象类。 抽象方法 ： 没有方法体的方法。 抽象类：包含抽象方法的类。 1.2 abstract使用格式abstract是抽象的意思，用于修饰方法方法和类，修饰的方法是抽象方法，修饰的类是抽象类。 1.2.1 抽象方法使用abstract 关键字修饰方法，该方法就成了抽象方法，抽象方法只包含一个方法名，而没有方法体。 定义格式： 1修饰符 abstract 返回值类型 方法名 (参数列表)； 代码举例： 1public abstract void run()； 1.2.2 抽象类如果一个类包含抽象方法，那么该类必须是抽象类。注意：抽象类不一定有抽象方法，但是有抽象方法的类必须定义成抽象类。 定义格式： 123abstract class 类名字 &#123; &#125; 代码举例： 123public abstract class Animal &#123; public abstract void run()；&#125; 1.2.3 抽象类的使用要求：继承抽象类的子类必须重写父类所有的抽象方法。否则，该子类也必须声明为抽象类。 代码举例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 父类,抽象类abstract class Employee &#123;\tprivate String id;\tprivate String name;\tprivate double salary; public Employee() &#123;\t&#125; public Employee(String id, String name, double salary) &#123; this.id = id; this.name = name; this.salary = salary;\t&#125; // 抽象方法\t// 抽象方法必须要放在抽象类中\tabstract public void work();&#125;// 定义一个子类继承抽象类class Manager extends Employee &#123;\tpublic Manager() &#123;\t&#125;\tpublic Manager(String id, String name, double salary) &#123; super(id, name, salary);\t&#125;\t// 2.重写父类的抽象方法\t@Override\tpublic void work() &#123; System.out.println(&quot;管理其他人&quot;);\t&#125;&#125;// 定义一个子类继承抽象类class Cook extends Employee &#123;\tpublic Cook() &#123;\t&#125;\tpublic Cook(String id, String name, double salary) &#123; super(id, name, salary);\t&#125;\t@Override\tpublic void work() &#123; System.out.println(&quot;厨师炒菜多加点盐...&quot;);\t&#125;&#125;// 测试类public class Demo10 &#123;\tpublic static void main(String[] args) &#123; // 创建抽象类,抽象类不能创建对象 // 假设抽象类让我们创建对象,里面的抽象方法没有方法体,无法执行.所以不让我们创建对象// Employee e = new Employee();// e.work(); // 3.创建子类 Manager m = new Manager(); m.work(); Cook c = new Cook(&quot;ap002&quot;, &quot;库克&quot;, 1); c.work();\t&#125;&#125; 此时的方法重写，是子类对父类抽象方法的完成实现，我们将这种方法重写的操作，也叫做实现方法。 1.3 抽象类的特征抽象类的特征总结起来可以说是 有得有失 有得：抽象类得到了拥有抽象方法的能力。 有失：抽象类失去了创建对象的能力。 其他成员（构造方法，实例方法，静态方法等）抽象类都是具备的。 1.4 抽象类的细节不需要背，只要当idea报错之后，知道如何修改即可。 关于抽象类的使用，以下为语法上要注意的细节，虽然条目较多，但若理解了抽象的本质，无需死记硬背。 抽象类不能创建对象，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。 理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。 抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。 理解：子类的构造方法中，有默认的super()，需要访问父类构造方法。 抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。 理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。 抽象类的子类，必须重写抽象父类中所有的抽象方法，否则子类也必须定义成抽象类，编译无法通过而报错。 理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。 抽象类存在的意义是为了被子类继承。 理解：抽象类中已经实现的是模板中确定的成员，抽象类不确定如何实现的定义成抽象方法，交给具体的子类去实现。 1.5 抽象类存在的意义​\t抽象类存在的意义是为了被子类继承，否则抽象类将毫无意义。抽象类可以强制让子类，一定要按照规定的格式进行重写。 第二章 接口2.1 概述我们已经学完了抽象类，抽象类中可以用抽象方法，也可以有普通方法，构造方法，成员变量等。那么什么是接口呢？接口是更加彻底的抽象，JDK7之前，包括JDK7，接口中全部是抽象方法。接口同样是不能创建对象的。 2.2 定义格式1234567//接口的定义格式：interface 接口名称&#123; // 抽象方法&#125;// 接口的声明：interface// 接口名称：首字母大写，满足“驼峰模式” 2.3 接口成分的特点 在JDK7，包括JDK7之前，接口中的只有包含：抽象方法和常量 2.3.1.抽象方法​ 注意：接口中的抽象方法默认会自动加上public abstract修饰程序员无需自己手写！！​ 按照规范：以后接口中的抽象方法建议不要写上public abstract。因为没有必要啊，默认会加上。 2.3.2 常量 在接口中定义的成员变量默认会加上： public static final修饰。也就是说在接口中定义的成员变量实际上是一个常量。这里是使用public static final修饰后，变量值就不可被修改，并且是静态化的变量可以直接用接口名访问，所以也叫常量。常量必须要给初始值。常量命名规范建议字母全部大写，多个单词用下划线连接。 2.3.3 案例演示123456789101112131415161718public interface InterF &#123; // 抽象方法！ // public abstract void run(); void run(); // public abstract String getName(); String getName(); // public abstract int add(int a , int b); int add(int a , int b); // 它的最终写法是： // public static final int AGE = 12 ; int AGE = 12; //常量 String SCHOOL_NAME = &quot;黑马程序员&quot;;&#125; 2.4 基本的实现2.4.1 实现接口的概述类与接口的关系为实现关系，即类实现接口，该类可以称为接口的实现类，也可以称为接口的子类。实现的动作类似继承，格式相仿，只是关键字不同，实现使用 implements关键字。 2.4.2 实现接口的格式123456/**接口的实现： 在Java中接口是被实现的，实现接口的类称为实现类。 实现类的格式:*/class 类名 implements 接口1,接口2,接口3...&#123;&#125; 从上面格式可以看出，接口是可以被多实现的。大家可以想一想为什么呢？ 2.4.3 类实现接口的要求和意义 必须重写实现的全部接口中所有抽象方法。 如果一个类实现了接口，但是没有重写完全部接口的全部抽象方法，这个类也必须定义成抽象类。 意义：接口体现的是一种规范，接口对实现类是一种强制性的约束，要么全部完成接口申明的功能，要么自己也定义成抽象类。这正是一种强制性的规范。 2.4.4 类与接口基本实现案例假如我们定义一个运动员的接口（规范），代码如下： 12345678/** 接口：接口体现的是规范。 * */public interface SportMan &#123; void run(); // 抽象方法，跑步。 void law(); // 抽象方法，遵守法律。 String compittion(String project); // 抽象方法，比赛。&#125; 接下来定义一个乒乓球运动员类，实现接口，实现接口的实现类代码如下： 1234567891011121314151617181920212223242526package com.itheima._03接口的实现;/** * 接口的实现： * 在Java中接口是被实现的，实现接口的类称为实现类。 * 实现类的格式: * class 类名 implements 接口1,接口2,接口3...&#123; * * * &#125; * */public class PingPongMan implements SportMan &#123; @Override public void run() &#123; System.out.println(&quot;乒乓球运动员稍微跑一下！！&quot;); &#125; @Override public void law() &#123; System.out.println(&quot;乒乓球运动员守法！&quot;); &#125; @Override public String compittion(String project) &#123; return &quot;参加&quot;+project+&quot;得金牌！&quot;; &#125;&#125; 测试代码： 12345678910public class TestMain &#123; public static void main(String[] args) &#123; // 创建实现类对象。 PingPongMan zjk = new PingPongMan(); zjk.run(); zjk.law(); System.out.println(zjk.compittion(&quot;全球乒乓球比赛&quot;)); &#125;&#125; 2.4.5 类与接口的多实现案例类与接口之间的关系是多实现的，一个类可以同时实现多个接口。 首先我们先定义两个接口，代码如下： 12345678910/** 法律规范：接口*/public interface Law &#123; void rule();&#125;/** 这一个运动员的规范：接口*/public interface SportMan &#123; void run();&#125; 然后定义一个实现类： 12345678910111213141516/** * Java中接口是可以被多实现的： * 一个类可以实现多个接口: Law, SportMan * * */public class JumpMan implements Law ,SportMan &#123; @Override public void rule() &#123; System.out.println(&quot;尊长守法&quot;); &#125; @Override public void run() &#123; System.out.println(&quot;训练跑步！&quot;); &#125;&#125; 从上面可以看出类与接口之间是可以多实现的，我们可以理解成实现多个规范，这是合理的。 2.5 接口与接口的多继承Java中，接口与接口之间是可以多继承的：也就是一个接口可以同时继承多个接口。大家一定要注意： 类与接口是实现关系 接口与接口是继承关系 接口继承接口就是把其他接口的抽象方法与本接口进行了合并。 案例演示： 12345678910111213141516171819public interface Abc &#123; void go(); void test();&#125;/** 法律规范：接口*/public interface Law &#123; void rule(); void test();&#125; * * 总结： * 接口与类之间是多实现的。 * 接口与接口之间是多继承的。 * */public interface SportMan extends Law , Abc &#123; void run();&#125; 2.6扩展：接口的细节不需要背，只要当idea报错之后，知道如何修改即可。 关于接口的使用，以下为语法上要注意的细节，虽然条目较多，但若理解了抽象的本质，无需死记硬背。 当两个接口中存在相同抽象方法的时候，该怎么办？ 只要重写一次即可。此时重写的方法，既表示重写1接口的，也表示重写2接口的。 实现类能不能继承A类的时候，同时实现其他接口呢？ 继承的父类，就好比是亲爸爸一样实现的接口，就好比是干爹一样可以继承一个类的同时，再实现多个接口，只不过，要把接口里面所有的抽象方法，全部实现。 实现类能不能继承一个抽象类的时候，同时实现其他接口呢？ 实现类可以继承一个抽象类的同时，再实现其他多个接口，只不过要把里面所有的抽象方法全部重写。 实现类Zi，实现了一个接口，还继承了一个Fu类。假设在接口中有一个方法，父类中也有一个相同的方法。子类如何操作呢？ 处理办法一：如果父类中的方法体，能满足当前业务的需求，在子类中可以不用重写。处理办法二：如果父类中的方法体，不能满足当前业务的需求，需要在子类中重写。 如果一个接口中，有10个抽象方法，但是我在实现类中，只需要用其中一个，该怎么办? 可以在接口跟实现类中间，新建一个中间类（适配器类）让这个适配器类去实现接口，对接口里面的所有的方法做空重写。让子类继承这个适配器类，想要用到哪个方法，就重写哪个方法。因为中间类没有什么实际的意义，所以一般会把中间类定义为抽象的，不让外界创建对象 第三章 内部类3.1 概述3.1.1 什么是内部类将一个类A定义在另一个类B里面，里面的那个类A就称为内部类，B则称为外部类。可以把内部类理解成寄生，外部类理解成宿主。 3.1.2 什么时候使用内部类一个事物内部还有一个独立的事物，内部的事物脱离外部的事物无法独立使用 人里面有一颗心脏。 汽车内部有一个发动机。 为了实现更好的封装性。 3.2 内部类的分类按定义的位置来分 成员内部内，类定义在了成员位置 (类中方法外称为成员位置，无static修饰的内部类) 静态内部类，类定义在了成员位置 (类中方法外称为成员位置，有static修饰的内部类) 局部内部类，类定义在方法内 匿名内部类，没有名字的内部类，可以在方法中，也可以在类中方法外。 3.3 成员内部类成员内部类特点： 无static修饰的内部类，属于外部类对象的。 宿主：外部类对象。 内部类的使用格式： 1外部类.内部类。 // 访问内部类的类型都是用 外部类.内部类 获取成员内部类对象的两种方式： 方式一：外部直接创建成员内部类的对象 1外部类.内部类 变量 = new 外部类（）.new 内部类（）; 方式二：在外部类中定义一个方法提供内部类的对象 案例演示 123456789101112131415161718192021222324252627282930313233343536373839404142方式一：public class Test &#123; public static void main(String[] args) &#123; // 宿主：外部类对象。 // Outer out = new Outer(); // 创建内部类对象。 Outer.Inner oi = new Outer().new Inner(); oi.method(); &#125;&#125;class Outer &#123; // 成员内部类，属于外部类对象的。 // 拓展：成员内部类不能定义静态成员。 public class Inner&#123; // 这里面的东西与类是完全一样的。 public void method()&#123; System.out.println(&quot;内部类中的方法被调用了&quot;); &#125; &#125;&#125;方式二：public class Outer &#123; String name; private class Inner&#123; static int a = 10; &#125; public Inner getInstance()&#123; return new Inner(); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; Outer o = new Outer(); System.out.println(o.getInstance()); &#125;&#125; 3.4 成员内部类的细节编写成员内部类的注意点： 成员内部类可以被一些修饰符所修饰，比如： private，默认，protected，public，static等 在成员内部类里面，JDK16之前不能定义静态变量，JDK16开始才可以定义静态变量。 创建内部类对象时，对象中有一个隐含的Outer.this记录外部类对象的地址值。（请参见3.6节的内存图） 详解： ​\t内部类被private修饰，外界无法直接获取内部类的对象，只能通过3.3节中的方式二获取内部类的对象 ​\t被其他权限修饰符修饰的内部类一般用3.3节中的方式一直接获取内部类的对象 ​\t内部类被static修饰是成员内部类中的特殊情况，叫做静态内部类下面单独学习。 ​\t内部类如果想要访问外部类的成员变量，外部类的变量必须用final修饰，JDK8以前必须手动写final，JDK8之后不需要手动写，JDK默认加上。 3.5 成员内部类面试题请在?地方向上相应代码,以达到输出的内容 注意：内部类访问外部类对象的格式是：外部类名.this 12345678910111213141516171819202122public class Test &#123; public static void main(String[] args) &#123; Outer.inner oi = new Outer().new inner(); oi.method(); &#125;&#125;class Outer &#123;\t// 外部类 private int a = 30; // 在成员位置定义一个类 class inner &#123; private int a = 20; public void method() &#123; int a = 10; System.out.println(???);\t// 10 答案：a System.out.println(???);\t// 20\t答案：this.a System.out.println(???);\t// 30\t答案：Outer.this.a &#125; &#125;&#125; 3.6 成员内部类内存图 3.7 静态内部类静态内部类特点： 静态内部类是一种特殊的成员内部类。 有static修饰，属于外部类本身的。 总结：静态内部类与其他类的用法完全一样。只是访问的时候需要加上外部类.内部类。 拓展1:静态内部类可以直接访问外部类的静态成员。 拓展2:静态内部类不可以直接访问外部类的非静态成员，如果要访问需要创建外部类的对象。 拓展3:静态内部类中没有银行的Outer.this。 内部类的使用格式： 1外部类.内部类。 静态内部类对象的创建格式： 1外部类.内部类 变量 = new 外部类.内部类构造器; 调用方法的格式： 调用非静态方法的格式：先创建对象，用对象调用 调用静态方法的格式：外部类名.内部类名.方法名(); 案例演示： 1234567891011121314151617181920212223242526// 外部类：Outer01class Outer01&#123; private static String sc_name = &quot;黑马程序&quot;; // 内部类: Inner01 public static class Inner01&#123; // 这里面的东西与类是完全一样的。 private String name; public Inner01(String name) &#123; this.name = name; &#125; public void showName()&#123; System.out.println(this.name); // 拓展:静态内部类可以直接访问外部类的静态成员。 System.out.println(sc_name); &#125; &#125;&#125;public class InnerClassDemo01 &#123; public static void main(String[] args) &#123; // 创建静态内部类对象。 // 外部类.内部类 变量 = new 外部类.内部类构造器; Outer01.Inner01 in = new Outer01.Inner01(&quot;张三&quot;); in.showName(); &#125;&#125; 3.8 局部内部类 局部内部类 ：定义在方法中的类。 定义格式: 1234567891011class 外部类名 &#123;\t数据类型 变量名; 修饰符 返回值类型 方法名(参数列表) &#123; // … class 内部类 &#123; // 成员变量 // 成员方法 &#125;\t&#125;&#125; 3.9 匿名内部类【重点】3.9.1 概述匿名内部类 ：是内部类的简化写法。他是一个隐含了名字的内部类。开发中，最常用到的内部类就是匿名内部类了。 3.9.2 格式123new 类名或者接口名() &#123; 重写方法;&#125;; 包含了： 继承或者实现关系 方法重写 创建对象 所以从语法上来讲，这个整体其实是匿名内部类对象 3.9.2 什么时候用到匿名内部类实际上，如果我们希望定义一个只要使用一次的类，就可考虑使用匿名内部类。匿名内部类的本质作用 是为了简化代码。 之前我们使用接口时，似乎得做如下几步操作： 定义子类 重写接口中的方法 创建子类对象 调用重写后的方法 123456789101112131415161718192021interface Swim &#123; public abstract void swimming();&#125;// 1. 定义接口的实现类class Student implements Swim &#123; // 2. 重写抽象方法 @Override public void swimming() &#123; System.out.println(&quot;狗刨式...&quot;); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; // 3. 创建实现类对象 Student s = new Student(); // 4. 调用方法 s.swimming(); &#125;&#125; 我们的目的，最终只是为了调用方法，那么能不能简化一下，把以上四步合成一步呢？匿名内部类就是做这样的快捷方式。 3.9.3 匿名内部类前提和格式匿名内部类必须继承一个父类或者实现一个父接口。 匿名内部类格式 1234567new 父类名或者接口名()&#123; // 方法重写 @Override public void method() &#123; // 执行语句 &#125;&#125;; 3.9.4 使用方式以接口为例，匿名内部类的使用，代码如下： 1234567891011121314151617181920212223242526interface Swim &#123; public abstract void swimming();&#125;public class Demo07 &#123; public static void main(String[] args) &#123; // 使用匿名内部类 new Swim() &#123; @Override public void swimming() &#123; System.out.println(&quot;自由泳...&quot;); &#125; &#125;.swimming(); // 接口 变量 = new 实现类(); // 多态,走子类的重写方法 Swim s2 = new Swim() &#123; @Override public void swimming() &#123; System.out.println(&quot;蛙泳...&quot;); &#125; &#125;; s2.swimming(); s2.swimming(); &#125;&#125; 3.9.5 匿名内部类的特点 定义一个没有名字的内部类 这个类实现了父类，或者父类接口 匿名内部类会创建这个没有名字的类的对象 3.9.6 匿名内部类的使用场景通常在方法的形式参数是接口或者抽象类时，也可以将匿名内部类作为参数传递。代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940interface Swim &#123; public abstract void swimming();&#125;public class Demo07 &#123; public static void main(String[] args) &#123; // 普通方式传入对象 // 创建实现类对象 Student s = new Student(); goSwimming(s); // 匿名内部类使用场景:作为方法参数传递 Swim s3 = new Swim() &#123; @Override public void swimming() &#123; System.out.println(&quot;蝶泳...&quot;); &#125; &#125;; // 传入匿名内部类 goSwimming(s3); // 完美方案: 一步到位 goSwimming(new Swim() &#123; public void swimming() &#123; System.out.println(&quot;大学生, 蛙泳...&quot;); &#125; &#125;); goSwimming(new Swim() &#123; public void swimming() &#123; System.out.println(&quot;小学生, 自由泳...&quot;); &#125; &#125;); &#125; // 定义一个方法,模拟请一些人去游泳 public static void goSwimming(Swim s) &#123; s.swimming(); &#125;&#125;"},{"title":"多态/包/final/权限修饰符和代码块","path":"/posts/3891389522/","content":"day14今日内容 多态 包 final 权限修饰符 代码块 教学目标 能够说出使用多态的前提条件 理解多态的向上转型 理解多态的向下转型 能够知道多态的使用场景 包的作用 public和private权限修饰符的作用 描述final修饰的类的特点 描述final修饰的方法的特点 描述final修饰的变量的特点 第一章 多态1.1 多态的形式多态是继封装、继承之后，面向对象的第三大特性。 多态是出现在继承或者实现关系中的。 多态体现的格式： 12父类类型 变量名 = new 子类/实现类构造器;变量名.方法名(); 多态的前提：有继承关系，子类对象是可以赋值给父类类型的变量。例如Animal是一个动物类型，而Cat是一个猫类型。Cat继承了Animal，Cat对象也是Animal类型，自然可以赋值给父类类型的变量。 1.2 多态的使用场景如果没有多态，在下图中register方法只能传递学生对象，其他的Teacher和administrator对象是无法传递给register方法方法的，在这种情况下，只能定义三个不同的register方法分别接收学生，老师和管理员。 有了多态之后，方法的形参就可以定义为共同的父类Person。 要注意的是： 当一个方法的形参是一个类，我们可以传递这个类所有的子类对象。 当一个方法的形参是一个接口，我们可以传递这个接口所有的实现类对象（后面会学）。 而且多态还可以根据传递的不同对象来调用不同类中的方法。 代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475父类：public class Person &#123; private String name; private int age; 空参构造 带全部参数的构造 get和set方法 public void show()&#123; System.out.println(name + &quot;, &quot; + age); &#125;&#125;子类1：public class Administrator extends Person &#123; @Override public void show() &#123; System.out.println(&quot;管理员的信息为：&quot; + getName() + &quot;, &quot; + getAge()); &#125;&#125;子类2：public class Student extends Person&#123; @Override public void show() &#123; System.out.println(&quot;学生的信息为：&quot; + getName() + &quot;, &quot; + getAge()); &#125;&#125;子类3：public class Teacher extends Person&#123; @Override public void show() &#123; System.out.println(&quot;老师的信息为：&quot; + getName() + &quot;, &quot; + getAge()); &#125;&#125;测试类：public class Test &#123; public static void main(String[] args) &#123; //创建三个对象，并调用register方法 Student s = new Student(); s.setName(&quot;张三&quot;); s.setAge(18); Teacher t = new Teacher(); t.setName(&quot;王建国&quot;); t.setAge(30); Administrator admin = new Administrator(); admin.setName(&quot;管理员&quot;); admin.setAge(35); register(s); register(t); register(admin); &#125; //这个方法既能接收老师，又能接收学生，还能接收管理员 //只能把参数写成这三个类型的父类 public static void register(Person p)&#123; p.show(); &#125;&#125; 1.3 多态的定义和前提多态： 是指同一行为，具有多个不同表现形式。 从上面案例可以看出，Cat和Dog都是动物，都是吃这一行为，但是出现的效果（表现形式）是不一样的。 前提【重点】 有继承或者实现关系 方法的重写【意义体现：不重写，无意义】 父类引用指向子类对象【格式体现】 父类类型：指子类对象继承的父类类型，或者实现的父接口类型。 1.4 多态的运行特点调用成员变量时：编译看左边，运行看左边 调用成员方法时：编译看左边，运行看右边 代码示例： 1234567Fu f = new Zi()；//编译看左边的父类中有没有name这个属性，没有就报错//在实际运行的时候，把父类name属性的值打印出来System.out.println(f.name);//编译看左边的父类中有没有show这个方法，没有就报错//在实际运行的时候，运行的是子类中的show方法f.show(); 1.5 多态的弊端我们已经知道多态编译阶段是看左边父类类型的，如果子类有些独有的功能，此时多态的写法就无法访问子类独有功能了。 12345678910111213141516171819202122232425262728class Animal&#123; public void eat()｛ System.out.println(&quot;动物吃东西！&quot;) ｝&#125;class Cat extends Animal &#123; public void eat() &#123; System.out.println(&quot;吃鱼&quot;); &#125; public void catchMouse() &#123; System.out.println(&quot;抓老鼠&quot;); &#125; &#125; class Dog extends Animal &#123; public void eat() &#123; System.out.println(&quot;吃骨头&quot;); &#125; &#125;class Test&#123; public static void main(String[] args)&#123; Animal a = new Cat(); a.eat(); a.catchMouse();//编译报错，编译看左边，Animal没有这个方法 &#125;&#125; 1.6 引用类型转换1.6.1 为什么要转型多态的写法就无法访问子类独有功能了。 当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说，不能调用子类拥有，而父类没有的方法。编译都错误，更别说运行了。这也是多态给我们带来的一点”小麻烦”。所以，想要调用子类特有的方法，必须做向下转型。 回顾基本数据类型转换 自动转换: 范围小的赋值给范围大的.自动完成:double d &#x3D; 5; 强制转换: 范围大的赋值给范围小的,强制转换:int i &#x3D; (int)3.14 ​ 多态的转型分为向上转型（自动转换）与向下转型（强制转换）两种。 1.6.2 向上转型（自动转换） 向上转型：多态本身是子类类型向父类类型向上转换（自动转换）的过程，这个过程是默认的。当父类引用指向一个子类对象时，便是向上转型。使用格式： 12父类类型 变量名 = new 子类类型();如：Animal a = new Cat(); 原因是：父类类型相对与子类来说是大范围的类型，Animal是动物类，是父类类型。Cat是猫类，是子类类型。Animal类型的范围当然很大，包含一切动物。所以子类范围小可以直接自动转型给父类类型的变量。 1.6.3 向下转型（强制转换） 向下转型：父类类型向子类类型向下转换的过程，这个过程是强制的。一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型。 使用格式： 123子类类型 变量名 = (子类类型) 父类变量名;如:Aniaml a = new Cat(); Cat c =(Cat) a; 1.6.4 案例演示当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说，不能调用子类拥有，而父类没有的方法。编译都错误，更别说运行了。这也是多态给我们带来的一点”小麻烦”。所以，想要调用子类特有的方法，必须做向下转型。 转型演示，代码如下： 定义类： 123456789101112131415161718192021abstract class Animal &#123; abstract void eat(); &#125; class Cat extends Animal &#123; public void eat() &#123; System.out.println(&quot;吃鱼&quot;); &#125; public void catchMouse() &#123; System.out.println(&quot;抓老鼠&quot;); &#125; &#125; class Dog extends Animal &#123; public void eat() &#123; System.out.println(&quot;吃骨头&quot;); &#125; public void watchHouse() &#123; System.out.println(&quot;看家&quot;); &#125; &#125; 定义测试类： 1234567891011public class Test &#123; public static void main(String[] args) &#123; // 向上转型 Animal a = new Cat(); a.eat(); // 调用的是 Cat 的 eat // 向下转型 Cat c = (Cat)a; c.catchMouse(); // 调用的是 Cat 的 catchMouse &#125; &#125; 1.6.5 转型的异常转型的过程中，一不小心就会遇到这样的问题，请看如下代码： 1234567891011public class Test &#123; public static void main(String[] args) &#123; // 向上转型 Animal a = new Cat(); a.eat(); // 调用的是 Cat 的 eat // 向下转型 Dog d = (Dog)a; d.watchHouse(); // 调用的是 Dog 的 watchHouse 【运行报错】 &#125; &#125; 这段代码可以通过编译，但是运行时，却报出了 ClassCastException ，类型转换异常！这是因为，明明创建了Cat类型对象，运行时，当然不能转换成Dog对象的。 1.6.6 instanceof关键字为了避免ClassCastException的发生，Java提供了 instanceof 关键字，给引用变量做类型的校验，格式如下： 123变量名 instanceof 数据类型 如果变量属于该数据类型或者其子类类型，返回true。如果变量不属于该数据类型或者其子类类型，返回false。 所以，转换前，我们最好先做一个判断，代码如下： 12345678910111213141516public class Test &#123; public static void main(String[] args) &#123; // 向上转型 Animal a = new Cat(); a.eat(); // 调用的是 Cat 的 eat // 向下转型 if (a instanceof Cat)&#123; Cat c = (Cat)a; c.catchMouse(); // 调用的是 Cat 的 catchMouse &#125; else if (a instanceof Dog)&#123; Dog d = (Dog)a; d.watchHouse(); // 调用的是 Dog 的 watchHouse &#125; &#125; &#125; 1.6.7 instanceof新特性JDK14的时候提出了新特性，把判断和强转合并成了一行 12345678910//新特性//先判断a是否为Dog类型，如果是，则强转成Dog类型，转换之后变量名为d//如果不是，则不强转，结果直接是falseif(a instanceof Dog d)&#123; d.lookHome();&#125;else if(a instanceof Cat c)&#123; c.catchMouse();&#125;else&#123; System.out.println(&quot;没有这个类型，无法转换&quot;);&#125; 1.7 综合练习123456789101112131415161718192021222324252627282930313233需求：根据需求完成代码:\t1.定义狗类 属性： 年龄，颜色 行为: eat(String something)(something表示吃的东西) 看家lookHome方法(无参数)2.定义猫类\t属性： 年龄，颜色\t行为: eat(String something)方法(something表示吃的东西) 逮老鼠catchMouse方法(无参数)3.定义Person类//饲养员\t属性： 姓名，年龄\t行为： keepPet(Dog dog,String something)方法 功能：喂养宠物狗，something表示喂养的东西\t行为： keepPet(Cat cat,String something)方法 功能：喂养宠物猫，something表示喂养的东西\t生成空参有参构造，set和get方法 4.定义测试类(完成以下打印效果):\tkeepPet(Dog dog,String somethind)方法打印内容如下： 年龄为30岁的老王养了一只黑颜色的2岁的狗 2岁的黑颜色的狗两只前腿死死的抱住骨头猛吃\tkeepPet(Cat cat,String somethind)方法打印内容如下： 年龄为25岁的老李养了一只灰颜色的3岁的猫 3岁的灰颜色的猫眯着眼睛侧着头吃鱼5.思考： 1.Dog和Cat都是Animal的子类，以上案例中针对不同的动物，定义了不同的keepPet方法，过于繁琐，能否简化，并体会简化后的好处？\t2.Dog和Cat虽然都是Animal的子类，但是都有其特有方法，能否想办法在keepPet中调用特有方法？ 画图分析： 代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159//动物类（父类）public class Animal &#123; private int age; private String color; public Animal() &#123; &#125; public Animal(int age, String color) &#123; this.age = age; this.color = color; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125; public void eat(String something)&#123; System.out.println(&quot;动物在吃&quot; + something); &#125;&#125;//猫类（子类）public class Cat extends Animal &#123; public Cat() &#123; &#125; public Cat(int age, String color) &#123; super(age, color); &#125; @Override public void eat(String something) &#123; System.out.println(getAge() + &quot;岁的&quot; + getColor() + &quot;颜色的猫眯着眼睛侧着头吃&quot; + something); &#125; public void catchMouse()&#123; System.out.println(&quot;猫抓老鼠&quot;); &#125;&#125;//狗类（子类）public class Dog extends Animal &#123; public Dog() &#123; &#125; public Dog(int age, String color) &#123; super(age, color); &#125; //行为 //eat(String something)(something表示吃的东西) //看家lookHome方法(无参数) @Override public void eat(String something) &#123; System.out.println(getAge() + &quot;岁的&quot; + getColor() + &quot;颜色的狗两只前腿死死的抱住&quot; + something + &quot;猛吃&quot;); &#125; public void lookHome()&#123; System.out.println(&quot;狗在看家&quot;); &#125;&#125;//饲养员类public class Person &#123; private String name; private int age; public Person() &#123; &#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; //饲养狗 /* public void keepPet(Dog dog, String something) &#123; System.out.println(&quot;年龄为&quot; + age + &quot;岁的&quot; + name + &quot;养了一只&quot; + dog.getColor() + &quot;颜色的&quot; + dog.getAge() + &quot;岁的狗&quot;); dog.eat(something); &#125; //饲养猫 public void keepPet(Cat cat, String something) &#123; System.out.println(&quot;年龄为&quot; + age + &quot;岁的&quot; + name + &quot;养了一只&quot; + cat.getColor() + &quot;颜色的&quot; + cat.getAge() + &quot;岁的猫&quot;); cat.eat(something); &#125;*/ //想要一个方法，能接收所有的动物，包括猫，包括狗 //方法的形参：可以写这些类的父类 Animal public void keepPet(Animal a, String something) &#123; if(a instanceof Dog d)&#123; System.out.println(&quot;年龄为&quot; + age + &quot;岁的&quot; + name + &quot;养了一只&quot; + a.getColor() + &quot;颜色的&quot; + a.getAge() + &quot;岁的狗&quot;); d.eat(something); &#125;else if(a instanceof Cat c)&#123; System.out.println(&quot;年龄为&quot; + age + &quot;岁的&quot; + name + &quot;养了一只&quot; + c.getColor() + &quot;颜色的&quot; + c.getAge() + &quot;岁的猫&quot;); c.eat(something); &#125;else&#123; System.out.println(&quot;没有这种动物&quot;); &#125; &#125;&#125;//测试类public class Test &#123; public static void main(String[] args) &#123; //创建对象并调用方法 /* Person p1 = new Person(&quot;老王&quot;,30); Dog d = new Dog(2,&quot;黑&quot;); p1.keepPet(d,&quot;骨头&quot;); Person p2 = new Person(&quot;老李&quot;,25); Cat c = new Cat(3,&quot;灰&quot;); p2.keepPet(c,&quot;鱼&quot;);*/ //创建饲养员的对象 Person p = new Person(&quot;老王&quot;,30); Dog d = new Dog(2,&quot;黑&quot;); Cat c = new Cat(3,&quot;灰&quot;); p.keepPet(d,&quot;骨头&quot;); p.keepPet(c,&quot;鱼&quot;); &#125;&#125; 第二章 包2.1 包​\t包在操作系统中其实就是一个文件夹。包是用来分门别类的管理技术，不同的技术类放在不同的包下，方便管理和维护。 在IDEA项目中，建包的操作如下： 包名的命名规范： 12路径名.路径名.xxx.xxx// 例如：com.itheima.oa 包名一般是公司域名的倒写。例如：黑马是www.itheima.com,包名就可以定义成com.itheima.技术名称。 包名必须用”.“连接。 包名的每个路径名必须是一个合法的标识符，而且不能是Java的关键字。 2.2 导包什么时候需要导包？ ​\t情况一：在使用Java中提供的非核心包中的类时 ​\t情况二：使用自己写的其他包中的类时 什么时候不需要导包？ ​\t情况一：在使用Java核心包（java.lang）中的类时 ​\t情况二：在使用自己写的同一个包中的类时 2.3 使用不同包下的相同类怎么办？假设demo1和demo2中都有一个Student该如何使用？ 代码示例： 12345//使用全类名的形式即可。//全类名：包名 + 类名//拷贝全类名的快捷键：选中类名crtl + shift + alt + c 或者用鼠标点copy，再点击copy Referencecom.itheima.homework.demo1.Student s1 = new com.itheima.homework.demo1.Student();com.itheima.homework.demo2.Student s2 = new com.itheima.homework.demo2.Student(); 第三章 权限修饰符3.1 权限修饰符​\t在Java中提供了四种访问权限，使用不同的访问权限修饰符修饰时，被修饰的内容会有不同的访问权限，我们之前已经学习过了public 和 private，接下来我们研究一下protected和默认修饰符的作用。 public：公共的，所有地方都可以访问。 protected：本类 ，本包，其他包中的子类都可以访问。 默认（没有修饰符）：本类 ，本包可以访问。 注意：默认是空着不写，不是default private：私有的，当前类可以访问。public &gt; protected &gt; 默认 &gt; private 3.2 不同权限的访问能力 public protected 默认 private 同一类中 √ √ √ √ 同一包中的类 √ √ √ 不同包的子类 √ √ 不同包中的无关类 √ 可见，public具有最大权限。private则是最小权限。 编写代码时，如果没有特殊的考虑，建议这样使用权限： 成员变量使用private ，隐藏细节。 构造方法使用 public ，方便创建对象。 成员方法使用public ，方便调用方法。 小贴士：不加权限修饰符，就是默认权限 第四章 final关键字4.1 概述​\t学习了继承后，我们知道，子类可以在父类的基础上改写父类内容，比如，方法重写。 如果有一个方法我不想别人去改写里面内容，该怎么办呢？ Java提供了final 关键字，表示修饰的内容不可变。 final： 不可改变，最终的含义。可以用于修饰类、方法和变量。 类：被修饰的类，不能被继承。 方法：被修饰的方法，不能被重写。 变量：被修饰的变量，有且仅能被赋值一次。 4.2 使用方式4.2.1 修饰类final修饰的类，不能被继承。 格式如下： 12final class 类名 &#123;&#125; 代码: 123final class Fu &#123;&#125;// class Zi extends Fu &#123;&#125; // 报错,不能继承final的类 查询API发现像 public final class String 、public final class Math 、public final class Scanner 等，很多我们学习过的类，都是被final修饰的，目的就是供我们使用，而不让我们所以改变其内容。 4.2.2 修饰方法final修饰的方法，不能被重写。格式如下： 123修饰符 final 返回值类型 方法名(参数列表)&#123; //方法体&#125; 代码: 12345678910111213141516171819class Fu2 &#123;\tfinal public void show1() &#123; System.out.println(&quot;Fu2 show1&quot;);\t&#125;\tpublic void show2() &#123; System.out.println(&quot;Fu2 show2&quot;);\t&#125;&#125;class Zi2 extends Fu2 &#123;//\t@Override//\tpublic void show1() &#123;// System.out.println(&quot;Zi2 show1&quot;);//\t&#125;\t@Override\tpublic void show2() &#123; System.out.println(&quot;Zi2 show2&quot;);\t&#125;&#125; 4.2.3 修饰变量-局部变量 局部变量——基本类型基本类型的局部变量，被final修饰后，只能赋值一次，不能再更改。代码如下： 123456789101112131415public class FinalDemo1 &#123; public static void main(String[] args) &#123; // 声明变量，使用final修饰 final int a; // 第一次赋值 a = 10; // 第二次赋值 a = 20; // 报错,不可重新赋值 // 声明变量，直接赋值，使用final修饰 final int b = 10; // 第二次赋值 b = 20; // 报错,不可重新赋值 &#125;&#125; 思考，下面两种写法，哪种可以通过编译？ 写法1： 12345final int c = 0;for (int i = 0; i &lt; 10; i++) &#123; c = i; System.out.println(c);&#125; 写法2： 1234for (int i = 0; i &lt; 10; i++) &#123; final int c = i; System.out.println(c);&#125; 根据 final 的定义，写法1报错！写法2，为什么通过编译呢？因为每次循环，都是一次新的变量c。这也是大家需要注意的地方。 4.2.4 修饰变量-成员变量成员变量涉及到初始化的问题，初始化方式有显示初始化和构造方法初始化，只能选择其中一个： 显示初始化(在定义成员变量的时候立马赋值)（常用）； 123public class Student &#123; final int num = 10;&#125; 构造方法初始化(在构造方法中赋值一次)（不常用，了解即可）。 注意：每个构造方法中都要赋值一次！ 1234567891011121314public class Student &#123; final int num = 10; final int num2; public Student() &#123; this.num2 = 20;// this.num2 = 20; &#125; public Student(String name) &#123; this.num2 = 20;// this.num2 = 20; &#125;&#125; 被final修饰的常量名称，一般都有书写规范，所有字母都大写。"},{"title":"static和继承","path":"/posts/620348626/","content":"面向对象进阶部分学习方法：特点： ​\t逻辑性没有那么强，但是概念会比较多。 ​\t记忆部分重要的概念，理解课堂上讲解的需要大家掌握的概念，多多练习代码。 day13今日内容 复习回顾 static关键字 继承 教学目标 能够掌握static关键字修饰的变量调用方式 能够掌握static关键字修饰的方法调用方式 知道静态代码块的格式和应用场景 能够写出类的继承格式 能够说出继承的特点 能够区分this和super的作用 能够说出方法重写的概念 能够说出方法重写的注意事项 第一章 复习回顾1.1 如何定义类类的定义格式如下: 12345修饰符 class 类名 &#123; // 1.成员变量（属性） // 2.成员方法 (行为) // 3.构造方法 （初始化类的对象数据的）&#125; 例如: 123456public class Student &#123; // 1.成员变量 public String name ; public char sex ; // &#x27;男&#x27; &#x27;女&#x27; public int age;&#125; 1.2 如何通过类创建对象1类名 对象名称 = new 类名(); 例如: 1Student stu = new Student(); 1.3 封装1.3.1 封装的步骤1.使用 private 关键字来修饰成员变量。 2.使用public修饰getter和setter方法。 1.3.2 封装的步骤实现 private修饰成员变量 1234public class Student &#123; private String name; private int age;&#125; public修饰getter和setter方法 123456789101112131415161718192021222324public class Student &#123; private String name; private int age; public void setName(String n) &#123; name = n; &#125; public String getName() &#123; return name; &#125; public void setAge(int a) &#123; if (a &gt; 0 &amp;&amp; a &lt;200) &#123; age = a; &#125; else &#123; System.out.println(&quot;年龄非法！&quot;); &#125; &#125; public int getAge() &#123; return age; &#125;&#125; 1.4 构造方法1.4.1 构造方法的作用在创建对象的时候，给成员变量进行初始化。 初始化即赋值的意思。 1.4.2 构造方法的格式123修饰符 类名(形参列表) &#123; // 构造体代码，执行代码&#125; 1.4.3 构造方法的应用首先定义一个学生类，代码如下： 12345678910public class Student &#123; // 1.成员变量 public String name; public int age; // 2.构造方法 public Student() &#123; System.out.println(&quot;无参数构造方法被调用&quot;)； &#125;&#125; 接下来通过调用构造方法得到两个学生对象。 123456789101112131415161718192021public class CreateStu02 &#123; public static void main(String[] args) &#123; // 创建一个学生对象 // 类名 变量名称 = new 类名(); Student s1 = new Student(); // 使用对象访问成员变量，赋值 s1.name = &quot;张三&quot;; s1.age = 20 ; // 使用对象访问成员变量 输出值 System.out.println(s1.name); System.out.println(s1.age); Student s2 = new Student(); // 使用对象访问成员变量 赋值 s2.name = &quot;李四&quot;; s2.age = 18 ; System.out.println(s2.name); System.out.println(s2.age); &#125;&#125; 1.5 this关键字的作用1.5.1 this关键字的作用this代表所在类的当前对象的引用（地址值），即代表当前对象。 1.5.2 this关键字的应用1.5.2.1 用于普通的gettter与setter方法this出现在实例方法中，谁调用这个方法（哪个对象调用这个方法），this就代表谁（this就代表哪个对象）。 123456789101112131415161718192021222324public class Student &#123; private String name; private int age; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setAge(int age) &#123; if (age &gt; 0 &amp;&amp; age &lt; 200) &#123; this.age = age; &#125; else &#123; System.out.println(&quot;年龄非法！&quot;); &#125; &#125; public int getAge() &#123; return age; &#125;&#125; 1.5.2.2 用于构造方法中this出现在构造方法中，代表构造方法正在初始化的那个对象。 12345678910111213public class Student &#123; private String name; private int age; // 无参数构造方法 public Student() &#123;&#125; // 有参数构造方法 public Student(String name,int age) &#123; this.name = name; this.age = age; &#125;&#125; 第二章 static关键字2.1 概述以前我们定义过如下类： 12345678910111213141516public class Student &#123; // 成员变量 public String name; public char sex; // &#x27;男&#x27; &#x27;女&#x27; public int age; // 无参数构造方法 public Student() &#123; &#125; // 有参数构造方法 public Student(String a) &#123; &#125;&#125; 我们已经知道面向对象中，存在类和对象的概念，我们在类中定义了一些成员变量，例如name,age,sex ,结果发现这些成员变量，每个对象都存在（因为每个对象都可以访问）。 而像name ,age , sex确实是每个学生对象都应该有的属性，应该属于每个对象。 所以Java中成员（变量和方法）等是存在所属性的，Java是通过static关键字来区分的。static关键字在Java开发非常的重要，对于理解面向对象非常关键。 关于 static 关键字的使用，它可以用来修饰的成员变量和成员方法，被static修饰的成员是属于类的是放在静态区中，没有static修饰的成员变量和方法则是属于对象的。我们上面案例中的成员变量都是没有static修饰的，所以属于每个对象。 2.2 定义格式和使用static是静态的意思。 static可以修饰成员变量或者修饰方法。 2.2.1 静态变量及其访问有static修饰成员变量，说明这个成员变量是属于类的，这个成员变量称为类变量或者静态成员变量。 直接用 类名访问即可。因为类只有一个，所以静态成员变量在内存区域中也只存在一份。所有的对象都可以共享这个变量。 如何使用呢 例如现在我们需要定义传智全部的学生类，那么这些学生类的对象的学校属性应该都是“传智”，这个时候我们可以把这个属性定义成static修饰的静态成员变量。 定义格式 1修饰符 static 数据类型 变量名 = 初始值； 举例 1234public class Student &#123; public static String schoolName = &quot;传智播客&quot;； // 属于类，只有一份。 // .....&#125; 静态成员变量的访问: 格式：类名.静态变量 12345public static void main(String[] args)&#123; System.out.println(Student.schoolName); // 传智播客 Student.schoolName = &quot;黑马程序员&quot;; System.out.println(Student.schoolName); // 黑马程序员&#125; 2.2.2 实例变量及其访问无static修饰的成员变量属于每个对象的， 这个成员变量叫实例变量，之前我们写成员变量就是实例成员变量。 需要注意的是：实例成员变量属于每个对象，必须创建类的对象才可以访问。 格式：对象.实例成员变量 2.2.3 静态方法及其访问有static修饰成员方法，说明这个成员方法是属于类的，这个成员方法称为类方法或者静态方法**。 直接用 类名访问即可。因为类只有一个，所以静态方法在内存区域中也只存在一份。所有的对象都可以共享这个方法。 与静态成员变量一样，静态方法也是直接通过类名.方法名称即可访问。 举例 1234567public class Student&#123; public static String schoolName = &quot;传智播客&quot;； // 属于类，只有一份。 // ..... public static void study()&#123; System.out.println(&quot;我们都在黑马程序员学习&quot;); &#125;&#125; 静态成员变量的访问: 格式：类名.静态方法 123public static void main(String[] args)&#123; Student.study();&#125; 2.2.4 实例方法及其访问无static修饰的成员方法属于每个对象的，这个成员方法也叫做实例方法。 需要注意的是：实例方法是属于每个对象，必须创建类的对象才可以访问。 格式：对象.实例方法 示例： 12345678910111213141516public class Student &#123; // 实例变量 private String name ; // 2.方法：行为 // 无 static修饰，实例方法。属于每个对象，必须创建对象调用 public void run()&#123; System.out.println(&quot;学生可以跑步&quot;); &#125;\t// 无 static修饰，实例方法 public void sleep()&#123; System.out.println(&quot;学生睡觉&quot;); &#125; public static void study()&#123; &#125;&#125; 12345678public static void main(String[] args)&#123; // 创建对象 Student stu = new Student ; stu.name = &quot;徐干&quot;; // Student.sleep();// 报错，必须用对象访问。 stu.sleep(); stu.run();&#125; 2.3 小结1.当 static 修饰成员变量或者成员方法时，该变量称为静态变量，该方法称为静态方法。该类的每个对象都共享同一个类的静态变量和静态方法。任何对象都可以更改该静态变量的值或者访问静态方法。但是不推荐这种方式去访问。因为静态变量或者静态方法直接通过类名访问即可，完全没有必要用对象去访问。 2.无static修饰的成员变量或者成员方法，称为实例变量，实例方法，实例变量和实例方法必须创建类的对象，然后通过对象来访问。 3.static修饰的成员属于类，会存储在静态区，是随着类的加载而加载的，且只加载一次，所以只有一份，节省内存。存储于一块固定的内存区域（静态区），所以，可以直接被类名调用。它优先于对象存在，所以，可以被所有对象共享。 4.无static修饰的成员，是属于对象，对象有多少个，他们就会出现多少份。所以必须由对象调用。 第三章 继承3.1 概述3.1.1 引入假如我们要定义如下类:学生类,老师类和工人类，分析如下。 学生类属性:姓名,年龄行为:吃饭,睡觉 老师类属性:姓名,年龄，薪水行为:吃饭,睡觉，教书 班主任属性:姓名,年龄，薪水行为:吃饭,睡觉，管理 如果我们定义了这三个类去开发一个系统，那么这三个类中就存在大量重复的信息（属性:姓名，年龄。行为：吃饭，睡觉）。这样就导致了相同代码大量重复，代码显得很臃肿和冗余，那么如何解决呢？ 假如多个类中存在相同属性和行为时，我们可以将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那一个类即可。如图所示： 其中，多个类可以称为子类，单独被继承的那一个类称为父类、超类（superclass）或者基类。 3.1.2 继承的含义继承描述的是事物之间的所属关系，这种关系是：is-a 的关系。例如，兔子属于食草动物，食草动物属于动物。可见，父类更通用，子类更具体。我们通过继承，可以使多种事物之间形成一种关系体系。 继承：就是子类继承父类的属性和行为，使得子类对象可以直接具有与父类相同的属性、相同的行为。子类可以直接访问父类中的非私有的属性和行为。 3.1.3 继承的好处 提高代码的复用性（减少代码冗余，相同代码重复利用）。 使类与类之间产生了关系。 3.2 继承的格式通过 extends 关键字，可以声明一个子类继承另外一个父类，定义格式如下： 1234567class 父类 &#123;\t...&#125;class 子类 extends 父类 &#123;\t...&#125; 需要注意：Java是单继承的，一个类只能继承一个直接父类，跟现实世界很像，但是Java中的子类是更加强大的。 3.3 继承案例3.3.1 案例请使用继承定义以下类: 学生类属性:姓名,年龄行为:吃饭,睡觉 老师类属性:姓名,年龄，薪水行为:吃饭,睡觉，教书 班主任属性:姓名,年龄，薪水行为:吃饭,睡觉，管理 3.3.2 案例图解分析老师类，学生类，还有班主任类，实际上都是属于人类的，我们可以定义一个人类，把他们相同的属性和行为都定义在人类中，然后继承人类即可，子类特有的属性和行为就定义在子类中了。 如下图所示。 3.3.3 案例代码实现1.父类Human类 12345678910111213141516171819202122public class Human &#123; // 合理隐藏 private String name ; private int age ; // 合理暴露 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 2.子类Teacher类 1234567891011121314151617public class Teacher extends Human &#123; // 工资 private double salary ; // 特有方法 public void teach()&#123; System.out.println(&quot;老师在认真教技术！&quot;)； &#125; public double getSalary() &#123; return salary; &#125; public void setSalary(double salary) &#123; this.salary = salary; &#125;&#125; 3.子类Student类 123public class Student extends Human&#123; &#125; 4.子类BanZhuren类 1234567891011121314151617public class Teacher extends Human &#123; // 工资 private double salary ; // 特有方法 public void admin()&#123; System.out.println(&quot;班主任强调纪律问题！&quot;)； &#125; public double getSalary() &#123; return salary; &#125; public void setSalary(double salary) &#123; this.salary = salary; &#125;&#125; 5.测试类 12345678910111213141516171819202122232425262728293031public class Test &#123; public static void main(String[] args) &#123; Teacher dlei = new Teacher(); dlei.setName(&quot;播仔&quot;); dlei.setAge(&quot;31&quot;); dlei.setSalary(1000.99); System.out.println(dlei.getName()); System.out.println(dlei.getAge()); System.out.println(dlei.getSalary()); dlei.teach(); BanZhuRen linTao = new BanZhuRen(); linTao.setName(&quot;灵涛&quot;); linTao.setAge(&quot;28&quot;); linTao.setSalary(1000.99); System.out.println(linTao.getName()); System.out.println(linTao.getAge()); System.out.println(linTao.getSalary()); linTao.admin(); Student xugan = new Student(); xugan.setName(&quot;播仔&quot;); xugan.setAge(&quot;31&quot;); //xugan.setSalary(1000.99); // xugan没有薪水属性，报错！ System.out.println(xugan.getName()); System.out.println(xugan.getAge()); &#125;&#125; 3.3.4 小结1.继承实际上是子类相同的属性和行为可以定义在父类中，子类特有的属性和行为由自己定义，这样就实现了相同属性和行为的重复利用，从而提高了代码复用。 2.子类继承父类，就可以直接得到父类的成员变量和方法。是否可以继承所有成分呢？请看下节！ 3.4 子类不能继承的内容3.4.1 引入并不是父类的所有内容都可以给子类继承的： 子类不能继承父类的构造方法。 值得注意的是子类可以继承父类的私有成员（成员变量，方法），只是子类无法直接访问而已，可以通过getter&#x2F;setter方法访问父类的private成员变量。 3.4.1 演示代码123456789101112131415161718192021222324252627282930313233343536public class Demo03 &#123; public static void main(String[] args) &#123; Zi z = new Zi(); System.out.println(z.num1);// System.out.println(z.num2); // 私有的子类无法使用 // 通过getter/setter方法访问父类的private成员变量 System.out.println(z.getNum2()); z.show1(); // z.show2(); // 私有的子类无法使用 &#125;&#125;class Fu &#123; public int num1 = 10; private int num2 = 20; public void show1() &#123; System.out.println(&quot;show1&quot;); &#125; private void show2() &#123; System.out.println(&quot;show2&quot;); &#125; public int getNum2() &#123; return num2; &#125; public void setNum2(int num2) &#123; this.num2 = num2; &#125;&#125;class Zi extends Fu &#123;&#125; 3.5 继承后的特点—成员变量当类之间产生了继承关系后，其中各类中的成员变量，又产生了哪些影响呢？ 3.5.1 成员变量不重名如果子类父类中出现不重名的成员变量，这时的访问是没有影响的。代码如下： 12345678910111213141516171819202122232425262728class Fu &#123;\t// Fu中的成员变量\tint num = 5;&#125;class Zi extends Fu &#123;\t// Zi中的成员变量\tint num2 = 6; // Zi中的成员方法\tpublic void show() &#123; // 访问父类中的num System.out.println(&quot;Fu num=&quot;+num); // 继承而来，所以直接访问。 // 访问子类中的num2 System.out.println(&quot;Zi num2=&quot;+num2);\t&#125;&#125;class Demo04 &#123;\tpublic static void main(String[] args) &#123; // 创建子类对象 Zi z = new Zi(); // 调用子类中的show方法 z.show(); &#125;&#125;演示结果：Fu num = 5Zi num2 = 6 3.5.2 成员变量重名如果子类父类中出现重名的成员变量，这时的访问是有影响的。代码如下： 1234567891011121314151617181920212223242526class Fu1 &#123;\t// Fu中的成员变量。\tint num = 5;&#125;class Zi1 extends Fu1 &#123;\t// Zi中的成员变量\tint num = 6; public void show() &#123; // 访问父类中的num System.out.println(&quot;Fu num=&quot; + num); // 访问子类中的num System.out.println(&quot;Zi num=&quot; + num);\t&#125;&#125;class Demo04 &#123;\tpublic static void main(String[] args) &#123; // 创建子类对象 Zi1 z = new Zi1(); // 调用子类中的show方法 z1.show(); &#125;&#125;演示结果：Fu num = 6Zi num = 6 子父类中出现了同名的成员变量时，子类会优先访问自己对象中的成员变量。如果此时想访问父类成员变量如何解决呢？我们可以使用super关键字。 3.5.3 super访问父类成员变量子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有成员变量时，需要使用super 关键字，修饰父类成员变量，类似于之前学过的 this 。 需要注意的是：super代表的是父类对象的引用，this代表的是当前对象的引用。 使用格式： 1super.父类成员变量名 子类方法需要修改，代码如下： 12345678910111213141516171819202122232425262728293031323334class Fu &#123;\t// Fu中的成员变量。\tint num = 5;&#125;class Zi extends Fu &#123;\t// Zi中的成员变量\tint num = 6; public void show() &#123; int num = 1; // 访问方法中的num System.out.println(&quot;method num=&quot; + num); // 访问子类中的num System.out.println(&quot;Zi num=&quot; + this.num); // 访问父类中的num System.out.println(&quot;Fu num=&quot; + super.num);\t&#125;&#125;class Demo04 &#123;\tpublic static void main(String[] args) &#123; // 创建子类对象 Zi1 z = new Zi1(); // 调用子类中的show方法 z1.show(); &#125;&#125;演示结果：method num=1Zi num=6Fu num=5 小贴士：Fu 类中的成员变量是非私有的，子类中可以直接访问。若Fu 类中的成员变量私有了，子类是不能直接访问的。通常编码时，我们遵循封装的原则，使用private修饰成员变量，那么如何访问父类的私有成员变量呢？对！可以在父类中提供公共的getXxx方法和setXxx方法。 3.6 继承后的特点—成员方法当类之间产生了关系，其中各类中的成员方法，又产生了哪些影响呢？ 3.6.1 成员方法不重名如果子类父类中出现不重名的成员方法，这时的调用是没有影响的。对象调用方法时，会先在子类中查找有没有对应的方法，若子类中存在就会执行子类中的方法，若子类中不存在就会执行父类中相应的方法。代码如下： 123456789101112131415161718class Fu &#123;\tpublic void show() &#123; System.out.println(&quot;Fu类中的show方法执行&quot;);\t&#125;&#125;class Zi extends Fu &#123;\tpublic void show2() &#123; System.out.println(&quot;Zi类中的show2方法执行&quot;);\t&#125;&#125;public class Demo05 &#123;\tpublic static void main(String[] args) &#123; Zi z = new Zi(); //子类中没有show方法，但是可以找到父类方法去执行 z.show(); z.show2();\t&#125;&#125; 3.6.2 成员方法重名如果子类父类中出现重名的成员方法，则创建子类对象调用该方法的时候，子类对象会优先调用自己的方法。 代码如下： 123456789101112131415161718class Fu &#123;\tpublic void show() &#123; System.out.println(&quot;Fu show&quot;);\t&#125;&#125;class Zi extends Fu &#123;\t//子类重写了父类的show方法\tpublic void show() &#123; System.out.println(&quot;Zi show&quot;);\t&#125;&#125;public class ExtendsDemo05&#123;\tpublic static void main(String[] args) &#123; Zi z = new Zi(); // 子类中有show方法，只执行重写后的show方法 z.show(); // Zi show\t&#125;&#125; 3.7 方法重写3.7.1 概念方法重写 ：子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果，也称为重写或者复写。声明不变，重新实现。 3.7.2 使用场景与案例发生在子父类之间的关系。子类继承了父类的方法，但是子类觉得父类的这方法不足以满足自己的需求，子类重新写了一个与父类同名的方法，以便覆盖父类的该方 法。 例如：我们定义了一个动物类代码如下： 12345678public class Animal &#123; public void run()&#123; System.out.println(&quot;动物跑的很快！&quot;); &#125; public void cry()&#123; System.out.println(&quot;动物都可以叫~~~&quot;); &#125;&#125; 然后定义一个猫类，猫可能认为父类cry()方法不能满足自己的需求 代码如下： 12345678910111213141516public class Cat extends Animal &#123; public void cry()&#123; System.out.println(&quot;我们一起学猫叫，喵喵喵！喵的非常好听！&quot;); &#125;&#125;public class Test &#123;\tpublic static void main(String[] args) &#123; // 创建子类对象 Cat ddm = new Cat()； // 调用父类继承而来的方法 ddm.run(); // 调用子类重写的方法 ddm.cry();\t&#125;&#125; 3.7.2 @Override重写注解 @Override:注解，重写注解校验！ 这个注解标记的方法，就说明这个方法必须是重写父类的方法，否则编译阶段报错。 建议重写都加上这个注解，一方面可以提高代码的可读性，一方面可以防止重写出错！ 加上后的子类代码形式如下： 12345678public class Cat extends Animal &#123; // 声明不变，重新实现 // 方法名称与父类全部一样，只是方法体中的功能重写写了！ @Override public void cry()&#123; System.out.println(&quot;我们一起学猫叫，喵喵喵！喵的非常好听！&quot;); &#125;&#125; 3.7.3 注意事项 方法重写是发生在子父类之间的关系。 子类方法覆盖父类方法，必须要保证权限大于等于父类权限。 子类方法覆盖父类方法，返回值类型、函数名和参数列表都要一模一样。 3.8 继承后的特点—构造方法3.8.1 引入当类之间产生了关系，其中各类中的构造方法，又产生了哪些影响呢？首先我们要回忆两个事情，构造方法的定义格式和作用。 构造方法的名字是与类名一致的。所以子类是无法继承父类构造方法的。 构造方法的作用是初始化对象成员变量数据的。所以子类的初始化过程中，必须先执行父类的初始化动作。子类的构造方法中默认有一个super() ，表示调用父类的构造方法，父类成员变量初始化后，才可以给子类使用。（先有爸爸，才能有儿子） 继承后子类构方法器特点:子类所有构造方法的第一行都会默认先调用父类的无参构造方法 3.8.2 案例演示按如下需求定义类: 人类成员变量: 姓名,年龄成员方法: 吃饭 学生类成员变量: 姓名,年龄,成绩成员方法: 吃饭 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041class Person &#123; private String name; private int age; public Person() &#123; System.out.println(&quot;父类无参&quot;); &#125; // getter/setter省略&#125;class Student extends Person &#123; private double score; public Student() &#123; //super(); // 调用父类无参,默认就存在，可以不写，必须再第一行 System.out.println(&quot;子类无参&quot;); &#125; public Student(double score) &#123; //super(); // 调用父类无参,默认就存在，可以不写，必须再第一行 this.score = score; System.out.println(&quot;子类有参&quot;); &#125;&#125;public class Demo07 &#123; public static void main(String[] args) &#123; Student s1 = new Student(); System.out.println(&quot;----------&quot;); Student s2 = new Student(99.9); &#125;&#125;输出结果：父类无参子类无参----------父类无参子类有参 3.8.3 小结 子类构造方法执行的时候，都会在第一行默认先调用父类无参数构造方法一次。 子类构造方法的第一行都隐含了一个**super()去调用父类无参数构造方法，super()**可以省略不写。 3.9 super(…)和this(…)3.9.1 引入请看上节中的如下案例： 123456789101112131415161718192021222324252627282930313233343536class Person &#123; private String name; private int age; public Person() &#123; System.out.println(&quot;父类无参&quot;); &#125; // getter/setter省略&#125;class Student extends Person &#123; private double score; public Student() &#123; //super(); // 调用父类无参构造方法,默认就存在，可以不写，必须再第一行 System.out.println(&quot;子类无参&quot;); &#125; public Student(double score) &#123; //super(); // 调用父类无参构造方法,默认就存在，可以不写，必须再第一行 this.score = score; System.out.println(&quot;子类有参&quot;); &#125; // getter/setter省略&#125;public class Demo07 &#123; public static void main(String[] args) &#123; // 调用子类有参数构造方法 Student s2 = new Student(99.9); System.out.println(s2.getScore()); // 99.9 System.out.println(s2.getName()); // 输出 null System.out.println(s2.getAge()); // 输出 0 &#125;&#125; 我们发现，子类有参数构造方法只是初始化了自己对象中的成员变量score，而父类中的成员变量name和age依然是没有数据的，怎么解决这个问题呢，我们可以借助与super(…)去调用父类构造方法，以便初始化继承自父类对象的name和age. 3.9.2 super和this的用法格式super和this完整的用法如下，其中this，super访问成员我们已经接触过了。 12345this.成员变量 -- 本类的super.成员变量 -- 父类的this.成员方法名() -- 本类的 super.成员方法名() -- 父类的 接下来我们使用调用构造方法格式： 12super(...) -- 调用父类的构造方法，根据参数匹配确认this(...) -- 调用本类的其他构造方法，根据参数匹配确认 3.9.3 super(….)用法演示代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041class Person &#123; private String name =&quot;凤姐&quot;; private int age = 20; public Person() &#123; System.out.println(&quot;父类无参&quot;); &#125; public Person(String name , int age)&#123; this.name = name ; this.age = age ; &#125; // getter/setter省略&#125;class Student extends Person &#123; private double score = 100; public Student() &#123; //super(); // 调用父类无参构造方法,默认就存在，可以不写，必须再第一行 System.out.println(&quot;子类无参&quot;); &#125; public Student(String name ， int age，double score) &#123; super(name ,age);// 调用父类有参构造方法Person(String name , int age)初始化name和age this.score = score; System.out.println(&quot;子类有参&quot;); &#125; // getter/setter省略&#125;public class Demo07 &#123; public static void main(String[] args) &#123; // 调用子类有参数构造方法 Student s2 = new Student(&quot;张三&quot;，20，99); System.out.println(s2.getScore()); // 99 System.out.println(s2.getName()); // 输出 张三 System.out.println(s2.getAge()); // 输出 20 &#125;&#125; 注意： 子类的每个构造方法中均有默认的super()，调用父类的空参构造。手动调用父类构造会覆盖默认的super()。 super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。 super(..)是根据参数去确定调用父类哪个构造方法的。 3.9.4 super(…)案例图解父类空间优先于子类对象产生 在每次创建子类对象时，先初始化父类空间，再创建其子类对象本身。目的在于子类对象中包含了其对应的父类空间，便可以包含其父类的成员，如果父类成员非private修饰，则子类可以随意使用父类成员。代码体现在子类的构造七调用时，一定先调用父类的构造方法。理解图解如下： 3.9.5 this(…)用法演示this(…) 默认是去找本类中的其他构造方法，根据参数来确定具体调用哪一个构造方法。 为了借用其他构造方法的功能。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.itheima._08this和super调用构造方法;/** * this(...): * 默认是去找本类中的其他构造方法，根据参数来确定具体调用哪一个构造方法。 * 为了借用其他构造方法的功能。 * */public class ThisDemo01 &#123; public static void main(String[] args) &#123; Student xuGan = new Student(); System.out.println(xuGan.getName()); // 输出:徐干 System.out.println(xuGan.getAge());// 输出:21 System.out.println(xuGan.getSex());// 输出： 男 &#125;&#125;class Student&#123; private String name ; private int age ; private char sex ; public Student() &#123; // 很弱，我的兄弟很牛逼啊，我可以调用其他构造方法：Student(String name, int age, char sex) this(&quot;徐干&quot;,21,&#x27;男&#x27;); &#125; public Student(String name, int age, char sex) &#123; this.name = name ; this.age = age ; this.sex = sex ; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public char getSex() &#123; return sex; &#125; public void setSex(char sex) &#123; this.sex = sex; &#125;&#125; 3.9.6 小结 子类的每个构造方法中均有默认的super()，调用父类的空参构造。手动调用父类构造会覆盖默认的super()。 super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。 super(..)和this(…)是根据参数去确定调用父类哪个构造方法的。 super(..)可以调用父类构造方法初始化继承自父类的成员变量的数据。 this(..)可以调用本类中的其他构造方法。 3.10 继承的特点 Java只支持单继承，不支持多继承。 12345// 一个类只能有一个父类，不可以有多个父类。class A &#123;&#125;class B &#123;&#125;class C1 extends A &#123;&#125; // ok// class C2 extends A, B &#123;&#125; // error 一个类可以有多个子类。 1234// A可以有多个子类class A &#123;&#125;class C1 extends A &#123;&#125;class C2 extends A &#123;&#125; 可以多层继承。 123class A &#123;&#125;class C1 extends A &#123;&#125;class D extends C1 &#123;&#125; 顶层父类是Object类。所有的类默认继承Object，作为父类。 4. 关于今天知识的小结：会写一个继承结构下的标准Javabean即可 需求： ​\t猫：属性，姓名，年龄，颜色 ​\t狗：属性，姓名，年龄，颜色，吼叫 分享书写技巧： ​ 1.在大脑中要区分谁是父，谁是子 ​ 2.把共性写到父类中，独有的东西写在子类中 ​ 3.开始编写标准Javabean（从上往下写） ​ 4.在测试类中，创建对象并赋值调用 代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package com.itheima.test4;public class Animal &#123; //姓名，年龄，颜色 private String name; private int age; private String color; public Animal() &#123; &#125; public Animal(String name, int age, String color) &#123; this.name = name; this.age = age; this.color = color; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125;&#125;public class Cat extends Animal&#123; //因为猫类中没有独有的属性。 //所以此时不需要写私有的成员变量 //空参 public Cat() &#123; &#125; //需要带子类和父类中所有的属性 public Cat(String name, int age, String color) &#123; super(name,age,color); &#125;&#125;public class Dog extends Animal&#123; //Dog ：吼叫 private String wang; //构造 public Dog() &#123; &#125; //带参构造：带子类加父类所有的属性 public Dog(String name, int age, String color,String wang) &#123; //共性的属性交给父类赋值 super(name,age,color); //独有的属性自己赋值 this.wang = wang; &#125; public String getWang() &#123; return wang; &#125; public void setWang(String wang) &#123; this.wang = wang; &#125;&#125;public class Demo &#123; public static void main(String[] args) &#123; //Animal ： 姓名，年龄，颜色 //Cat : //Dog ：吼叫 //创建狗的对象 Dog d = new Dog(&quot;旺财&quot;,2,&quot;黑色&quot;,&quot;嗷呜~~&quot;); System.out.println(d.getName()+&quot;, &quot; + d.getAge() + &quot;, &quot; + d.getColor() + &quot;, &quot; + d.getWang()); //创建猫的对象 Cat c = new Cat(&quot;中华田园猫&quot;,3,&quot;黄色&quot;); System.out.println(c.getName() + &quot;, &quot; + c.getAge() + &quot;, &quot; + c.getColor()); &#125;&#125;"},{"title":"集合&学生管理系统","path":"/posts/2681060841/","content":"1.ArrayList集合和数组的优势对比： 长度可变 添加数据的时候不需要考虑索引，默认将数据添加到末尾 1.1 ArrayList类概述 什么是集合 ​\t提供一种存储空间可变的存储模型，存储的数据容量可以发生改变 ArrayList集合的特点 ​\t长度可以变化，只能存储引用数据类型。 泛型的使用 ​\t用于约束集合中存储元素的数据类型 1.2 ArrayList类常用方法1.2.1 构造方法 方法名 说明 public ArrayList() 创建一个空的集合对象 1.2.2 成员方法 方法名 说明 public boolean add(要添加的元素) 将指定的元素追加到此集合的末尾 public boolean remove(要删除的元素) 删除指定元素,返回值表示是否删除成功 public E remove(int index) 删除指定索引处的元素，返回被删除的元素 public E set(int index,E element) 修改指定索引处的元素，返回被修改的元素 public E get(int index) 返回指定索引处的元素 public int size() 返回集合中的元素的个数 1.2.3 示例代码123456789101112131415161718192021222324252627282930313233343536373839public class ArrayListDemo02 &#123; public static void main(String[] args) &#123; //创建集合 ArrayList&lt;String&gt; array = new ArrayList&lt;String&gt;(); //添加元素 array.add(&quot;hello&quot;); array.add(&quot;world&quot;); array.add(&quot;java&quot;); //public boolean remove(Object o)：删除指定的元素，返回删除是否成功 // System.out.println(array.remove(&quot;world&quot;)); // System.out.println(array.remove(&quot;javaee&quot;)); //public E remove(int index)：删除指定索引处的元素，返回被删除的元素 // System.out.println(array.remove(1)); //IndexOutOfBoundsException // System.out.println(array.remove(3)); //public E set(int index,E element)：修改指定索引处的元素，返回被修改的元素 // System.out.println(array.set(1,&quot;javaee&quot;)); //IndexOutOfBoundsException // System.out.println(array.set(3,&quot;javaee&quot;)); //public E get(int index)：返回指定索引处的元素 // System.out.println(array.get(0)); // System.out.println(array.get(1)); // System.out.println(array.get(2)); //System.out.println(array.get(3)); //？？？？？？ 自己测试 //public int size()：返回集合中的元素的个数 System.out.println(array.size()); //输出集合 System.out.println(&quot;array:&quot; + array); &#125;&#125; 1.3 ArrayList存储字符串并遍历1.3.1 案例需求​\t创建一个存储字符串的集合，存储3个字符串元素，使用程序实现在控制台遍历该集合 1.3.2 代码实现123456789101112131415161718192021222324252627282930public class ArrayListDemo3 &#123; public static void main(String[] args) &#123; //1.创建集合对象 ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); //2.添加元素 list.add(&quot;aaa&quot;); list.add(&quot;bbb&quot;); list.add(&quot;ccc&quot;); list.add(&quot;ddd&quot;); //3.遍历 //快捷键: list.fori 正向遍历 //list.forr 倒着遍历 System.out.print(&quot;[&quot;); for (int i = 0; i &lt; list.size(); i++) &#123; //i 依次表示集合里面的每一个索引 if(i == list.size() - 1)&#123; //最大索引 System.out.print(list.get(i)); &#125;else&#123; //非最大索引 System.out.print(list.get(i) + &quot;, &quot;); &#125; &#125; System.out.print(&quot;]&quot;); &#125;&#125; 1.4 ArrayList存储学生对象并遍历1.4.1 案例需求​\t创建一个存储学生对象的集合，存储3个学生对象，使用程序实现在控制台遍历该集合 1.4.2 代码实现123456789101112131415161718192021222324252627public class ArrayListDemo4 &#123; public static void main(String[] args) &#123; //1.创建集合对象，用来存储数据 ArrayList&lt;Student&gt; list = new ArrayList&lt;&gt;(); //2.创建学生对象 Student s1 = new Student(&quot;zhangsan&quot;,16); Student s2 = new Student(&quot;lisi&quot;,15); Student s3 = new Student(&quot;wangwu&quot;,18); //3.把学生对象添加到集合中 list.add(s1); list.add(s2); list.add(s3); //4.遍历 for (int i = 0; i &lt; list.size(); i++) &#123; //i 依次表示集合中的每一个索引 Student stu = list.get(i); System.out.println(stu.getName() + &quot;, &quot; + stu.getAge()); &#125; &#125;&#125; 1.5 查找用户的索引需求： 1，main方法中定义一个集合，存入三个用户对象。 用户属性为：id，username，password 2，要求：定义一个方法，根据id查找对应的学生信息。 如果存在，返回索引 如果不存在，返回-1 代码示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class ArrayListDemo6 &#123; public static void main(String[] args) &#123; /*需求： 1，main方法中定义一个集合，存入三个用户对象。 用户属性为：id，username，password 2，要求：定义一个方法，根据id查找对应的学生信息。 如果存在，返回索引 如果不存在，返回-1*/ //1.创建集合对象 ArrayList&lt;User&gt; list = new ArrayList&lt;&gt;(); //2.创建用户对象 User u1 = new User(&quot;heima001&quot;, &quot;zhangsan&quot;, &quot;123456&quot;); User u2 = new User(&quot;heima002&quot;, &quot;lisi&quot;, &quot;1234&quot;); User u3 = new User(&quot;heima003&quot;, &quot;wangwu&quot;, &quot;1234qwer&quot;); //3.把用户对象添加到集合当中 list.add(u1); list.add(u2); list.add(u3); //4.调用方法，通过id获取对应的索引 int index = getIndex(list, &quot;heima001&quot;); System.out.println(index); &#125; //1.我要干嘛？ 根据id查找对应的学生信息 //2.我干这件事情需要什么才能完成？ 集合 id //3.方法的调用处是否需要继续使用方法的结果？ //要用必须返回，不要用可以返回也可以不返回 //明确说明需要有返回值 int public static int getIndex(ArrayList&lt;User&gt; list, String id) &#123; //遍历集合得到每一个元素 for (int i = 0; i &lt; list.size(); i++) &#123; User u = list.get(i); String uid = u.getId(); if(uid.equals(id))&#123; return i; &#125; &#125; //因为只有当集合里面所有的元素都比较完了，才能断定id是不存在的。 return -1; &#125;&#125; 1.6 判断用户的是否存在123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class ArrayListDemo5 &#123; public static void main(String[] args) &#123; /* 需求： 1，main方法中定义一个集合，存入三个用户对象。 用户属性为：id，username，password 2，要求：定义一个方法，根据id查找对应的学生信息。 如果存在，返回true 如果不存在，返回false*/ //1.定义集合 ArrayList&lt;User&gt; list = new ArrayList&lt;&gt;(); //2.创建对象 User u1 = new User(&quot;heima001&quot;,&quot;zhangsan&quot;,&quot;123456&quot;); User u2 = new User(&quot;heima002&quot;,&quot;lisi&quot;,&quot;12345678&quot;); User u3 = new User(&quot;heima003&quot;,&quot;wangwu&quot;,&quot;1234qwer&quot;); //3.把用户对象添加到集合当中 list.add(u1); list.add(u2); list.add(u3); //4.调用方法，查询id是否存在 boolean result = contains(list, &quot;heima001&quot;); System.out.println(result); &#125; //定义在测试类中的方法需要加static //1.我要干嘛？ 我要根据id查询学生是否存在 //2.我干这件事情，需要什么才能完成？ 集合 id //3.方法的调用处是否需要使用方法的结果？ //如果要用，必须返回，如果不用，可以返回也可以不返回 //但是本题明确说明需要返回 public static boolean contains(ArrayList&lt;User&gt; list, String id)&#123; //循环遍历集合，得到集合里面的每一个元素 //再进行判断 for (int i = 0; i &lt; list.size(); i++) &#123; //i 索引 list.get(i); 元素 User u = list.get(i); //判断id是否存在，我是拿着谁跟谁比较 //需要把用户对象里面的id拿出来再进行比较。 String uid = u.getId(); if(id.equals(uid))&#123; return true;//return 关键字：作用就是结束方法。 &#125; &#125; //只有当集合里面所有的元素全部比较完毕才能认为是不存在的。 return false; &#125;&#125; 2.学生管理系统2.1学生管理系统实现步骤 案例需求 ​\t针对目前我们的所学内容，完成一个综合案例：学生管理系统。该系统主要功能如下： ​\t添加学生：通过键盘录入学生信息，添加到集合中 ​\t删除学生：通过键盘录入要删除学生的学号，将该学生对象从集合中删除 ​\t修改学生：通过键盘录入要修改学生的学号，将该学生对象其他信息进行修改 ​\t查看学生：将集合中的学生对象信息进行展示 ​\t退出系统：结束程序 实现步骤 定义学生类，包含以下成员变量 ​ private String sid &#x2F;&#x2F; 学生id ​ private String name &#x2F;&#x2F; 学生姓名 ​ private String age &#x2F;&#x2F; 学生年龄 ​ private String address &#x2F;&#x2F; 学生所在地 学生管理系统主界面的搭建步骤 2.1 用输出语句完成主界面的编写2.2 用Scanner实现键盘输入2.3 用switch语句完成选择的功能2.4 用循环完成功能结束后再次回到主界面 学生管理系统的添加学生功能实现步骤 3.1 定义一个方法，接收ArrayList集合3.2 方法内完成添加学生的功能​ ①键盘录入学生信息​ ②根据录入的信息创建学生对象​ ③将学生对象添加到集合中​ ④提示添加成功信息3.3 在添加学生的选项里调用添加学生的方法 学生管理系统的查看学生功能实现步骤 4.1 定义一个方法，接收ArrayList集合4.2 方法内遍历集合，将学生信息进行输出4.3 在查看所有学生选项里调用查看学生方法 学生管理系统的删除学生功能实现步骤 5.1 定义一个方法，接收ArrayList集合5.2 方法中接收要删除学生的学号5.3 遍历集合，获取每个学生对象5.4 使用学生对象的学号和录入的要删除的学号进行比较,如果相同，则将当前学生对象从集合中删除5.5 在删除学生选项里调用删除学生的方法 学生管理系统的修改学生功能实现步骤 6.1 定义一个方法，接收ArrayList集合6.2 方法中接收要修改学生的学号6.3 通过键盘录入学生对象所需的信息，并创建对象6.4 遍历集合，获取每一个学生对象。并和录入的修改学生学号进行比较.如果相同，则使用新学生对象替换当前学生对象6.5 在修改学生选项里调用修改学生的方法 退出系统 使用System.exit(0);退出JVM 2.2学生类的定义1234567891011package com.itheima.studentsystem;public class Student &#123; private String id; private String name; private int age; private String address; //下面是空参，有参，get和set方法&#125; 2.3测试类的定义123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178public class StudentSystem &#123; public static void main(String[] args) &#123; ArrayList&lt;Student&gt; list = new ArrayList&lt;&gt;(); loop: while (true) &#123; System.out.println(&quot;-----------------欢迎来到黑马学生管理系统-------------------&quot;); System.out.println(&quot;1:添加学生&quot;); System.out.println(&quot;2:删除学生&quot;); System.out.println(&quot;3:修改学生&quot;); System.out.println(&quot;4:查询学生&quot;); System.out.println(&quot;5:退出&quot;); System.out.println(&quot;请输入您的选择：&quot;); Scanner sc = new Scanner(System.in); String choose = sc.next(); switch (choose) &#123; case &quot;1&quot; -&gt; addStudent(list); case &quot;2&quot; -&gt; deleteStudent(list); case &quot;3&quot; -&gt; updateStudent(list); case &quot;4&quot; -&gt; queryStudent(list); case &quot;5&quot; -&gt; &#123; System.out.println(&quot;退出&quot;); //break loop; System.exit(0);//停止虚拟机运行 &#125; default -&gt; System.out.println(&quot;没有这个选项&quot;); &#125; &#125; &#125; //添加学生 public static void addStudent(ArrayList&lt;Student&gt; list) &#123; //利用空参构造先创建学生对象 Student s = new Student(); Scanner sc = new Scanner(System.in); String id = null; while (true) &#123; System.out.println(&quot;请输入学生的id&quot;); id = sc.next(); boolean flag = contains(list, id); if(flag)&#123; //表示id已经存在，需要重新录入 System.out.println(&quot;id已经存在，请重新录入&quot;); &#125;else&#123; //表示id不存在，表示可以使用 s.setId(id); break; &#125; &#125; System.out.println(&quot;请输入学生的姓名&quot;); String name = sc.next(); s.setName(name); System.out.println(&quot;请输入学生的年龄&quot;); int age = sc.nextInt(); s.setAge(age); System.out.println(&quot;请输入学生的家庭住址&quot;); String address = sc.next(); s.setAddress(address); //把学生对象添加到集合当中 list.add(s); //提示一下用户 System.out.println(&quot;学生信息添加成功&quot;); &#125; //删除学生 public static void deleteStudent(ArrayList&lt;Student&gt; list) &#123; Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入要删除的id&quot;); String id = sc.next(); //查询id在集合中的索引 int index = getIndex(list, id); //对index进行判断 //如果-1，就表示不存在，结束方法，回到初始菜单 if(index &gt;= 0)&#123; //如果大于等于0的，表示存在，直接删除 list.remove(index); System.out.println(&quot;id为：&quot; + id + &quot;的学生删除成功&quot;); &#125;else&#123; System.out.println(&quot;id不存在，删除失败&quot;); &#125; &#125; //修改学生 public static void updateStudent(ArrayList&lt;Student&gt; list) &#123; Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入要修改学生的id&quot;); String id = sc.next(); int index = getIndex(list, id); if(index == -1)&#123; System.out.println(&quot;要修改的id&quot; + id + &quot;不存在，请重新输入&quot;); return; &#125; //当代码执行到这里，表示什么？表示当前id是存在的。 //获取要修改的学生对象 Student stu = list.get(index); //输入其他的信息并修改 System.out.println(&quot;请输入要修改的学生姓名&quot;); String newName = sc.next(); stu.setName(newName); System.out.println(&quot;请输入要修改的学生年龄&quot;); int newAge = sc.nextInt(); stu.setAge(newAge); System.out.println(&quot;请输入要修改的学生家庭住址&quot;); String newAddress = sc.next(); stu.setAddress(newAddress); System.out.println(&quot;学生信息修改成功&quot;); &#125; //查询学生 public static void queryStudent(ArrayList&lt;Student&gt; list) &#123; if (list.size() == 0) &#123; System.out.println(&quot;当前无学生信息，请添加后再查询&quot;); //结束方法 return; &#125; //打印表头信息 System.out.println(&quot;id\\t\\t姓名\\t年龄\\t家庭住址&quot;); //当代码执行到这里，表示集合中是有数据的 for (int i = 0; i &lt; list.size(); i++) &#123; Student stu = list.get(i); System.out.println(stu.getId() + &quot;\\t&quot; + stu.getName() + &quot;\\t&quot; + stu.getAge() + &quot;\\t&quot; + stu.getAddress()); &#125; &#125; //判断id在集合中是否存在 public static boolean contains(ArrayList&lt;Student&gt; list, String id) &#123; //循环遍历集合得到里面的每一个学生对象 /*for (int i = 0; i &lt; list.size(); i++) &#123; //拿到学生对象后，获取id并进行判断 Student stu = list.get(i); String sid = stu.getId(); if(sid.equals(id))&#123; //存在，true return true; &#125; &#125; // 不存在false return false;*/ return getIndex(list,id) &gt;= 0; &#125; //通过id获取索引的方法 public static int getIndex(ArrayList&lt;Student&gt; list, String id)&#123; //遍历集合 for (int i = 0; i &lt; list.size(); i++) &#123; //得到每一个学生对象 Student stu = list.get(i); //得到每一个学生对象的id String sid = stu.getId(); //拿着集合中的学生id跟要查询的id进行比较 if(sid.equals(id))&#123; //如果一样，那么就返回索引 return i; &#125; &#125; //当循环结束之后还没有找到，就表示不存在，返回-1. return -1; &#125;&#125;"},{"title":"常用API","path":"/posts/3822765128/","content":"1.API1.1API概述 什么是API ​\tAPI (Application Programming Interface) ：应用程序编程接口 java中的API ​\t指的就是 JDK 中提供的各种功能的 Java类，这些类将底层的实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可，我们可以通过帮助文档来学习这些API如何使用。 1.2如何使用API帮助文档 打开帮助文档 找到索引选项卡中的输入框 在输入框中输入Random 看类在哪个包下 看类的描述 看构造方法 看成员方法 2.String类2.1String类概述​\tString 类代表字符串，Java 程序中的所有字符串文字（例如“abc”）都被实现为此类的实例。也就是说，Java 程序中所有的双引号字符串，都是 String 类的对象。String 类在 java.lang 包下，所以使用的时候不需要导包！ 2.2String类的特点 字符串不可变，它们的值在创建后不能被更改 虽然 String 的值是不可变的，但是它们可以被共享 字符串效果上相当于字符数组( char[] )，但是底层原理是字节数组( byte[] ) 2.3String类的构造方法 常用的构造方法 方法名 说明 public String() 创建一个空白字符串对象，不含有任何内容 public String(char[] chs) 根据字符数组的内容，来创建字符串对象 public String(byte[] bys) 根据字节数组的内容，来创建字符串对象 String s &#x3D; “abc”; 直接赋值的方式创建字符串对象，内容就是abc 示例代码 123456789101112131415161718192021public class StringDemo01 &#123; public static void main(String[] args) &#123; //public String()：创建一个空白字符串对象，不含有任何内容 String s1 = new String(); System.out.println(&quot;s1:&quot; + s1); //public String(char[] chs)：根据字符数组的内容，来创建字符串对象 char[] chs = &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125;; String s2 = new String(chs); System.out.println(&quot;s2:&quot; + s2); //public String(byte[] bys)：根据字节数组的内容，来创建字符串对象 byte[] bys = &#123;97, 98, 99&#125;; String s3 = new String(bys); System.out.println(&quot;s3:&quot; + s3); //String s = “abc”;\t直接赋值的方式创建字符串对象，内容就是abc String s4 = &quot;abc&quot;; System.out.println(&quot;s4:&quot; + s4); &#125;&#125; 2.4创建字符串对象两种方式的区别 通过构造方法创建 ​\t通过 new 创建的字符串对象，每一次 new 都会申请一个内存空间，虽然内容相同，但是地址值不同 直接赋值方式创建 ​\t以“”方式给出的字符串，只要字符序列相同(顺序和大小写)，无论在程序代码中出现几次，JVM 都只会建立一个 String 对象，并在字符串池中维护 2.5字符串的比较2.5.1&#x3D;&#x3D;号的作用 比较基本数据类型：比较的是具体的值 比较引用数据类型：比较的是对象地址值 2.5.2equals方法的作用 方法介绍 1public boolean equals(String s) 比较两个字符串内容是否相同、区分大小写 示例代码 1234567891011121314151617181920212223public class StringDemo02 &#123; public static void main(String[] args) &#123; //构造方法的方式得到对象 char[] chs = &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125;; String s1 = new String(chs); String s2 = new String(chs); //直接赋值的方式得到对象 String s3 = &quot;abc&quot;; String s4 = &quot;abc&quot;; //比较字符串对象地址是否相同 System.out.println(s1 == s2); System.out.println(s1 == s3); System.out.println(s3 == s4); System.out.println(&quot;--------&quot;); //比较字符串内容是否相同 System.out.println(s1.equals(s2)); System.out.println(s1.equals(s3)); System.out.println(s3.equals(s4)); &#125;&#125; 2.6用户登录案例2.6.1案例需求​\t已知用户名和密码，请用程序实现模拟用户登录。总共给三次机会，登录之后，给出相应的提示 2.6.2代码实现1234567891011121314151617181920212223242526272829303132333435public class Test1登录案例 &#123; public static void main(String[] args) &#123; //1.定义两个变量用来记录正确的用户名和密码 String rightUsername = &quot;itheima&quot;; String rightPassword = &quot;1234qwer&quot;; //2.键盘录入用户名和密码 //ctrl + alt + T 选择包裹方式 for (int i = 0; i &lt; 3; i++) &#123;//0 1 2 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入用户名&quot;); String username = sc.next(); System.out.println(&quot;请输入密码&quot;); String password = sc.next(); //3.判断比较 if (username.equals(rightUsername) &amp;&amp; password.equals(rightPassword)) &#123; System.out.println(&quot;登录成功&quot;); //如果正确，循环结束 break; &#125; else &#123; //最后一次机会 if(i == 2)&#123; System.out.println(&quot;账户&quot; + username + &quot;被锁定，请联系黑马程序员官方小姐姐：XXXXXXX&quot;); &#125;else&#123; //不是最后一次机会 System.out.println(&quot;用户名或密码错误，登录失败,还剩下&quot; + (2 - i) + &quot;次机会&quot;);//2 1 0 &#125; &#125; &#125; &#125;&#125; 2.7遍历字符串案例2.7.1案例需求​\t键盘录入一个字符串，使用程序实现在控制台遍历该字符串 2.7.2直接遍历字符串1234567891011121314151617181920212223242526public class Test2字符串直接遍历 &#123; public static void main(String[] args) &#123; //两个方法： //charAt()：会根据索引获取对应的字符 //length(): 会返回字符串的长度 //1.键盘录入一个字符串 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入字符串&quot;); String str = sc.next(); System.out.println(str); //2.遍历 for (int i = 0; i &lt; str.length(); i++) &#123; //i 依次表示字符串的每一个索引 //索引的范围：0 ~ 长度-1 //根据索引获取字符串里面的每一个字符 //ctrl + alt + V 自动生成左边的接受变量 char c = str.charAt(i); System.out.println(c); &#125; &#125;&#125; 2.8统计字符次数案例2.8.1案例需求​\t键盘录入一个字符串，统计该字符串中大写字母字符，小写字母字符，数字字符出现的次数(不考虑其他字符) 2.8.2代码实现123456789101112131415161718192021222324252627282930313233343536373839public class Test4统计个数 &#123; public static void main(String[] args) &#123; //键盘录入一个字符串，统计大写，小写，数字出现的次数 //1.键盘录入一个字符串 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入一个字符串&quot;); String str = sc.next(); //2.统计 --- 计数器count //此时我要统计的有3样东西，所以要定义3个计数器分别进行统计 int bigCount = 0; int smallCount = 0; int numberCount = 0; //得到这个字符串里面每一个字符 for (int i = 0; i &lt; str.length(); i++) &#123; //i 表示字符串中的索引 //c 表示字符串中的每一个字符 char c = str.charAt(i); //对c进行判断 if (c &gt;= &#x27;a&#x27; &amp;&amp; c &lt;= &#x27;z&#x27;) &#123; smallCount++; &#125;else if(c &gt;= &#x27;A&#x27; &amp;&amp; c &lt;= &#x27;Z&#x27;)&#123; bigCount++; &#125;else if(c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;)&#123; numberCount++; &#125; &#125; //3.当循环结束之后，三个变量记录的就是对应的个数 System.out.println(&quot;大写字符有:&quot; + bigCount + &quot;个&quot;); System.out.println(&quot;小写字符有:&quot; + smallCount + &quot;个&quot;); System.out.println(&quot;数字字符有:&quot; + numberCount + &quot;个&quot;); &#125;&#125; 2.9字符串拼接案例2.9.1案例需求​\t定义一个方法，把 int 数组中的数据按照指定的格式拼接成一个字符串返回，调用该方法， ​\t并在控制台输出结果。例如，数组为 int[] arr &#x3D; {1,2,3}; ，执行方法后的输出结果为：[1, 2, 3] 2.9.2代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class Test5数组拼接成字符串 &#123; public static void main(String[] args) &#123; //定义一个方法，把 int 数组中的数据按照指定的格式拼接成一个字符串返回，调用该方法， //并在控制台输出结果。例如，数组为 int[] arr = &#123;1,2,3&#125;; //执行方法后的输出结果为：[1, 2, 3] int[] arr = &#123;1, 2, 3, 4, 5&#125;; String str = arrToString(arr); System.out.println(str); &#125; //作用：把一个数组变成字符串 public static String arrToString(int[] arr) &#123; String s = &quot;&quot;; //拼接左括号 s = s + &quot;[&quot;; //此时是拿着长度为0的字符串，跟[进行拼接，产生一个新的字符串。 //把新的字符串再赋值给s，此时变量s记录的就是新的字符串&quot;[&quot;的地址值 //下面我想得到数组里面的每一个元素并进行拼接 //那么就需要遍历数组，得到每一个元素才行 for (int i = 0; i &lt; arr.length; i++) &#123; //假设第一次循环:i = 0 获取的就是0索引上的元素 //在拼接的时候：&quot;[&quot; + 1 + &quot;, &quot; 拼接完毕之后产生一个新的字符串 &quot;[1, &quot; //第二次循环：i = 1 获取的就是1索引上的元素 //在拼接的时候： 此时s就是第一次循环结束后拼接完毕的结果：&quot;[1, &quot; //在拼接的时候：&quot;[1, &quot; + 2 + &quot;, &quot; 拼接完毕之后产生一个新的字符串 &quot;[1, 2, &quot; //... if(i == arr.length - 1)&#123; //如果是最后一个元素，那么不需要拼接逗号空格 s = s + arr[i]; &#125;else&#123; //如果不是最后一个元素，需要拼接元素和逗号空格 s = s + arr[i] + &quot;, &quot;; &#125; &#125; //等循环结束之后，再拼接最后一个右括号 s = s + &quot;]&quot;; return s; &#125; //用来遍历数组 public static void printArr(int[] arr) &#123; System.out.print(&quot;[&quot;); for (int i = 0; i &lt; arr.length; i++) &#123; if (i == arr.length - 1) &#123; System.out.print(arr[i]); &#125; else &#123; System.out.print(arr[i] + &quot;, &quot;); &#125; &#125; System.out.println(&quot;]&quot;); //[1, 2, 3, 4, 5] //我们现在要知道，这个最终结果是怎么来的？ //从到右依次打印得来的。 &#125;&#125; 2.10字符串反转案例2.10.1案例需求​\t定义一个方法，实现字符串反转。键盘录入一个字符串，调用该方法后，在控制台输出结果 ​\t例如，键盘录入 abc，输出结果 cba 2.10.2代码实现1234567891011121314151617181920212223242526272829303132333435363738public class Test6反转字符串 &#123; public static void main(String[] args) &#123; /*定义一个方法，实现字符串反转。键盘录入一个字符串，调用该方法后，在控制台输出结果 例如，键盘录入 abc，输出结果 cba*/ //1.定义一个字符串 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入一个字符串&quot;); String str = sc.next(); //2.定义一个方法，反转字符串 //abc ---&gt; cba //可以把字符串倒着遍历，再拼接 String result = reverse(str); System.out.println(result); &#125; //注释：方法的作用就是反转字符串 //把传递进来的字符串进行反转 public static String reverse(String str)&#123;//abc //核心思想：倒着遍历并进行拼接就可以了 //fori :正着遍历 forr：倒着遍历 String s = &quot;&quot;; for (int i = str.length() - 1; i &gt;= 0; i--) &#123; //i 依次表示字符串里面的每一个索引（倒着的） //我们就可以拿到里面的每一个字符并拼接 s = s + str.charAt(i); &#125; //把倒着拼接之后的结果返回即可 return s; &#125;&#125; 2.11 金额转换2.11.1 案例需求​\t把2135变成：零佰零拾零万贰仟壹佰叁拾伍元 ​\t把789变成：零佰零拾零万零仟柒佰捌拾玖元 2.11.2 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.itheima.stringdemo;import java.util.Scanner;public class StringDemo9 &#123; public static void main(String[] args) &#123; //1.键盘录入一个金额 Scanner sc = new Scanner(System.in); int money; while (true) &#123; System.out.println(&quot;请录入一个金额&quot;); money = sc.nextInt(); if (money &gt;= 0 &amp;&amp; money &lt;= 9999999) &#123; break; &#125; else &#123; System.out.println(&quot;金额无效&quot;); &#125; &#125; //定义一个变量用来表示钱的大写 String moneyStr = &quot;&quot;; //2.得到money里面的每一位数字,再转成中文 while (true) &#123;//2135 //从右往左获取数据，因为右侧是数据的个位 int ge = money % 10; String capitalNumber = getCapitalNumber(ge); //把转换之后的大写拼接到moneyStr当中 moneyStr = capitalNumber + moneyStr; //第一次循环 ： &quot;伍&quot; + &quot;&quot; = &quot;伍&quot; //第二次循环 ： &quot;叁&quot; + &quot;伍&quot; = &quot;叁伍&quot; //去掉刚刚获取的数据 money = money / 10; //如果数字上的每一位全部获取到了，那么money记录的就是0，此时循环结束 if (money == 0) &#123; break; &#125; &#125; //3.在前面补0，补齐7位 int count = 7 - moneyStr.length(); for (int i = 0; i &lt; count; i++) &#123; moneyStr = &quot;零&quot; + moneyStr; &#125; System.out.println(moneyStr);//零零零贰壹叁伍 //4.插入单位 //定义一个数组表示单位 String[] arr = &#123;&quot;佰&quot;,&quot;拾&quot;,&quot;万&quot;,&quot;仟&quot;,&quot;佰&quot;,&quot;拾&quot;,&quot;元&quot;&#125;; // 零 零 零 贰 壹 叁 伍 //遍历moneyStr，依次得到 零 零 零 贰 壹 叁 伍 //然后把arr的单位插入进去 String result = &quot;&quot;; for (int i = 0; i &lt; moneyStr.length(); i++) &#123; char c = moneyStr.charAt(i); //把大写数字和单位拼接到result当中 result = result + c + arr[i]; &#125; //5.打印最终结果 System.out.println(result); &#125; //定义一个方法把数字变成大写的中文 //1 -- 壹 public static String getCapitalNumber(int number) &#123; //定义数组，让数字跟大写的中文产生一个对应关系 String[] arr = &#123;&quot;零&quot;, &quot;壹&quot;, &quot;贰&quot;, &quot;叁&quot;, &quot;肆&quot;, &quot;伍&quot;, &quot;陆&quot;, &quot;柒&quot;, &quot;捌&quot;, &quot;玖&quot;&#125;; //返回结果 return arr[number]; &#125;&#125; 2.12 手机号屏蔽需求：以字符串的形式从键盘接受一个手机号，将中间四位号码屏蔽 最终效果为：131****9468 代码实现： 1234567891011121314151617181920212223242526public class Test8手机号屏蔽 &#123; public static void main(String[] args) &#123; /*以字符串的形式从键盘接受一个手机号，将中间四位号码屏蔽 最终效果为：131****9468*/ //1.键盘录入一个手机号码 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入手机号码&quot;); String phoneNumber = sc.next();//13112349408 //2.截取手机号码中的前三位 String star = phoneNumber.substring(0, 3); //3.截取手机号码中的最后四位 //此时我用substring方法，是用1个参数的，还是两个参数的？1个参数的会更好 //因为现在我要截取到最后，所以建议使用1个参数的。 String end = phoneNumber.substring(7); //4.拼接 String result = star + &quot;****&quot; + end; System.out.println(result); &#125;&#125; 2.13 敏感词替换需求1：键盘录入一个 字符串，如果字符串中包含（TMD），则使用***替换 123456789101112131415public class Test9敏感词替换 &#123; public static void main(String[] args) &#123; //1.定义一个变量表示骂人的话 String talk = &quot;后裔你玩什么啊，TMD&quot;; //2.把这句话中的敏感词进行替换 String result = talk.replace(&quot;TMD&quot;, &quot;***&quot;); //3.打印 System.out.println(talk); System.out.println(result); &#125;&#125; 需求2：如果要替换的敏感词比较多怎么办？ 1234567891011121314151617181920212223242526public class Test10多个敏感词替换 &#123; public static void main(String[] args) &#123; //实际开发中，敏感词会有很多很多 //1.先键盘录入要说的话 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入要说的话&quot;); String talk = sc.next();//后裔你玩什么啊，TMD,GDX,ctmd,ZZ //2.定义一个数组用来存多个敏感词 String[] arr = &#123;&quot;TMD&quot;,&quot;GDX&quot;,&quot;ctmd&quot;,&quot;ZZ&quot;,&quot;lj&quot;,&quot;FW&quot;,&quot;nt&quot;&#125;; //3.把说的话中所有的敏感词都替换为*** for (int i = 0; i &lt; arr.length; i++) &#123; //i 索引 //arr[i] 元素 --- 敏感词 talk = talk.replace(arr[i],&quot;***&quot;); &#125; //4.打印结果 System.out.println(talk);//后裔你玩什么啊，***,***,***,*** &#125;&#125; 2.14 身份证信息查看​\t身份证的每一位都是有固定的含义： 1、2位：省份 3、4位：城市 5、6位：区县 7-14位：出生年、月、日 15、16位：所在地派出所 17位：性别（奇数男性，偶数女性） 18位：个人信息码（随机产生） 要求打印内容方式如下： ​\t人物信息为： ​\t出生年月日：XXXX年X月X日 ​\t性别为：男&#x2F;女 1234567891011121314151617181920212223242526272829303132333435363738package com.itheima.stringdemo;public class StringDemo11 &#123; public static void main(String[] args) &#123; //1.定义一个字符串记录身份证号码 String id = &quot;321281202001011234&quot;; //2.获取出生年月日 String year = id.substring(6, 10); String month = id.substring(10, 12); String day = id.substring(12, 14); System.out.println(&quot;人物信息为：&quot;); System.out.println(&quot;出生年月日:&quot; + year + &quot;年&quot; + month + &quot;月&quot; + day + &quot;日&quot;); //3.获取性别 char gender = id.charAt(16);//&#x27;3&#x27; ---&gt; 3 //利用ASCII码表进行转换 //&#x27;0&#x27; ---&gt; 48 //&#x27;1&#x27; ---&gt; 49 //&#x27;2&#x27; ---&gt; 50 //&#x27;3&#x27; ---&gt; 51 //&#x27;4&#x27; ---&gt; 52 //&#x27;5&#x27; ---&gt; 53 //&#x27;6&#x27; ---&gt; 54 //&#x27;7&#x27; ---&gt; 55 //&#x27;8&#x27; ---&gt; 56 //&#x27;9&#x27; ---&gt; 57 int num = gender - 48; if(num % 2 == 0)&#123; System.out.println(&quot;性别为:女&quot;); &#125;else&#123; System.out.println(&quot;性别为:男&quot;); &#125; &#125;&#125; 3.StringBuilderStringBuilder 可以看成是一个容器，创建之后里面的内容是可变的。 当我们在拼接字符串和反转字符串的时候会使用到 3.1 基本使用1234567891011121314151617181920212223242526public class StringBuilderDemo3 &#123; public static void main(String[] args) &#123; //1.创建对象 StringBuilder sb = new StringBuilder(&quot;abc&quot;); //2.添加元素 /*sb.append(1); sb.append(2.3); sb.append(true);*/ //反转 sb.reverse(); //获取长度 int len = sb.length(); System.out.println(len); //打印 //普及： //因为StringBuilder是Java已经写好的类 //java在底层对他做了一些特殊处理。 //打印对象不是地址值而是属性值。 System.out.println(sb); &#125;&#125; 3.2 链式编程12345678910111213141516public class StringBuilderDemo4 &#123; public static void main(String[] args) &#123; //1.创建对象 StringBuilder sb = new StringBuilder(); //2.添加字符串 sb.append(&quot;aaa&quot;).append(&quot;bbb&quot;).append(&quot;ccc&quot;).append(&quot;ddd&quot;); System.out.println(sb);//aaabbbcccddd //3.再把StringBuilder变回字符串 String str = sb.toString(); System.out.println(str);//aaabbbcccddd &#125;&#125; 3.3 练习1：对称字符串需求： ​\t键盘接受一个字符串，程序判断出该字符串是否是对称字符串，并在控制台打印是或不是 对称字符串：123321、111 非对称字符串：123123 代码示例： 123456789101112131415161718192021222324public class StringBuilderDemo6 &#123; //使用StringBuilder的场景： //1.字符串的拼接 //2.字符串的反转 public static void main(String[] args) &#123; //1.键盘录入一个字符串 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入一个字符串&quot;); String str = sc.next(); //2.反转键盘录入的字符串 String result = new StringBuilder().append(str).reverse().toString(); //3.比较 if(str.equals(result))&#123; System.out.println(&quot;当前字符串是对称字符串&quot;); &#125;else&#123; System.out.println(&quot;当前字符串不是对称字符串&quot;); &#125; &#125;&#125; 3.4 练习2：拼接字符串需求：定义一个方法，把 int 数组中的数据按照指定的格式拼接成一个字符串返回。 ​ 调用该方法，并在控制台输出结果。 ​ 例如：数组为int[] arr &#x3D; {1,2,3}; ​ 执行方法后的输出结果为：[1, 2, 3] 代码示例: 1234567891011121314151617181920212223242526272829303132package com.itheima.stringbuilderdemo;public class StringBuilderDemo7 &#123; public static void main(String[] args) &#123; //1.定义数组 int[] arr = &#123;1,2,3&#125;; //2.调用方法把数组变成字符串 String str = arrToString(arr); System.out.println(str); &#125; public static String arrToString(int[] arr)&#123; StringBuilder sb = new StringBuilder(); sb.append(&quot;[&quot;); for (int i = 0; i &lt; arr.length; i++) &#123; if(i == arr.length - 1)&#123; sb.append(arr[i]); &#125;else&#123; sb.append(arr[i]).append(&quot;, &quot;); &#125; &#125; sb.append(&quot;]&quot;); return sb.toString(); &#125;&#125; 4. StringJoiner StringJoiner跟StringBuilder一样，也可以看成是一个容器，创建之后里面的内容是可变的。 作用：提高字符串的操作效率，而且代码编写特别简洁，但是目前市场上很少有人用。 JDK8出现的 基本使用： 123456//1.创建一个对象，并指定中间的间隔符号StringJoiner sj = new StringJoiner(&quot;---&quot;);//2.添加元素sj.add(&quot;aaa&quot;).add(&quot;bbb&quot;).add(&quot;ccc&quot;);//3.打印结果System.out.println(sj);//aaa---bbb---ccc 12345678910//1.创建对象StringJoiner sj = new StringJoiner(&quot;, &quot;,&quot;[&quot;,&quot;]&quot;);//2.添加元素sj.add(&quot;aaa&quot;).add(&quot;bbb&quot;).add(&quot;ccc&quot;);int len = sj.length();System.out.println(len);//15//3.打印System.out.println(sj);//[aaa, bbb, ccc]String str = sj.toString();System.out.println(str);//[aaa, bbb, ccc] 关于字符串的小扩展： 字符串存储的内存原理 String s &#x3D; “abc”；直接赋值 特点： ​\t此时字符串abc是存在字符串常量池中的。 ​\t先检查字符串常量池中有没有字符串abc，如果有，不会创建新的，而是直接复用。如果没有abc，才会创建一个新的。 所以，直接赋值的方式，代码简单，而且节约内存。 new出来的字符串 看到new关键字，一定是在堆里面开辟了一个小空间。 String s1 &#x3D; new String（“abc”）； String s2 &#x3D; “abc”； s1记录的是new出来的，在堆里面的地址值。 s2是直接赋值的，所以记录的是字符串常量池中的地址值。 &#x3D;&#x3D;号比较的到底是什么？ 如果比较的是基本数据类型：比的是具体的数值是否相等。 如果比较的是引用数据类型：比的是地址值是否相等。 结论：&#x3D;&#x3D;只能用于比较基本数据类型。不能比较引用数据类型。"},{"title":"面向对象综合训练","path":"/posts/1189031682/","content":"练习一：文字版格斗游戏需求: ​\t格斗游戏，每个游戏角色的姓名，血量，都不相同，在选定人物的时候（new对象的时候），这些信息就应该被确定下来。 举例： ​\t程序运行之后结果为： ​\t姓名为:乔峰 血量为:100 ​\t姓名为:鸠摩智\t血量为:100 ​\t乔峰举起拳头打了鸠摩智一下，造成了XX点伤害，鸠摩智还剩下XXX点血。 ​\t鸠摩智举起拳头打了鸠摩智一下，造成了XX点伤害，乔峰还剩下XXX点血。 ​\t乔峰举起拳头打了鸠摩智一下，造成了XX点伤害，鸠摩智还剩下XXX点血。 ​\t鸠摩智举起拳头打了鸠摩智一下，造成了XX点伤害，乔峰还剩下XXX点血。 ​\t乔峰K.O.了鸠摩智 代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class GameTest &#123; public static void main(String[] args) &#123; //1.创建第一个角色 Role r1 = new Role(&quot;乔峰&quot;,100); //2.创建第二个角色 Role r2 = new Role(&quot;鸠摩智&quot;,100); //3.开始格斗 回合制游戏 while(true)&#123; //r1开始攻击r2 r1.attack(r2); //判断r2的剩余血量 if(r2.getBlood() == 0)&#123; System.out.println(r1.getName() + &quot; K.O了&quot; + r2.getName()); break; &#125; //r2开始攻击r1 r2.attack(r1); if(r1.getBlood() == 0)&#123; System.out.println(r2.getName() + &quot; K.O了&quot; + r1.getName()); break; &#125; &#125; &#125;&#125;public class Role &#123; private String name; private int blood; public Role() &#123; &#125; public Role(String name, int blood) &#123; this.name = name; this.blood = blood; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getBlood() &#123; return blood; &#125; public void setBlood(int blood) &#123; this.blood = blood; &#125; //定义一个方法用于攻击别人 //思考：谁攻击谁？ //Role r1 = new Role（）； //Role r2 = new Role（）； //r1.攻击(r2); //方法的调用者去攻击参数 public void attack(Role role) &#123; //计算造成的伤害 1 ~ 20 Random r = new Random(); int hurt = r.nextInt(20) + 1; //剩余血量 int remainBoold = role.getBlood() - hurt; //对剩余血量做一个验证，如果为负数了，就修改为0 remainBoold = remainBoold &lt; 0 ? 0 : remainBoold; //修改一下挨揍的人的血量 role.setBlood(remainBoold); //this表示方法的调用者 System.out.println(this.getName() + &quot;举起拳头，打了&quot; + role.getName() + &quot;一下，&quot; + &quot;造成了&quot; + hurt + &quot;点伤害，&quot; + role.getName() + &quot;还剩下了&quot; + remainBoold + &quot;点血&quot;); &#125;&#125; 练习二：文字版格斗游戏进阶​\t在上一个的基础上，我想看到人物的性别和长相，打斗的时候我想看到武功招式。 举例： ​\t程序运行之后结果为： ​\t姓名为:乔峰 血量为:100\t性别为:男\t长相为:气宇轩昂 ​\t姓名为:鸠摩智\t血量为:100\t性别为:男\t长相为:气宇轩昂 ​\t乔峰使出了一招【背心钉】，转到对方的身后，一掌向鸠摩智背心的灵台穴拍去。给鸠摩智造成一处瘀伤。 ​\t鸠摩智使出了一招【游空探爪】，飞起身形自半空中变掌为抓锁向乔峰。结果乔峰退了半步，毫发无损。 ​\t。。。。 ​\t乔峰K.O.了鸠摩智 分析： ​\t长相是提前定义好的，提前放在一个数组当中，程序运行之后，从数组中随机获取。 1234//男生长相数组String[] boyfaces = &#123;&quot;风流俊雅&quot;, &quot;气宇轩昂&quot;, &quot;相貌英俊&quot;, &quot;五官端正&quot;, &quot;相貌平平&quot;, &quot;一塌糊涂&quot;, &quot;面目狰狞&quot;&#125;;//女生长相数组String[] girlfaces = &#123;&quot;美奂绝伦&quot;, &quot;沉鱼落雁&quot;, &quot;婷婷玉立&quot;, &quot;身材娇好&quot;, &quot;相貌平平&quot;, &quot;相貌简陋&quot;, &quot;惨不忍睹&quot;&#125;; ​\t武功招式也是提前定义好的，提前放在一个数组当中，程序运行之后，从数组随机获取 12345678//attack 攻击描述：String[] attacks_desc = &#123; &quot;%s使出了一招【背心钉】，转到对方的身后，一掌向%s背心的灵台穴拍去。&quot;, &quot;%s使出了一招【游空探爪】，飞起身形自半空中变掌为抓锁向%s。&quot;, &quot;%s大喝一声，身形下伏，一招【劈雷坠地】，捶向%s双腿。&quot;, &quot;%s运气于掌，一瞬间掌心变得血红，一式【掌心雷】，推向%s。&quot;, &quot;%s阴手翻起阳手跟进，一招【没遮拦】，结结实实的捶向%s。&quot;, &quot;%s上步抢身，招中套招，一招【劈挂连环】，连环攻向%s。&quot; ​\t受伤的提前也是提前定义好的，只不过不是随机了，根据剩余血量获取不同的描述 12345678910//injured 受伤描述：String[] injureds_desc = &#123; &quot;结果%s退了半步，毫发无损&quot;, &quot;结果给%s造成一处瘀伤&quot;, &quot;结果一击命中，%s痛得弯下腰&quot;, &quot;结果%s痛苦地闷哼了一声，显然受了点内伤&quot;, &quot;结果%s摇摇晃晃，一跤摔倒在地&quot;, &quot;结果%s脸色一下变得惨白，连退了好几步&quot;, &quot;结果『轰』的一声，%s口中鲜血狂喷而出&quot;, &quot;结果%s一声惨叫，像滩软泥般塌了下去&quot; ​\t其中输出语句跟以前不一样了，用的是System.out.printf（）；该输出语句支持%s占位符 1234567891011public class Test &#123; public static void main(String[] args) &#123; //两部分参数： //第一部分参数：要输出的内容%s（占位） //第二部分参数：填充的数据 System.out.printf(&quot;你好啊%s&quot;,&quot;张三&quot;);//用张三填充第一个%s System.out.println();//换行 System.out.printf(&quot;%s你好啊%s&quot;,&quot;张三&quot;,&quot;李四&quot;);//用张三填充第一个%s，李四填充第二个%s &#125;&#125; 最终代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196package com.itheima.test2;import java.util.Random;public class Role &#123; private String name; private int blood; private char gender; private String face;//长相是随机的 String[] boyfaces = &#123;&quot;风流俊雅&quot;, &quot;气宇轩昂&quot;, &quot;相貌英俊&quot;, &quot;五官端正&quot;, &quot;相貌平平&quot;, &quot;一塌糊涂&quot;, &quot;面目狰狞&quot;&#125;; String[] girlfaces = &#123;&quot;美奂绝伦&quot;, &quot;沉鱼落雁&quot;, &quot;婷婷玉立&quot;, &quot;身材娇好&quot;, &quot;相貌平平&quot;, &quot;相貌简陋&quot;, &quot;惨不忍睹&quot;&#125;; //attack 攻击描述： String[] attacks_desc = &#123; &quot;%s使出了一招【背心钉】，转到对方的身后，一掌向%s背心的灵台穴拍去。&quot;, &quot;%s使出了一招【游空探爪】，飞起身形自半空中变掌为抓锁向%s。&quot;, &quot;%s大喝一声，身形下伏，一招【劈雷坠地】，捶向%s双腿。&quot;, &quot;%s运气于掌，一瞬间掌心变得血红，一式【掌心雷】，推向%s。&quot;, &quot;%s阴手翻起阳手跟进，一招【没遮拦】，结结实实的捶向%s。&quot;, &quot;%s上步抢身，招中套招，一招【劈挂连环】，连环攻向%s。&quot; &#125;; //injured 受伤描述： String[] injureds_desc = &#123; &quot;结果%s退了半步，毫发无损&quot;, &quot;结果给%s造成一处瘀伤&quot;, &quot;结果一击命中，%s痛得弯下腰&quot;, &quot;结果%s痛苦地闷哼了一声，显然受了点内伤&quot;, &quot;结果%s摇摇晃晃，一跤摔倒在地&quot;, &quot;结果%s脸色一下变得惨白，连退了好几步&quot;, &quot;结果『轰』的一声，%s口中鲜血狂喷而出&quot;, &quot;结果%s一声惨叫，像滩软泥般塌了下去&quot; &#125;; public Role() &#123; &#125; public Role(String name, int blood, char gender) &#123; this.name = name; this.blood = blood; this.gender = gender; //随机长相 setFace(gender); &#125; public char getGender() &#123; return gender; &#125; public void setGender(char gender) &#123; this.gender = gender; &#125; public String getFace() &#123; return face; &#125; public void setFace(char gender) &#123; Random r = new Random(); //长相是随机的 if (gender == &#x27;男&#x27;) &#123; //从boyfaces里面随机长相 int index = r.nextInt(boyfaces.length); this.face = boyfaces[index]; &#125; else if (gender == &#x27;女&#x27;) &#123; //从girlfaces里面随机长相 int index = r.nextInt(girlfaces.length); this.face = girlfaces[index]; &#125; else &#123; this.face = &quot;面目狰狞&quot;; &#125; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getBlood() &#123; return blood; &#125; public void setBlood(int blood) &#123; this.blood = blood; &#125; //定义一个方法用于攻击别人 //思考：谁攻击谁？ //Role r1 = new Role（）； //Role r2 = new Role（）； //r1.攻击(r2); //方法的调用者去攻击参数 public void attack(Role role) &#123; Random r = new Random(); int index = r.nextInt(attacks_desc.length); String KungFu = attacks_desc[index]; //输出一个攻击的效果 System.out.printf(KungFu, this.getName(), role.getName()); System.out.println(); //计算造成的伤害 1 ~ 20 int hurt = r.nextInt(20) + 1; //剩余血量 int remainBoold = role.getBlood() - hurt; //对剩余血量做一个验证，如果为负数了，就修改为0 remainBoold = remainBoold &lt; 0 ? 0 : remainBoold; //修改一下挨揍的人的血量 role.setBlood(remainBoold); //受伤的描述 //血量&gt; 90 0索引的描述 //80 ~ 90 1索引的描述 //70 ~ 80 2索引的描述 //60 ~ 70 3索引的描述 //40 ~ 60 4索引的描述 //20 ~ 40 5索引的描述 //10 ~ 20 6索引的描述 //小于10的 7索引的描述 if (remainBoold &gt; 90) &#123; System.out.printf(injureds_desc[0], role.getName()); &#125;else if(remainBoold &gt; 80 &amp;&amp; remainBoold &lt;= 90)&#123; System.out.printf(injureds_desc[1], role.getName()); &#125;else if(remainBoold &gt; 70 &amp;&amp; remainBoold &lt;= 80)&#123; System.out.printf(injureds_desc[2], role.getName()); &#125;else if(remainBoold &gt; 60 &amp;&amp; remainBoold &lt;= 70)&#123; System.out.printf(injureds_desc[3], role.getName()); &#125;else if(remainBoold &gt; 40 &amp;&amp; remainBoold &lt;= 60)&#123; System.out.printf(injureds_desc[4], role.getName()); &#125;else if(remainBoold &gt; 20 &amp;&amp; remainBoold &lt;= 40)&#123; System.out.printf(injureds_desc[5], role.getName()); &#125;else if(remainBoold &gt; 10 &amp;&amp; remainBoold &lt;= 20)&#123; System.out.printf(injureds_desc[6], role.getName()); &#125;else&#123; System.out.printf(injureds_desc[7], role.getName()); &#125; System.out.println(); &#125; public void showRoleInfo() &#123; System.out.println(&quot;姓名为：&quot; + getName()); System.out.println(&quot;血量为：&quot; + getBlood()); System.out.println(&quot;性别为：&quot; + getGender()); System.out.println(&quot;长相为：&quot; + getFace()); &#125;&#125;package com.itheima.test2;public class GameTest &#123; public static void main(String[] args) &#123; //1.创建第一个角色 Role r1 = new Role(&quot;乔峰&quot;,100,&#x27;男&#x27;); //2.创建第二个角色 Role r2 = new Role(&quot;鸠摩智&quot;,100,&#x27;男&#x27;); //展示一下角色的信息 r1.showRoleInfo(); r2.showRoleInfo(); //3.开始格斗 回合制游戏 while(true)&#123; //r1开始攻击r2 r1.attack(r2); //判断r2的剩余血量 if(r2.getBlood() == 0)&#123; System.out.println(r1.getName() + &quot; K.O了&quot; + r2.getName()); break; &#125; //r2开始攻击r1 r2.attack(r1); if(r1.getBlood() == 0)&#123; System.out.println(r2.getName() + &quot; K.O了&quot; + r1.getName()); break; &#125; &#125; &#125;&#125; 练习三：对象数组（商品）需求： ​\t定义数组存储3个商品对象。 ​\t商品的属性：商品的id，名字，价格，库存。 ​\t创建三个商品对象，并把商品对象存入到数组当中。 代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.itheima.test3;public class Goods &#123; private String id; private String name; private double price; private int count; public Goods() &#123; &#125; public Goods(String id, String name, double price, int count) &#123; this.id = id; this.name = name; this.price = price; this.count = count; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public double getPrice() &#123; return price; &#125; public void setPrice(double price) &#123; this.price = price; &#125; public int getCount() &#123; return count; &#125; public void setCount(int count) &#123; this.count = count; &#125;&#125;package com.itheima.test3;public class GoodsTest &#123; public static void main(String[] args) &#123; //1.创建一个数组 Goods[] arr = new Goods[3]; //2.创建三个商品对象 Goods g1 = new Goods(&quot;001&quot;,&quot;华为P40&quot;,5999.0,100); Goods g2 = new Goods(&quot;002&quot;,&quot;保温杯&quot;,227.0,50); Goods g3 = new Goods(&quot;003&quot;,&quot;枸杞&quot;,12.7,70); //3.把商品添加到数组中 arr[0] = g1; arr[1] = g2; arr[2] = g3; //4.遍历 for (int i = 0; i &lt; arr.length; i++) &#123; //i 索引 arr[i] 元素 Goods goods = arr[i]; System.out.println(goods.getId() + &quot;, &quot; + goods.getName() + &quot;, &quot; + goods.getPrice() + &quot;, &quot; + goods.getCount()); &#125; &#125;&#125; 练习四：对象数组（汽车）需求： ​\t定义数组存储3部汽车对象。 ​\t汽车的属性：品牌，价格，颜色。 ​\t创建三个汽车对象，数据通过键盘录入而来，并把数据存入到数组当中。 代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package com.itheima.test5;public class Car &#123; private String brand;//品牌 private int price;//价格 private String color;//颜色 public Car() &#123; &#125; public Car(String brand, int price, String color) &#123; this.brand = brand; this.price = price; this.color = color; &#125; public String getBrand() &#123; return brand; &#125; public void setBrand(String brand) &#123; this.brand = brand; &#125; public int getPrice() &#123; return price; &#125; public void setPrice(int price) &#123; this.price = price; &#125; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125;&#125;package com.itheima.test5;import java.util.Scanner;public class CarTest &#123; public static void main(String[] args) &#123; //1.创建一个数组用来存3个汽车对象 Car[] arr = new Car[3]; //2.创建汽车对象，数据来自于键盘录入 Scanner sc = new Scanner(System.in); for (int i = 0; i &lt; arr.length; i++) &#123; //创建汽车的对象 Car c = new Car(); //录入品牌 System.out.println(&quot;请输入汽车的品牌&quot;); String brand = sc.next(); c.setBrand(brand); //录入价格 System.out.println(&quot;请输入汽车的价格&quot;); int price = sc.nextInt(); c.setPrice(price); //录入颜色 System.out.println(&quot;请输入汽车的颜色&quot;); String color = sc.next(); c.setColor(color); //把汽车对象添加到数组当中 arr[i] = c; &#125; //3.遍历数组 for (int i = 0; i &lt; arr.length; i++) &#123; Car car = arr[i]; System.out.println(car.getBrand() + &quot;, &quot; + car.getPrice() + &quot;, &quot; + car.getColor()); &#125; &#125;&#125; 练习五：对象数组（手机）需求 : ​\t定义数组存储3部手机对象。 ​\t手机的属性：品牌，价格，颜色。 ​\t要求，计算出三部手机的平均价格 代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.itheima.test6;public class Phone &#123; private String brand;//品牌 private int price;//价格 private String color;//颜色 public Phone() &#123; &#125; public Phone(String brand, int price, String color) &#123; this.brand = brand; this.price = price; this.color = color; &#125; public String getBrand() &#123; return brand; &#125; public void setBrand(String brand) &#123; this.brand = brand; &#125; public int getPrice() &#123; return price; &#125; public void setPrice(int price) &#123; this.price = price; &#125; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125;&#125;package com.itheima.test6;import java.math.BigDecimal;public class PhoneTest &#123; public static void main(String[] args) &#123; //1.创建一个数组 Phone[] arr = new Phone[3]; //2.创建手机的对象 Phone p1 = new Phone(&quot;小米&quot;,1999,&quot;白色&quot;); Phone p2 = new Phone(&quot;华为&quot;,4999,&quot;蓝色&quot;); Phone p3 = new Phone(&quot;魅族&quot;,3999,&quot;红色&quot;); //3.把手机对象添加到数组当中 arr[0] = p1; arr[1] = p2; arr[2] = p3; //4.获取三部手机的平均价格 int sum = 0; for (int i = 0; i &lt; arr.length; i++) &#123; //i 索引 arr[i] 元素（手机对象） Phone phone = arr[i]; sum = sum + phone.getPrice(); &#125; //5.求平均值 //数据能不写死，尽量不写死 //int avg = sum / arr.length; double avg2 = sum * 1.0 / arr.length; System.out.println(avg2);//3665.6666666666665 &#125;&#125; 练习六：对象数组（女朋友）需求： ​\t定义数组存储4个女朋友的对象 ​\t女朋友的属性：姓名、年龄、性别、爱好 ​\t要求1：计算出四女朋友的平均年龄 ​\t要求2：统计年龄比平均值低的女朋友有几个？并把她们的所有信息打印出来。 代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package com.itheima.test7;public class GirlFriend &#123; private String name;//姓名 private int age;//年龄 private String gender;//性别 private String hobby;//爱好 public GirlFriend() &#123; &#125; public GirlFriend(String name, int age, String gender, String hobby) &#123; this.name = name; this.age = age; this.gender = gender; this.hobby = hobby; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public String getHobby() &#123; return hobby; &#125; public void setHobby(String hobby) &#123; this.hobby = hobby; &#125;&#125;package com.itheima.test7;public class GirlFriendTest &#123; public static void main(String[] args) &#123; //1.定义数组存入女朋友的对象 GirlFriend[] arr = new GirlFriend[4]; //2.创建女朋友对象 GirlFriend gf1 = new GirlFriend(&quot;小诗诗&quot;,18,&quot;萌妹子&quot;,&quot;吃零食&quot;); GirlFriend gf2 = new GirlFriend(&quot;小丹丹&quot;,19,&quot;萌妹子&quot;,&quot;玩游戏&quot;); GirlFriend gf3 = new GirlFriend(&quot;小惠惠&quot;,20,&quot;萌妹子&quot;,&quot;看书，学习&quot;); GirlFriend gf4 = new GirlFriend(&quot;小莉莉&quot;,21,&quot;憨妹子&quot;,&quot;睡觉&quot;); //3.把对象添加到数组当中 arr[0] = gf1; arr[1] = gf2; arr[2] = gf3; arr[3] = gf4; //4.求和 int sum = 0; for (int i = 0; i &lt; arr.length; i++) &#123; //i 索引 arr[i] 元素（女朋友对象） GirlFriend gf = arr[i]; //累加 sum = sum + gf.getAge(); &#125; //5.平均值 int avg = sum / arr.length; //6.统计年龄比平均值低的有几个，打印他们的信息 int count = 0; for (int i = 0; i &lt; arr.length; i++) &#123; GirlFriend gf = arr[i]; if(gf.getAge() &lt; avg)&#123; count++; System.out.println(gf.getName() + &quot;, &quot; + gf.getAge() + &quot;, &quot; + gf.getGender() + &quot;, &quot; + gf.getHobby()); &#125; &#125; System.out.println(count + &quot;个&quot;); &#125;&#125; 练习七：复杂的对象数组操作定义一个长度为3的数组，数组存储1~3名学生对象作为初始数据，学生对象的学号，姓名各不相同。 学生的属性：学号，姓名，年龄。 要求1：再次添加一个学生对象，并在添加的时候进行学号的唯一性判断。 要求2：添加完毕之后，遍历所有学生信息。 要求3：通过id删除学生信息 ​ 如果存在，则删除，如果不存在，则提示删除失败。 要求4：删除完毕之后，遍历所有学生信息。 要求5：查询数组id为“heima002”的学生，如果存在，则将他的年龄+1岁 代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940package com.itheima.test8;public class Student &#123; private int id; private String name; private int age; public Student() &#123; &#125; public Student(int id, String name, int age) &#123; this.id = id; this.name = name; this.age = age; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124public class Test &#123; public static void main(String[] args) &#123; /*定义一个长度为3的数组，数组存储1~3名学生对象作为初始数据，学生对象的学号，姓名各不相同。 学生的属性：学号，姓名，年龄。 要求1：再次添加一个学生对象，并在添加的时候进行学号的唯一性判断。 要求2：添加完毕之后，遍历所有学生信息。 */ //1.创建一个数组用来存储学生对象 Student[] arr = new Student[3]; //2.创建学生对象并添加到数组当中 Student stu1 = new Student(1, &quot;zhangsan&quot;, 23); Student stu2 = new Student(2, &quot;lisi&quot;, 24); //3.把学生对象添加到数组当中 arr[0] = stu1; arr[1] = stu2; //要求1：再次添加一个学生对象，并在添加的时候进行学号的唯一性判断。 Student stu4 = new Student(1, &quot;zhaoliu&quot;, 26); //唯一性判断 //已存在 --- 不用添加 //不存在 --- 就可以把学生对象添加进数组 boolean flag = contains(arr, stu4.getId()); if(flag)&#123; //已存在 --- 不用添加 System.out.println(&quot;当前id重复，请修改id后再进行添加&quot;); &#125;else&#123; //不存在 --- 就可以把学生对象添加进数组 //把stu4添加到数组当中 //1.数组已经存满 --- 只能创建一个新的数组，新数组的长度 = 老数组 + 1 //2.数组没有存满 --- 直接添加 int count = getCount(arr); if(count == arr.length)&#123; //已经存满 //创建一个新的数组，长度 = 老数组的长度 + 1 //然后把老数组的元素，拷贝到新数组当中 Student[] newArr = creatNewArr(arr); //把stu4添加进去 newArr[count] = stu4; //要求2：添加完毕之后，遍历所有学生信息。 printArr(newArr); &#125;else&#123; //没有存满 //[stu1,stu2,null] //getCount获取到的是2，表示数组当中已经有了2个元素 //还有一层意思：如果下一次要添加数据，就是添加到2索引的位置 arr[count] = stu4; //要求2：添加完毕之后，遍历所有学生信息。 printArr(arr); &#125; &#125; &#125; public static void printArr(Student[] arr)&#123; for (int i = 0; i &lt; arr.length; i++) &#123; Student stu = arr[i]; if(stu != null)&#123; System.out.println(stu.getId() + &quot;, &quot; + stu.getName() + &quot;, &quot; + stu.getAge()); &#125; &#125; &#125; //创建一个新的数组，长度 = 老数组的长度 + 1 //然后把老数组的元素，拷贝到新数组当中 public static Student[] creatNewArr(Student[] arr)&#123; Student[] newArr = new Student[arr.length + 1]; //循环遍历得到老数组中的每一个元素 for (int i = 0; i &lt; arr.length; i++) &#123; //把老数组中的元素添加到新数组当中 newArr[i] = arr[i]; &#125; //把新数组返回 return newArr; &#125; //定义一个方法判断数组中已经存了几个元素 public static int getCount(Student[] arr)&#123; //定义一个计数器用来统计 int count = 0; for (int i = 0; i &lt; arr.length; i++) &#123; if(arr[i] != null)&#123; count++; &#125; &#125; //当循环结束之后，我就知道了数组中一共有几个元素 return count; &#125; //1.我要干嘛？ 唯一性判断 //2.我干这件事情，需要什么才能完成？ 数组 id //3.调用处是否需要继续使用方法的结果？ 必须返回 public static boolean contains(Student[] arr, int id) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; //依次获取到数组里面的每一个学生对象 Student stu = arr[i]; if(stu != null)&#123; //获取数组中学生对象的id int sid = stu.getId(); //比较 if(sid == id)&#123; return true; &#125; &#125; &#125; //当循环结束之后，还没有找到一样的，那么就表示数组中要查找的id是不存在的。 return false; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package com.itheima.test8;public class Test3 &#123; public static void main(String[] args) &#123; /*定义一个长度为3的数组，数组存储1~3名学生对象作为初始数据，学生对象的学号，姓名各不相同。 学生的属性：学号，姓名，年龄。 要求3：通过id删除学生信息 如果存在，则删除，如果不存在，则提示删除失败。 要求4：删除完毕之后，遍历所有学生信息。 */ //1.创建一个数组用来存储学生对象 Student[] arr = new Student[3]; //2.创建学生对象并添加到数组当中 Student stu1 = new Student(1, &quot;zhangsan&quot;, 23); Student stu2 = new Student(2, &quot;lisi&quot;, 24); Student stu3 = new Student(3, &quot;wangwu&quot;, 25); //3.把学生对象添加到数组当中 arr[0] = stu1; arr[1] = stu2; arr[2] = stu3; /*要求3：通过id删除学生信息 如果存在，则删除，如果不存在，则提示删除失败。*/ //要找到id在数组中对应的索引 int index = getIndex(arr, 2); if (index &gt;= 0)&#123; //如果存在，则删除 arr[index] = null; //遍历数组 printArr(arr); &#125;else&#123; //如果不存在，则提示删除失败 System.out.println(&quot;当前id不存在，删除失败&quot;); &#125; &#125; //1.我要干嘛？ 找到id在数组中的索引 //2.我需要什么？ 数组 id //3.调用处是否需要继续使用方法的结果？ 要 public static int getIndex(Student[] arr , int id)&#123; for (int i = 0; i &lt; arr.length; i++) &#123; //依次得到每一个学生对象 Student stu = arr[i]; //对stu进行一个非空判断 if(stu != null)&#123; int sid = stu.getId(); if(sid == id)&#123; return i; &#125; &#125; &#125; //当循环结束之后，还没有找到就表示不存在 return -1; &#125; public static void printArr(Student[] arr)&#123; for (int i = 0; i &lt; arr.length; i++) &#123; Student stu = arr[i]; if(stu != null)&#123; System.out.println(stu.getId() + &quot;, &quot; + stu.getName() + &quot;, &quot; + stu.getAge()); &#125; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.itheima.test8;public class Test4 &#123; public static void main(String[] args) &#123; /*定义一个长度为3的数组，数组存储1~3名学生对象作为初始数据，学生对象的学号，姓名各不相同。 学生的属性：学号，姓名，年龄。 要求5：查询数组id为“2”的学生，如果存在，则将他的年龄+1岁*/ //1.创建一个数组用来存储学生对象 Student[] arr = new Student[3]; //2.创建学生对象并添加到数组当中 Student stu1 = new Student(1, &quot;zhangsan&quot;, 23); Student stu2 = new Student(2, &quot;lisi&quot;, 24); Student stu3 = new Student(3, &quot;wangwu&quot;, 25); //3.把学生对象添加到数组当中 arr[0] = stu1; arr[1] = stu2; arr[2] = stu3; //4.先要找到id为2的学生对于的索引 int index = getIndex(arr, 2); //5.判断索引 if(index &gt;= 0)&#123; //存在， 则将他的年龄+1岁 Student stu = arr[index]; //把原来的年龄拿出来 int newAge = stu.getAge() + 1; //把+1之后的年龄塞回去 stu.setAge(newAge); //遍历数组 printArr(arr); &#125;else&#123; //不存在，则直接提示 System.out.println(&quot;当前id不存在，修改失败&quot;); &#125; &#125; //1.我要干嘛？ 找到id在数组中的索引 //2.我需要什么？ 数组 id //3.调用处是否需要继续使用方法的结果？ 要 public static int getIndex(Student[] arr , int id)&#123; for (int i = 0; i &lt; arr.length; i++) &#123; //依次得到每一个学生对象 Student stu = arr[i]; //对stu进行一个非空判断 if(stu != null)&#123; int sid = stu.getId(); if(sid == id)&#123; return i; &#125; &#125; &#125; //当循环结束之后，还没有找到就表示不存在 return -1; &#125; public static void printArr(Student[] arr)&#123; for (int i = 0; i &lt; arr.length; i++) &#123; Student stu = arr[i]; if(stu != null)&#123; System.out.println(stu.getId() + &quot;, &quot; + stu.getName() + &quot;, &quot; + stu.getAge()); &#125; &#125; &#125;&#125;"},{"title":"面向对象","path":"/posts/673421965/","content":"1. 类和对象1.1 类和对象的理解客观存在的事物皆为对象 ，所以我们也常常说万物皆对象。 类 类的理解 类是对现实生活中一类具有共同属性和行为的事物的抽象 类是对象的数据类型，类是具有相同属性和行为的一组对象的集合 简单理解：类就是对现实事物的一种描述 类的组成 属性：指事物的特征，例如：手机事物（品牌，价格，尺寸） 行为：指事物能执行的操作，例如：手机事物（打电话，发短信） 类和对象的关系 类：类是对现实生活中一类具有共同属性和行为的事物的抽象 对象：是能够看得到摸的着的真实存在的实体 简单理解：类是对事物的一种描述，对象则为具体存在的事物 1.2 类的定义类的组成是由属性和行为两部分组成 属性：在类中通过成员变量来体现（类中方法外的变量） 行为：在类中通过成员方法来体现（和前面的方法相比去掉static关键字即可） 类的定义步骤： ①定义类 ②编写类的成员变量 ③编写类的成员方法 123456789public class 类名 &#123;\t// 成员变量\t变量1的数据类型 变量1；\t变量2的数据类型 变量2;\t…\t// 成员方法\t方法1;\t方法2;\t&#125; 示例代码： 12345678910111213141516171819202122232425262728/* 手机类： 类名： 手机(Phone) 成员变量： 品牌(brand) 价格(price) 成员方法： 打电话(call) 发短信(sendMessage) */public class Phone &#123; //成员变量 String brand; int price; //成员方法 public void call() &#123; System.out.println(&quot;打电话&quot;); &#125; public void sendMessage() &#123; System.out.println(&quot;发短信&quot;); &#125;&#125; 1.3 对象的使用 创建对象的格式： 类名 对象名 &#x3D; new 类名(); 调用成员的格式： 对象名.成员变量 对象名.成员方法(); 示例代码 123456789101112131415161718192021222324252627282930313233/* 创建对象 格式：类名 对象名 = new 类名(); 范例：Phone p = new Phone(); 使用对象 1：使用成员变量 格式：对象名.变量名 范例：p.brand 2：使用成员方法 格式：对象名.方法名() 范例：p.call() */public class PhoneDemo &#123; public static void main(String[] args) &#123; //创建对象 Phone p = new Phone(); //使用成员变量 System.out.println(p.brand); System.out.println(p.price); p.brand = &quot;小米&quot;; p.price = 2999; System.out.println(p.brand); System.out.println(p.price); //使用成员方法 p.call(); p.sendMessage(); &#125;&#125; 1.4 学生对象-练习 需求：首先定义一个学生类，然后定义一个学生测试类，在学生测试类中通过对象完成成员变量和成员方法的使用 分析： 成员变量：姓名，年龄… 成员方法：学习，做作业… 示例代码： 12345678910111213141516171819202122232425262728293031323334public class Student &#123; //成员变量 String name; int age; //成员方法 public void study() &#123; System.out.println(&quot;好好学习，天天向上&quot;); &#125; public void doHomework() &#123; System.out.println(&quot;键盘敲烂，月薪过万&quot;); &#125;&#125;/* 学生测试类 */public class StudentDemo &#123; public static void main(String[] args) &#123; //创建对象 Student s = new Student(); //使用对象 System.out.println(s.name + &quot;,&quot; + s.age); s.name = &quot;林青霞&quot;; s.age = 30; System.out.println(s.name + &quot;,&quot; + s.age); s.study(); s.doHomework(); &#125;&#125; 2. 对象内存图2.1 单个对象内存图 成员变量使用过程 成员方法调用过程 2.2 多个对象内存图 成员变量使用过程 成员方法调用过程 总结： 多个对象在堆内存中，都有不同的内存划分，成员变量存储在各自的内存区域中，成员方法多个对象共用的一份 3. 成员变量和局部变量3.1 成员变量和局部变量的区别 类中位置不同：成员变量（类中方法外）局部变量（方法内部或方法声明上） 内存中位置不同：成员变量（堆内存）局部变量（栈内存） 生命周期不同：成员变量（随着对象的存在而存在，随着对象的消失而消失）局部变量（随着方法的调用而存在，醉着方法的调用完毕而消失） 初始化值不同：成员变量（有默认初始化值）局部变量（没有默认初始化值，必须先定义，赋值才能使用） 4. 封装4.1 封装思想 封装概述是面向对象三大特征之一（封装，继承，多态） 对象代表什么，就得封装对应的数据，并提供数据对应的行为 封装代码实现将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问成员变量private，提供对应的getXxx()&#x2F;setXxx()方法 4.2 private关键字private是一个修饰符，可以用来修饰成员（成员变量，成员方法） 被private修饰的成员，只能在本类进行访问，针对private修饰的成员变量，如果需要被其他类使用，提供相应的操作 提供“get变量名()”方法，用于获取成员变量的值，方法用public修饰 提供“set变量名(参数)”方法，用于设置成员变量的值，方法用public修饰 示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940/* 学生类 */class Student &#123; //成员变量 String name; private int age; //提供get/set方法 public void setAge(int a) &#123; if(a&lt;0 || a&gt;120) &#123; System.out.println(&quot;你给的年龄有误&quot;); &#125; else &#123; age = a; &#125; &#125; public int getAge() &#123; return age; &#125; //成员方法 public void show() &#123; System.out.println(name + &quot;,&quot; + age); &#125;&#125;/* 学生测试类 */public class StudentDemo &#123; public static void main(String[] args) &#123; //创建对象 Student s = new Student(); //给成员变量赋值 s.name = &quot;林青霞&quot;; s.setAge(30); //调用show方法 s.show(); &#125;&#125; 4.3 private的使用 需求：定义标准的学生类，要求name和age使用private修饰，并提供set和get方法以及便于显示数据的show方法，测试类中创建对象并使用，最终控制台输出 林青霞，30 示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/* 学生类 */class Student &#123; //成员变量 private String name; private int age; //get/set方法 public void setName(String n) &#123; name = n; &#125; public String getName() &#123; return name; &#125; public void setAge(int a) &#123; age = a; &#125; public int getAge() &#123; return age; &#125; public void show() &#123; System.out.println(name + &quot;,&quot; + age); &#125;&#125;/* 学生测试类 */public class StudentDemo &#123; public static void main(String[] args) &#123; //创建对象 Student s = new Student(); //使用set方法给成员变量赋值 s.setName(&quot;林青霞&quot;); s.setAge(30); s.show(); //使用get方法获取成员变量的值 System.out.println(s.getName() + &quot;---&quot; + s.getAge()); System.out.println(s.getName() + &quot;,&quot; + s.getAge()); &#125;&#125; 4.4 this关键字 this修饰的变量用于指代成员变量，其主要作用是（区分局部变量和成员变量的重名问题） 方法的形参如果与成员变量同名，不带this修饰的变量指的是形参，而不是成员变量 方法的形参没有与成员变量同名，不带this修饰的变量指的是成员变量 123456789101112131415161718192021222324public class Student &#123; private String name; private int age; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getAge() &#123; return age; &#125; public void show() &#123; System.out.println(name + &quot;,&quot; + age); &#125;&#125; 5. 构造方法5.1 构造方法概述构造方法是一种特殊的方法 作用：创建对象 Student stu &#x3D; new Student(); 格式： public class 类名{ ​ 修饰符 类名( 参数 ) { ​ } } 功能：主要是完成对象数据的初始化 示例代码： 1234567891011121314151617181920212223class Student &#123; private String name; private int age; //构造方法 public Student() &#123; System.out.println(&quot;无参构造方法&quot;); &#125; public void show() &#123; System.out.println(name + &quot;,&quot; + age); &#125;&#125;/* 测试类 */public class StudentDemo &#123; public static void main(String[] args) &#123; //创建对象 Student s = new Student(); s.show(); &#125;&#125; 5.2 构造方法的注意事项 构造方法的创建 如果没有定义构造方法，系统将给出一个默认的无参数构造方法如果定义了构造方法，系统将不再提供默认的构造方法 构造方法的重载 如果自定义了带参构造方法，还要使用无参数构造方法，就必须再写一个无参数构造方法 推荐的使用方式 无论是否使用，都手工书写无参数构造方法 重要功能！ 可以使用带参构造，为成员变量进行初始化 示例代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* 学生类 */class Student &#123; private String name; private int age; public Student() &#123;&#125; public Student(String name) &#123; this.name = name; &#125; public Student(int age) &#123; this.age = age; &#125; public Student(String name,int age) &#123; this.name = name; this.age = age; &#125; public void show() &#123; System.out.println(name + &quot;,&quot; + age); &#125;&#125;/* 测试类 */public class StudentDemo &#123; public static void main(String[] args) &#123; //创建对象 Student s1 = new Student(); s1.show(); //public Student(String name) Student s2 = new Student(&quot;林青霞&quot;); s2.show(); //public Student(int age) Student s3 = new Student(30); s3.show(); //public Student(String name,int age) Student s4 = new Student(&quot;林青霞&quot;,30); s4.show(); &#125;&#125; 5.3 标准类制作① 类名需要见名知意 ② 成员变量使用private修饰 ③ 提供至少两个构造方法 无参构造方法 带全部参数的构造方法 ④ get和set方法 ​\t提供每一个成员变量对应的setXxx()&#x2F;getXxx() ⑤ 如果还有其他行为，也需要写上 5.4 练习1需求： ​\t定义标准学生类，要求分别使用空参和有参构造方法创建对象，空参创建的对象通过setXxx赋值，有参创建的对象直接赋值，并通过show方法展示数据。 示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Student &#123; //成员变量 private String name; private int age; //构造方法 public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; //成员方法 public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getAge() &#123; return age; &#125; public void show() &#123; System.out.println(name + &quot;,&quot; + age); &#125;&#125;/* 创建对象并为其成员变量赋值的两种方式 1:无参构造方法创建对象后使用setXxx()赋值 2:使用带参构造方法直接创建带有属性值的对象*/public class StudentDemo &#123; public static void main(String[] args) &#123; //无参构造方法创建对象后使用setXxx()赋值 Student s1 = new Student(); s1.setName(&quot;林青霞&quot;); s1.setAge(30); s1.show(); //使用带参构造方法直接创建带有属性值的对象 Student s2 = new Student(&quot;林青霞&quot;,30); s2.show(); &#125;&#125; 5.4 练习2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104public class User &#123; //1.私有化全部的成员变量 //2.空参构造 //3.带全部参数的构造 //4.针对于每一个私有化的成员变量都要提供其对应的get和set方法 //5.如果当前事物还有其他行为，那么也要写出来，比如学生的吃饭，睡觉等行为 private String username;//用户名 private String password;//密码 private String email;//邮箱 private char gender;//性别 private int age;//年龄 //空参构造方法 public User() &#123; &#125; //带全部参数的构造 public User(String username, String password, String email, char gender, int age) &#123; this.username = username; this.password = password; this.email = email; this.gender = gender; this.age = age; &#125; //get和set public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public char getGender() &#123; return gender; &#125; public void setGender(char gender) &#123; this.gender = gender; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void eat()&#123; System.out.println(username + &quot;在吃饭&quot;); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; //写一个标准的javabean类 //咱们在课后只要能把这个标准的javabean能自己写出来，那么就表示今天的知识点就ok了 //利用空参构造创建对象 User u1 = new User(); //如果利用空参创建对象，还想赋值只能用set方法赋值 u1.setUsername(&quot;zhangsan&quot;); u1.setPassword(&quot;1234qwer&quot;); u1.setEmail(&quot;itheima@itcast.cn&quot;); u1.setGender(&#x27;男&#x27;); u1.setAge(23); //获取属性的值并打印 System.out.println(u1.getUsername() + &quot;, &quot; + u1.getPassword() + &quot;, &quot; + u1.getEmail() + &quot;, &quot; + u1.getGender() + &quot;, &quot; + u1.getAge()); u1.eat(); System.out.println(&quot;=============================&quot;); //简单的办法 //利用带全部参数的构造来创建对象 //快捷键:ctrl + p User u2 = new User(&quot;lisi&quot;,&quot;12345678&quot;,&quot;lisi@itcast.cn&quot;,&#x27;女&#x27;,24); System.out.println(u2.getUsername() + &quot;, &quot; + u2.getPassword() + &quot;, &quot; + u2.getEmail() + &quot;, &quot; + u2.getGender() + &quot;, &quot; + u2.getAge()); u2.eat(); &#125;&#125;"},{"title":"综合练习","path":"/posts/2514530103/","content":"练习一：飞机票需求: ​\t机票价格按照淡季旺季、头等舱和经济舱收费、输入机票原价、月份和头等舱或经济舱。 ​\t按照如下规则计算机票价格：旺季（5-10月）头等舱9折，经济舱8.5折，淡季（11月到来年4月）头等舱7折，经济舱6.5折。 代码示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.itheima.test;import java.util.Scanner;public class Test1 &#123; public static void main(String[] args) &#123; /* 机票价格按照淡季旺季、头等舱和经济舱收费、输入机票原价、月份和头等舱或经济舱。 按照如下规则计算机票价格：旺季（5-10月）头等舱9折，经济舱8.5折，淡季（11月到来年4月）头等舱7折，经济舱6.5折。*/ //分析： //1.键盘录入机票原价、月份、头等舱或经济舱 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入机票的原价&quot;); int ticket = sc.nextInt(); System.out.println(&quot;请输入当前的月份&quot;); int month = sc.nextInt(); System.out.println(&quot;请输入当前购买的舱位 0 头等舱 1 经济舱&quot;); int seat = sc.nextInt(); //2.先判断月份是旺季还是淡季 //ctrl + alt + M 自动抽取方法 if (month &gt;= 5 &amp;&amp; month &lt;= 10) &#123; //旺季 //3.继续判断当前机票是经济舱还是头等舱 //ticket = getPrice(ticket, seat, 0.9, 0.85); ticket = getTicket(ticket, seat, 0.9, 0.85); &#125; else if ((month &gt;= 1 &amp;&amp; month &lt;= 4) || (month &gt;= 11 &amp;&amp; month &lt;= 12)) &#123; //淡季 //ticket = getPrice(ticket, seat, 0.7, 0.65); ticket = getTicket(ticket, seat, 0.7, 0.65); &#125; else &#123; //表示键盘录入的月份是一个非法数据 System.out.println(&quot;键盘录入的月份不合法&quot;); &#125; System.out.println(ticket); &#125; public static int getTicket(int ticket, int seat, double v, double v2) &#123; if (seat == 0) &#123; //头等舱 ticket = (int) (ticket * v); &#125; else if (seat == 1) &#123; //经济舱 ticket = (int) (ticket * v2); &#125; else &#123; System.out.println(&quot;没有这个舱位&quot;); &#125; return ticket; &#125; //1.我要干嘛？根据舱位和折扣来计算最终的票价 //2.我干这件事，需要什么才能完成？原价 舱位 头等舱的折扣 经济舱的折扣 //3.方法的调用处是否需要继续使用这个结果 需要 /* public static int getPrice(int ticket, int seat, double v0, double v1) &#123; if (seat == 0) &#123; //头等舱 ticket = (int) (ticket * v0); &#125; else if (seat == 1) &#123; //经济舱 ticket = (int) (ticket * v1); &#125; else &#123; System.out.println(&quot;没有这个舱位&quot;); &#125; return ticket; &#125;*/&#125; 练习二：打印素数​\t判断101~200之间有多少个素数，并输出所有素数。 备注：素数就是质数 代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.itheima.test;public class Test2 &#123; public static void main(String[] args) &#123; //判断 101 ~ 200 之间有多少个素数，并打印所有素数 //思路一： 2 ~ 99 //定义变量i ，赋值100 //判断i是否为质数 //定义一个变量用来统计有多少个质数 int count = 0; //外循环：遍历101~200这个范围，依次得到这个范围之内的每一个数字 for (int i = 101; i &lt;= 200; i++) &#123; //i 依次表示循环中的每一个数字 //继续判断i是否为一个质数 boolean flag = true; //内循环:判断当前数字是否为一个质数。 for (int j = 2; j &lt; i; j++) &#123; //j 表示2~99之间的每一个数字 if(i % j == 0)&#123; flag = false; //跳出单层循环，内循环 break; &#125; &#125; if(flag)&#123; System.out.println(&quot;当前数字&quot;+i+&quot;是质数&quot;); count++; &#125; &#125; System.out.println(&quot;一共有&quot; + count + &quot;个质数&quot;); /* int i = 7; boolean flag = true; for (int j = 2; j &lt; i; j++) &#123; //j 表示2~99之间的每一个数字 if(i % j == 0)&#123; flag = false; break; &#125; &#125; if(flag)&#123; System.out.println(&quot;当前数字是质数&quot;); &#125;else&#123; System.out.println(&quot;当前数字不是一个质数&quot;); &#125;*/ &#125;&#125; 练习三：验证码需求： ​\t定义方法实现随机产生一个5位的验证码 验证码格式： ​\t长度为5 ​\t前四位是大写字母或者小写字母 ​\t最后一位是数字 代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.itheima.test;import java.util.Random;public class Test3 &#123; public static void main(String[] args) &#123; /* 需求： 定义方法实现随机产生一个5位的验证码 验证码格式： 长度为5 前四位是大写字母或者小写字母 最后一位是数字 */ //方法： //在以后如果我们要在一堆没有什么规律的数据中随机抽取 //可以先把这些数据放到数组当中 //再随机抽取一个索引 //分析： //1.大写字母和小写字母都放到数组当中 char[] chs = new char[52]; for (int i = 0; i &lt; chs.length; i++) &#123; //ASCII码表 if(i &lt;= 25)&#123; //添加小写字母 chs[i] = (char)(97 + i); &#125;else&#123;//27 //添加大写字母 // A --- 65 chs[i] = (char)(65 + i - 26); &#125; &#125; //定义一个字符串类型的变量，用来记录最终的结果 String result = &quot;&quot;; //2.随机抽取4次 //随机抽取数组中的索引 Random r = new Random(); for (int i = 0; i &lt; 4; i++) &#123; int randomIndex = r.nextInt(chs.length); //利用随机索引，获取对应的元素 //System.out.println(chs[randomIndex]); result = result + chs[randomIndex]; &#125; //System.out.println(result); //3.随机抽取一个数字0~9 int number = r.nextInt(10); //生成最终的结果 result = result + number; //打印最终结果 System.out.println(result); &#125;&#125; 练习四：复制数组需求： ​\t把一个数组中的元素复制到另一个新数组中去。 代码示例： 123456789101112131415161718192021222324252627package com.itheima.test;public class Test4 &#123; public static void main(String[] args) &#123; /* 需求： 把一个数组中的元素复制到另一个新数组中去。*/ //分析： //1.定义一个老数组并存储一些元素 int[] arr = &#123;1,2,3,4,5&#125;; //2.定义一个新数组的长度跟老数组一致 int[] newArr = new int[arr.length]; //3.遍历老数组，得到老数组中的每一个元素，依次存入到新数组当中 for (int i = 0; i &lt; arr.length; i++) &#123; //i 表示老数组中的索引。新数组中的每一个索引 //arr[i] 表示老数组中的元素 newArr[i] = arr[i]; &#125; //4.新数组中已经存满元素了 for (int i = 0; i &lt; newArr.length; i++) &#123; System.out.println(newArr[i]); &#125; &#125;&#125; 练习五：评委打分需求 : ​\t在唱歌比赛中，有6名评委给选手打分，分数范围是[0 - 100]之间的整数。选手的最后得分为：去掉最高分、最低分后的4个评委的平均分，请完成上述过程并计算出选手的得分。 代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.itheima.test;import java.util.Scanner;public class Test5 &#123; public static void main(String[] args) &#123; //在唱歌比赛中，有6名评委给选手打分，分数范围是[0 - 100]之间的整数。 // 选手的最后得分为：去掉最高分、最低分后的4个评委的平均分，请完成上述过程并计算出选手的得分。 //分析： //1.定义一个数组，用来存储6名评委的打分（0~100） int[] scoreArr = getScores(); for (int i = 0; i &lt; scoreArr.length; i++) &#123; System.out.println(scoreArr[i]); &#125; //2.求出数组中的最大值 int max = getMax(scoreArr); //3.求出数组中的最小值 int min = getMin(scoreArr); //4.求出数组中6个分数的总和 int sum = getSum(scoreArr); //5.（总和 - 最大值 - 最小值 ）/4 int avg = (sum - max - min)/(scoreArr.length - 2); //6.打印结果 System.out.println(&quot;选手的最终得分为：&quot; + avg); &#125; public static int getSum(int[] scoreArr)&#123; int sum = 0; for (int i = 0; i &lt; scoreArr.length; i++) &#123; sum = sum + scoreArr[i]; &#125; return sum; &#125; //求数组的最大值 public static int getMax(int[] scoreArr)&#123; int max = scoreArr[0]; for (int i = 1; i &lt; scoreArr.length; i++) &#123; if(scoreArr[i] &gt; max)&#123; max = scoreArr[i]; &#125; &#125; return max; &#125; //求数组的最小值 public static int getMin(int[] scoreArr)&#123; int min = scoreArr[0]; for (int i = 1; i &lt; scoreArr.length; i++) &#123; if(scoreArr[i] &lt; min)&#123; min = scoreArr[i]; &#125; &#125; return min; &#125; //1.我要干嘛？定义一个数组，用来存储6名评委的打分（0~100） //2.我需要什么？都不需要 //3.干完了这件事情，是否需要返回？必须返回 public static int[] getScores()&#123; //定义数组 int[] scores = new int[6]; //使用键盘录入的形式，输入分数：0~100 Scanner sc = new Scanner(System.in); for (int i = 0; i &lt; scores.length; ) &#123; System.out.println(&quot;请输入评委的打分&quot;); int score = sc.nextInt();//100 if(score &gt;=0 &amp;&amp; score&lt;= 100)&#123; scores[i] = score; i++; &#125;else&#123; System.out.println(&quot;成绩超出了范围,继续录入，当前的i为：&quot; + i); &#125; &#125; return scores; &#125;&#125; 练习六：数字加密需求： ​\t某系统的数字密码（大于0），比如1983，采用加密方式进行传输。 规则如下： ​\t先得到每位数，然后每位数都加上5 , 再对10求余，最后将所有数字反转，得到一串新数。 举例： 12345 1\t9\t8\t3+5 6 14 13 8%10 6 4 3 8反转 8 3 4 6加密后的结果就是：8346 代码示例： 1234567891011121314151617181920212223242526272829303132333435363738394041package com.itheima.test;public class Test6 &#123; public static void main(String[] args) &#123; /* 某系统的数字密码（大于0）。比如1983，采用加密方式进行传输， 规则如下： 每位数加上5 再对10求余， 最后将所有数字反转， 得到一串新数。*/ //分析： //1.把整数里面的每一位放到数组当中 int[] arr = &#123;1, 9, 8, 3&#125;; //2.加密 //每位数加上5 for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = arr[i] + 5; &#125; //再对10求余， for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = arr[i] % 10; &#125; //将所有数字反转 for (int i = 0, j = arr.length - 1; i &lt; j; i++, j--) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; //8 3 4 6 --&gt; 8346 //3.把数组里面的每一个数字进行拼接，变成加密之后的结果 int number = 0; for (int i = 0; i &lt; arr.length; i++) &#123; number = number * 10 + arr[i]; &#125; System.out.println(number); &#125;&#125; 练习六扩展：123456789101112131415161718192021222324252627282930313233343536373839404142package com.itheima.test;public class Test7 &#123; public static void main(String[] args) &#123; //需求： //把整数上的每一位都添加到数组当中 //反向推导 //1.计算出数组的长度 int number = 12345; //定义一个变量临时记录number的值，就是为了第三步的时候再次使用 int temp = number; //定义一个变量进行统计 int count = 0; while(number != 0)&#123; //每一次循环就去掉右边的一个数字 number = number / 10; //去掉一位计数器就自增一次。 count++; &#125; //2.定义数组 //动态初始化 int[] arr = new int[count]; //3.把整数上的每一位都添加到数组当中 int index = arr.length -1; while(temp != 0)&#123;//12345 //获取temp里面的每一位数组 int ge = temp % 10; //再去掉右边的那位数字 temp = temp / 10; //把当前获取到的个位添加到数组当中 arr[index] = ge; index--; &#125; //验证结果 1 2 3 4 5 for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i] + &quot; &quot;); &#125; &#125;&#125; 练习七：数字解密把上一题加密之后的数据进行解密 代码示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.itheima.test;public class Test8 &#123; public static void main(String[] args) &#123; /*某系统的数字密码（大于0）。比如1983，采用加密方式进行传输， 规则如下： 每位数加上5 再对10求余， 最后将所有数字反转， 得到一串新数。 按照以上规则进行解密： 比如1983加密之后变成8346，解密之后变成1983 */ //1.定义数组记录解密之后的结果 int[] arr = &#123;8, 3, 4, 6&#125;; //2.反转 for (int i = 0, j = arr.length - 1; i &lt; j; i++, j--) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; //3.由于加密是通过对10取余的方式进行获取的 //所以在解密的时候就需要判断，0~4之间+10 5~9数字不变 for (int i = 0; i &lt; arr.length; i++) &#123; if (arr[i] &gt;= 0 &amp;&amp; arr[i] &lt;= 4) &#123; arr[i] = arr[i] + 10; &#125; &#125; //4.每一位减5 for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = arr[i] - 5; &#125; //5.获取数组里面的每一位数字拼接成最终的结果 int number = 0; for (int i = 0; i &lt; arr.length; i++) &#123; number = number * 10 + arr[i]; &#125; System.out.println(number); &#125;&#125; 练习八：抽奖需求： ​\t一个大V直播抽奖，奖品是现金红包，分别有{2, 588 , 888, 1000, 10000}五个奖金。请使用代码模拟抽奖，打印出每个奖项，奖项的出现顺序要随机且不重复。打印效果如下：（随机顺序，不一定是下面的顺序） 12345888元的奖金被抽出588元的奖金被抽出10000元的奖金被抽出1000元的奖金被抽出2元的奖金被抽出 解法一:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.itheima.test;import java.util.Random;public class Test9 &#123; public static void main(String[] args) &#123; /* 需求： 一个大V直播抽奖，奖品是现金红包，分别有&#123;2, 588 , 888, 1000, 10000&#125;五个奖金。 请使用代码模拟抽奖，打印出每个奖项，奖项的出现顺序要随机且不重复。 打印效果如下：（随机顺序，不一定是下面的顺序） 888元的奖金被抽出 588元的奖金被抽出 10000元的奖金被抽出 1000元的奖金被抽出 2元的奖金被抽出 */ //分析： //1.定义数组表示奖池 int[] arr = &#123;2, 588, 888, 1000, 10000&#125;; //2.定义新数组用于存储抽奖的结果 int[] newArr = new int[arr.length]; //3.抽奖 Random r = new Random(); //因为有5个奖项，所以这里要循环5次 for (int i = 0; i &lt; 5; ) &#123; //获取随机索引 int randomIndex = r.nextInt(arr.length); //获取奖项 int prize = arr[randomIndex]; //判断当前的奖项是否存在，如果存在则重新抽取，如果不存在，就表示是有效奖项 boolean flag = contains(newArr, prize); if(!flag)&#123; //把当前抽取到的奖项添加到newArr当中 newArr[i] = prize; //添加完毕之后，移动索引 i++; &#125; &#125; //4.遍历newArr for (int i = 0; i &lt; newArr.length; i++) &#123; System.out.println(newArr[i]); &#125; &#125; //判断prize在数组当中是否存在 //存在：true //不存在：false public static boolean contains(int[] arr,int prize)&#123; for (int i = 0; i &lt; arr.length; i++) &#123; if(arr[i] == prize)&#123; return true; &#125; &#125; return false; &#125;&#125; 解法二：123456789101112131415161718192021222324252627282930313233343536package com.itheima.test;import java.util.Random;public class Test10 &#123; public static void main(String[] args) &#123; /* 需求： 一个大V直播抽奖，奖品是现金红包，分别有&#123;2, 588 , 888, 1000, 10000&#125;五个奖金。 请使用代码模拟抽奖，打印出每个奖项，奖项的出现顺序要随机且不重复。 打印效果如下：（随机顺序，不一定是下面的顺序） 888元的奖金被抽出 588元的奖金被抽出 10000元的奖金被抽出 1000元的奖金被抽出 2元的奖金被抽出 */ //1.把奖池里面的所有奖项打乱顺序 int[] arr = &#123;2, 588, 888, 1000, 10000&#125;; Random r = new Random(); for (int i = 0; i &lt; arr.length; i++) &#123; //获取随机索引 int randomIndex = r.nextInt(arr.length); //拿着i跟随机索引randomIndex上的值进行交换 int temp = arr[i]; arr[i] = arr[randomIndex]; arr[randomIndex] = temp; &#125; //2.遍历奖池,从0索引开始获取每一个奖项 for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; &#125;&#125; 练习九：双色球 代码示例: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149package com.itheima.test;import java.util.Random;import java.util.Scanner;public class Test11 &#123; public static void main(String[] args) &#123; //1.生成中奖号码 int[] arr = createNumber(); // 123456 7 System.out.println(&quot;=======================&quot;); for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i] + &quot; &quot;); &#125; System.out.println(&quot;=======================&quot;); //2.用户输入彩票号码（红球 + 蓝球）//654321 int[] userInputArr = userInputNumber(); //3.判断用户的中奖情况 //红球 蓝球 int redCount = 0; int blueCount = 0; //判断红球 for (int i = 0; i &lt; userInputArr.length - 1; i++) &#123; int redNumber = userInputArr[i]; for (int j = 0; j &lt; arr.length - 1; j++) &#123; if(redNumber == arr[j])&#123; redCount++; //如果找到了，那么后面的数字就没有必要继续比较了 //跳出内循环，继续判断下一个红球号码是否中奖 break; &#125; &#125; &#125; //判断蓝球 int blueNumber = userInputArr[userInputArr.length-1]; if(blueNumber == arr[arr.length - 1])&#123; blueCount++; &#125; //根据红球的个数以及蓝球的个数来判断中奖情况 if(redCount == 6 &amp;&amp; blueCount == 1)&#123; System.out.println(&quot;恭喜你，中奖1000万&quot;); &#125;else if(redCount == 6 &amp;&amp; blueCount == 0)&#123; System.out.println(&quot;恭喜你，中奖500万&quot;); &#125;else if(redCount == 5 &amp;&amp; blueCount == 1)&#123; System.out.println(&quot;恭喜你，中奖3000&quot;); &#125;else if((redCount == 5 &amp;&amp; blueCount == 0) || (redCount == 4 &amp;&amp; blueCount == 1))&#123; System.out.println(&quot;恭喜你，中奖200&quot;); &#125;else if((redCount == 4 &amp;&amp; blueCount == 0) || (redCount == 3 &amp;&amp; blueCount == 1))&#123; System.out.println(&quot;恭喜你，中奖10&quot;); &#125;else if((redCount == 2 &amp;&amp; blueCount == 1) || (redCount == 1 &amp;&amp; blueCount == 1)|| (redCount == 0 &amp;&amp; blueCount == 1))&#123; System.out.println(&quot;恭喜你，中奖5&quot;); &#125;else&#123; System.out.println(&quot;谢谢参与，谢谢惠顾&quot;); &#125; &#125; public static int[] userInputNumber() &#123; //1.创建数组用于添加用户购买的彩票号码 //6个红球 1个蓝球 数组长度：7 int[] arr = new int[7]; //2.利用键盘录入让用输入 Scanner sc = new Scanner(System.in); //让用户输入红球号码 for (int i = 0; i &lt; 6; ) &#123; System.out.println(&quot;请输入第&quot; + (i + 1) + &quot;个红球号码&quot;); int redNumber = sc.nextInt(); //redNumber 在1~33 唯一不重复 if (redNumber &gt;= 1 &amp;&amp; redNumber &lt;= 33) &#123; boolean flag = contains(arr, redNumber); if (!flag) &#123; //不存在 //有效的，可以添加到数组当中 arr[i] = redNumber; i++; &#125; else &#123; //存在 System.out.println(&quot;当前红球号码已经存在，请重新输入&quot;); &#125; &#125; else &#123; System.out.println(&quot;当前红球号码超出范围&quot;); &#125; &#125; //让用户输入篮球号码 System.out.println(&quot;请输入篮球号码&quot;); //1~16 while (true) &#123; int blueNumber = sc.nextInt(); if (blueNumber &gt;= 1 &amp;&amp; blueNumber &lt;= 16) &#123; arr[arr.length - 1] = blueNumber; break; &#125; else &#123; System.out.println(&quot;当前篮球号码超出范围&quot;); &#125; &#125; return arr; &#125; public static int[] createNumber() &#123; //1.创建数组用于添加中奖号码 //6个红球 1个蓝球 数组长度：7 int[] arr = new int[7]; //2.随机生成号码并添加到数组当中 //红球：不能重复的 1 2 3 4 5 6 //蓝球：可以跟红球号码重复 5 //生成红球号码并添加到数组当中 Random r = new Random(); for (int i = 0; i &lt; 6; ) &#123; //获取红球号码 int redNumber = r.nextInt(33) + 1; boolean flag = contains(arr, redNumber); if (!flag) &#123; //把红球号码添加到数组当中 arr[i] = redNumber; i++; &#125; &#125; //生成蓝球号码并添加到数组当中 int blueNumber = r.nextInt(16) + 1; arr[arr.length - 1] = blueNumber; return arr; &#125; //用于判断数组在数组中是否存在 public static boolean contains(int[] arr, int number) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; if (arr[i] == number) &#123; return true; &#125; &#125; return false; &#125;&#125;"},{"title":"方法","path":"/posts/2902572094/","content":"1. 方法概述1.1 方法的概念​\t方法（method）是程序中最小的执行单元 注意： 方法必须先创建才可以使用，该过程成为方法定义 方法创建后并不是直接可以运行的，需要手动使用后，才执行，该过程成为方法调用 2. 方法的定义和调用2.1 无参数方法定义和调用 定义格式： 123public static void 方法名 ( ) &#123;\t// 方法体;&#125; 范例： 123public static void method ( ) &#123;\t// 方法体;&#125; 调用格式： 1方法名(); 范例： 1method(); 注意： ​\t方法必须先定义，后调用，否则程序将报错 2.3 无参数方法的练习 需求：设计一个方法用于打印两个数中的较大数 思路： ①定义一个方法，用于打印两个数字中的较大数，例如getMax() ②方法中定义两个变量，用于保存两个数字 ③使用分支语句分两种情况对两个数字的大小关系进行处理 ④在main()方法中调用定义好的方法 代码： 1234567891011121314151617181920public class MethodTest &#123; public static void main(String[] args) &#123; //在main()方法中调用定义好的方法 getMax(); &#125; //定义一个方法，用于打印两个数字中的较大数，例如getMax() public static void getMax() &#123; //方法中定义两个变量，用于保存两个数字 int a = 10; int b = 20; //使用分支语句分两种情况对两个数字的大小关系进行处理 if(a &gt; b) &#123; System.out.println(a); &#125; else &#123; System.out.println(b); &#125; &#125;&#125; 3. 带参数方法定义和调用3.1 带参数方法定义和调用 定义格式： 参数：由数据类型和变量名组成 - 数据类型 变量名 参数范例：int a 1234567public static void 方法名 (参数1) &#123;\t方法体;&#125;public static void 方法名 (参数1, 参数2, 参数3...) &#123;\t方法体;&#125; 范例： 123456public static void isEvenNumber(int number)&#123; ...&#125;public static void getMax(int num1, int num2)&#123; ...&#125; 注意： 方法定义时，参数中的数据类型与变量名都不能缺少，缺少任意一个程序将报错 方法定义时，多个参数之间使用逗号( ，)分隔 调用格式： 123方法名(参数)；方法名(参数1,参数2); 范例： 123isEvenNumber(10);getMax(10,20); 方法调用时，参数的数量与类型必须与方法定义中的设置相匹配，否则程序将报错 3.2 形参和实参 形参：方法定义中的参数 ​ 等同于变量定义格式，例如：int number 实参：方法调用中的参数 ​ 等同于使用变量或常量，例如： 10 number 3.3 带参数方法练习 需求：设计一个方法用于打印两个数中的较大数，数据来自于方法参数 } 思路： ①定义一个方法，用于打印两个数字中的较大数，例如getMax() ②为方法定义两个参数，用于接收两个数字 ③使用分支语句分两种情况对两个数字的大小关系进行处理 ④在main()方法中调用定义好的方法（使用常量） ⑤在main()方法中调用定义好的方法（使用变量） 代码： 12345678910111213141516171819202122232425public class MethodTest &#123; public static void main(String[] args) &#123; //在main()方法中调用定义好的方法（使用常量） getMax(10,20); //调用方法的时候，人家要几个，你就给几个，人家要什么类型的，你就给什么类型的 //getMax(30); //getMax(10.0,20.0); //在main()方法中调用定义好的方法（使用变量） int a = 10; int b = 20; getMax(a, b); &#125; //定义一个方法，用于打印两个数字中的较大数，例如getMax() //为方法定义两个参数，用于接收两个数字 public static void getMax(int a, int b) &#123; //使用分支语句分两种情况对两个数字的大小关系进行处理 if(a &gt; b) &#123; System.out.println(a); &#125; else &#123; System.out.println(b); &#125; &#125;&#125; 4. 带返回值方法的定义和调用4.1 带返回值方法定义和调用 定义格式 123public static 数据类型 方法名 ( 参数 ) &#123; return 数据 ;&#125; 范例 123456public static boolean isEvenNumber( int number ) &#123; return true ;&#125;public static int getMax( int a, int b ) &#123;\treturn 100 ;&#125; 注意： 方法定义时return后面的返回值与方法定义上的数据类型要匹配，否则程序将报错 调用格式 12方法名 ( 参数 ) ;数据类型 变量名 = 方法名 ( 参数 ) ; 范例 12isEvenNumber ( 5 ) ;boolean flag = isEvenNumber ( 5 ); 注意： 方法的返回值通常会使用变量接收，否则该返回值将无意义 4.2 带返回值方法练习1 需求：设计一个方法可以获取两个数的较大值，数据来自于参数 思路： ①定义一个方法，用于获取两个数字中的较大数 ②使用分支语句分两种情况对两个数字的大小关系进行处理 ③根据题设分别设置两种情况下对应的返回结果 ④在main()方法中调用定义好的方法并使用变量保存 ⑤在main()方法中调用定义好的方法并直接打印结果 代码： 123456789101112131415161718192021public class MethodTest &#123; public static void main(String[] args) &#123; //在main()方法中调用定义好的方法并使用变量保存 int result = getMax(10,20); System.out.println(result); //在main()方法中调用定义好的方法并直接打印结果 System.out.println(getMax(10,20)); &#125; //定义一个方法，用于获取两个数字中的较大数 public static int getMax(int a, int b) &#123; //使用分支语句分两种情况对两个数字的大小关系进行处理 //根据题设分别设置两种情况下对应的返回结果 if(a &gt; b) &#123; return a; &#125; else &#123; return b; &#125; &#125;&#125; 4.3 带返回值方法练习2需求： ​\t定义一个方法，求一家商场每个季度的营业额。根据方法结果再计算出全年营业额。 代码示例： 123456789101112131415161718192021222324252627282930package com.itheima.demo;public class MethodDemo9 &#123; public static void main(String[] args) &#123; /*需求：定义一个方法，求一家商场每个季度的营业额。 根据方法结果再计算出全年营业额。*/ int sum1 = getSum(10, 20, 30); int sum2 = getSum(10, 20, 30); int sum3 = getSum(10, 20, 30); int sum4 = getSum(10, 20, 30); int sum = sum1 + sum2 + sum3 + sum4; System.out.println(sum); &#125; //心得： //1.我要干嘛？ 决定了方法体 每个季度的营业额 //2.我干这件事情，需要什么才能完成？ 决定了形参 需要三个月的营业额 a b c //3.我干完这件事情，看调用处是否需要使用方法的结果。 决定了返回值 //如果需要使用，那么必须返回 //如果不需要使用，可以返回也可以不返回 public static int getSum(int month1,int month2,int month3)&#123; int sum = month1 + month2 + month3; //因为方法的调用处，需要继续使用这个结果 //所以我们必须要把sum返回 return sum; &#125;&#125; 4.4 带返回值方法练习3需求： ​\t键盘录入两个圆的半径（整数），比较两个圆的面积。 代码示例： 123456789101112131415161718192021222324252627282930import java.util.Scanner;public class MethodDemo10 &#123; public static void main(String[] args) &#123; //需求：键盘录入两个圆的半径（整数），比较两个圆的面积。 //键盘录入圆的半径 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入圆的半径&quot;); int radii1 = sc.nextInt(); System.out.println(&quot;请输入第二个圆的半径&quot;); int radii2 = sc.nextInt(); double area1 = getArea(radii1); double area2 = getArea(radii2); if(area1 &gt; area2)&#123; System.out.println(&quot;第一个圆更大&quot;); &#125;else&#123; System.out.println(&quot;第二个圆更大&quot;); &#125; &#125; //心得： //1.我要干嘛？ 求圆的面积 //2.我干这件事情，需要什么才能完成？ 半径 //3.方法的调用处，是否需要继续使用方法的结果 要比较 public static double getArea(int radii) &#123; double area = 3.14 * radii * radii; return area; &#125;&#125; 5. 方法的注意事项5.1 方法的注意事项 方法不能嵌套定义 示例代码： 1234567891011public class MethodDemo &#123; public static void main(String[] args) &#123; &#125; public static void methodOne() &#123; public static void methodTwo() &#123; // 这里会引发编译错误!!! &#125; &#125;&#125; void表示无返回值，可以省略return，也可以单独的书写return，后面不加数据 示例代码： 12345678910public class MethodDemo &#123; public static void main(String[] args) &#123; &#125; public static void methodTwo() &#123; //return 100; 编译错误，因为没有具体返回值类型 return; //System.out.println(100); return语句后面不能跟数据或代码 &#125;&#125; 5.2 方法的通用格式 格式： 1234public static 返回值类型 方法名(参数) &#123; 方法体; return 数据 ;&#125; 解释： public static 修饰符，目前先记住这个格式 返回值类型\t方法操作完毕之后返回的数据的数据类型 ​ 如果方法操作完毕，没有数据返回，这里写void，而且方法体中一般不写return 方法名 调用方法时候使用的标识 参数 由数据类型和变量名组成，多个参数之间用逗号隔开 方法体 完成功能的代码块 return 如果方法操作完毕，有数据返回，用于把数据返回给调用者 定义方法时，要做到两个明确 明确返回值类型：主要是明确方法操作完毕之后是否有数据返回，如果没有，写void；如果有，写对应的数据类型 明确参数：主要是明确参数的类型和数量 调用方法时的注意： void类型的方法，直接调用即可 非void类型的方法，推荐用变量接收调用 6. 方法重载6.1 方法重载 方法重载概念 方法重载指同一个类中定义的多个方法之间的关系，满足下列条件的多个方法相互构成重载 多个方法在同一个类中 多个方法具有相同的方法名 多个方法的参数不相同，类型不同或者数量不同 注意： 重载仅对应方法的定义，与方法的调用无关，调用方式参照标准格式 重载仅针对同一个类中方法的名称与参数进行识别，与返回值无关，换句话说不能通过返回值来判定两个方法是否相互构成重载 正确范例： 1234567891011121314151617public class MethodDemo &#123;\tpublic static void fn(int a) &#123; //方法体 &#125; public static int fn(double a) &#123; //方法体 &#125;&#125;public class MethodDemo &#123;\tpublic static float fn(int a) &#123; //方法体 &#125; public static int fn(int a , int b) &#123; //方法体 &#125;&#125; 错误范例： 12345678910111213141516171819public class MethodDemo &#123;\tpublic static void fn(int a) &#123; //方法体 &#125; public static int fn(int a) &#123; /*错误原因：重载与返回值无关*/ //方法体 &#125;&#125;public class MethodDemo01 &#123; public static void fn(int a) &#123; //方法体 &#125;&#125; public class MethodDemo02 &#123; public static int fn(double a) &#123; /*错误原因：这是两个类的两个fn方法*/ //方法体 &#125;&#125; 6.2 方法重载练习 需求：使用方法重载的思想，设计比较两个整数是否相同的方法，兼容全整数类型（byte,short,int,long） 思路： ①定义比较两个数字的是否相同的方法compare()方法，参数选择两个int型参数 ②定义对应的重载方法，变更对应的参数类型，参数变更为两个long型参数 ③定义所有的重载方法，两个byte类型与两个short类型参数 ④完成方法的调用，测试运行结果 代码： 12345678910111213141516171819202122232425262728293031323334public class MethodTest &#123; public static void main(String[] args) &#123; //调用方法 System.out.println(compare(10, 20)); System.out.println(compare((byte) 10, (byte) 20)); System.out.println(compare((short) 10, (short) 20)); System.out.println(compare(10L, 20L)); &#125; //int public static boolean compare(int a, int b) &#123; System.out.println(&quot;int&quot;); return a == b; &#125; //byte public static boolean compare(byte a, byte b) &#123; System.out.println(&quot;byte&quot;); return a == b; &#125; //short public static boolean compare(short a, short b) &#123; System.out.println(&quot;short&quot;); return a == b; &#125; //long public static boolean compare(long a, long b) &#123; System.out.println(&quot;long&quot;); return a == b; &#125;&#125; 7.3 数组遍历 需求：设计一个方法用于数组遍历，要求遍历的结果是在一行上的。例如：[11, 22, 33, 44, 55] 思路： ①因为要求结果在一行上输出，所以这里需要在学习一个新的输出语句System.out.print(“内容”); System.out.println(“内容”); 输出内容并换行 System.out.print(“内容”); 输出内容不换行 System.out.println(); 起到换行的作用 ②定义一个数组，用静态初始化完成数组元素初始化 ③定义一个方法，用数组遍历通用格式对数组进行遍历 ④用新的输出语句修改遍历操作 ⑤调用遍历方法 代码： 12345678910111213141516171819202122232425262728public class Test1 &#123; public static void main(String[] args) &#123; /* //先打印数据，再进行换行 System.out.println(&quot;aaa&quot;); //只打印不换行 System.out.print(&quot;bbb&quot;); System.out.print(&quot;ddd&quot;); //不打印任何内容，只换行 System.out.println(); System.out.print(&quot;cc&quot;);*/ //设计一个方法用于数组遍历，要求遍历的结果是在一行上的。例如：[11, 22, 33, 44, 55] int[] arr = &#123;1,2,3,4,5&#125;; printArr(arr); &#125; //1.我要遍历数组 //2.需要什么？ 数组 //3.调用处是否需要使用方法的结果。 public static void printArr(int[] arr)&#123; System.out.print(&quot;[&quot;); for (int i = 0; i &lt; arr.length; i++) &#123; if(i == arr.length - 1)&#123; System.out.println(arr[i] + &quot;]&quot;); &#125;else&#123; System.out.print(arr[i] + &quot;, &quot;); &#125; &#125; &#125;&#125; 7.4 数组最大值 需求：设计一个方法用于获取数组中元素的最大值 思路： ①定义一个数组，用静态初始化完成数组元素初始化 ②定义一个方法，用来获取数组中的最大值，最值的认知和讲解我们在数组中已经讲解过了 ③调用获取最大值方法，用变量接收返回结果 ④把结果输出在控制台 代码： 1234567891011121314151617181920212223242526272829public class MethodTest02 &#123; public static void main(String[] args) &#123; //定义一个数组，用静态初始化完成数组元素初始化 int[] arr = &#123;12, 45, 98, 73, 60&#125;; //调用获取最大值方法，用变量接收返回结果 int number = getMax(arr); //把结果输出在控制台 System.out.println(&quot;number:&quot; + number); &#125; //定义一个方法，用来获取数组中的最大值 /* 两个明确： 返回值类型：int 参数：int[] arr */ public static int getMax(int[] arr) &#123; int max = arr[0]; for(int x=1; x&lt;arr.length; x++) &#123; if(arr[x] &gt; max) &#123; max = arr[x]; &#125; &#125; return max; &#125;&#125; 7.6 获取索引需求： ​\t定义一个方法获取数字，在数组中的索引位置，将结果返回给调用处，如果有重复的，只要获取第一个即可。 代码示例： 12345678910111213141516171819202122232425262728293031package com.itheima.demo;public class Test4 &#123; public static void main(String[] args) &#123; //定义一个方法获取数字，在数组中的索引位置，将结果返回给调用处 //如果有重复的，只要获取第一个即可 int[] arr = &#123;1,2,3,4,5&#125;; int index = contains(arr, 3); System.out.println(index); &#125; //1. 我要干嘛？判断数组中的某一个数是否存在 //2. 需要什么？数组 数字 //3. 调用处是否需要继续使用？返回 //获取number在arr中的位置 public static int contains(int[] arr, int number) &#123; //遍历arr得到每一个元素 for (int i = 0; i &lt; arr.length; i++) &#123; //拿着每一个元素跟number比较 if(arr[i] == number)&#123; //如果相等，表示找到了 return i; &#125; &#125; //当循环结束之后，如果还不能返回索引，表示数组中不存在该数据 //可以返回-1 return -1; &#125;&#125;"},{"title":"关于Waline部署在Vercel上无法正常加载的解决方案","path":"/posts/3352780266/","content":"问题描述在博客的搭建基本完成的时候，我发现Waline的评论框无法正常加载。 我的Waline是在Vercel上托管部署的。默认的情况下，Waline是无法正常加载的，因为vercel.app的域名在国内已经被DNS污染了。 那么同理，如果你是直接把自己的博客平台都部署在Vercel上，也会出现无法正常加载的情况。解决方案也是类似的，接下来来介绍一下如何操作。 解决方法前提： 1、你已经拥有了自己的博客并且已经为它申请了域名，申请域名的过程就不再赘述了。 2、按步骤开通了walinee所需的环境（leancloud、vercel那些），这里我默认你已经搭建好，如果还不会，请参照官方文档进行操作。 添加新的域名解析登录你的域名解析商的后台，找到你的域名记录。 我使用的是腾讯云的域名解析，所以我在域名解析的页面找到我的域名记录，点击添加记录。 添加一个二级域名 比如我在腾讯云里的主机记录里增加了一个叫做 comment 并且 CNAME 解析记录指向了 cname.vercel-dns.com 。 如下图： 这样我就拥有了一个 comment.zargo.site 的子域名了。 修改Vercel的Domains信息在setting里找到Domains 让你原有的vercel上的Waline地址指向你设置的子域名上： Redeploy一下你的Waline项目 修改Hexo的配置文件我在修改完以上信息之后还是不能正常访问，随后我去到了我的博客的配置文件里，将waline配置文件的’serverURL’字段修改成了’comment.zargo.site’ 现在问题真正解决了！ 问题解决后随想这样就可以正常访问了。但是我心中对DNS污染的相关疑惑还没有解决。 下面查阅了一些资料： DNS污染是一种网络攻击，攻击者通过向域名系统（DNS）服务器注入错误的解析记录，导致用户访问到错误的IP地址。这种攻击通常用于干扰正常的网络通信、窃取信息或将用户重定向到恶意网站。 简单来说，当用户尝试访问某个网站时，DNS会将域名转换为对应的IP地址。如果DNS被污染，用户可能会被导向一个假的或恶意的地址，而不是他们想要访问的真实网站。这种方式可以被用来进行网络钓鱼或其他类型的网络攻击。 在现代互联网中，DNS污染已经成为一个严重的问题。一些国家和组织已经采取了措施来防止DNS污染，例如使用DNSSEC（DNS安全扩展）来验证DNS记录的真实性。然而，DNS污染仍然是一个持续的问题，需要采取措施来保护用户的隐私和安全。"},{"title":"Github仓库里文件有白色箭头但是打不开问题（已解决）","path":"/posts/2535023956/","content":"问题描述今天在检查之前git进远程仓库的代码时，发现有一个文件有白色箭头，但是点击后无法打开。 通过查询文档，发现了问题所在。在此记录。 原因箭头可能意味着这是一个子模块 子模块的意思: 有一个指向另一个git版本控制项目&#x2F;储存库提交的链接。 我是用的别人的Hexo主题，他的代码是包含”.git”文件夹和”.gitignore”文件，属于子模块，所以会出现箭头。 解决方法！！！在进行所有操作前一定要对目标文件夹进行备份！！！ 出现了问题可以及时回滚，就不怕操作出问题导致项目文件丢失了。这很重要！ 在git bash中输入 1234567891011121314git pull #先拉取远程仓库代码下来#删除子文件夹里面.git文件,我这里是删除了&quot;blog/themes&quot;文件夹里面的.git文件和gitignore文件git rm -cached + 文件夹路径 #删除缓存，我是建议打不开的文件夹全部删掉,注意文件夹的名字需要写清楚路径，我这里用的是&quot;blog/themes&quot;#如果遇到删不掉的情况使用命令：rm -rf + 文件夹路径#然后重新推到远程仓库git add --allgit commit -m &#x27;备注&#x27; git push &lt;remote_repository_name&gt; &lt;branch_name&gt; 在处理期间由于看了别人的解决办法都是使用 “git add .” 命令，一直失败，文件还是带箭头的打不开，后来发现正是提交到缓存区的命令出问题了，应该使用 “git add –all” 命令。 “git add .”命令并不会记录你在工作目录里的删除操作，也就是你删除的文件记录并不会被提交到缓存区，所以你还是会把在本地删掉的git文件传上去，那不是等于没有删除吗。 “git add –all”命令则会记录你在工作目录里的所有操作，包括删除操作。再次上传之后就完成了。"},{"title":"博客部署SSL证书教程，带你搞懂HTTPS","path":"/posts/1527092412/","content":"前言最近在做自己的博客，发现部署在自己的服务器上后，是HTTP协议的站点，作为小白，查询了很多文件和资料，成功将HTTP的站点变更为了HTTPS。 不过在这背后，关于HTTPS的相关知识我想能够全部记录下来，本文整合了自己在学习过程中查询到的资料，希望能够帮助到大家。 需要查看如何在Nignx上部署SSL证书的可以直接跳转在Nignx上部署SSL证书。 本文尝试从 HTTP 开始，一步一步深入到 HTTPS，告诉你 HTTPS 到底是什么、为什么需要 HTTPS、以及 HTTPS 到底是怎么做的。相信你在阅读完本文后，一定会对 HTTPS 有深入的了解。 好了，废话不多说，直接进入正题吧。 什么是 HTTPS ?一句话，HTTPS &#x3D; HTTP + SSL。HTTPS 并不是一个全新的协议，而是在 HTTP 的基础上，通过 SSL 增加了一层加密协议，从而大大增加了 HTTP 协议的安全性。 所以在正式了解 HTTPS 之前，我们需要先了解 HTTP。 1.HTTPHTTP 全称 超文本传输协议（HyperText Transfer Protocol），是一种广泛用于互联网中浏览器与服务器之间的应用层传输协议。简单来说，浏览器向服务器发送 HTTP 请求，服务器向浏览器返回 HTTP 响应，两者之间通过这种方式进行“交流”，来使得我们的浏览器可以正常从服务器端获取数据，并展示在用户的电脑屏幕上. 以访问 http://httpbin.org 网址为例，一个典型的 HTTP 请求如下所示： 12345678910GET / HTTP/1.1Accept: text/html,...Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cache-Control: no-cacheConnection: keep-aliveHost: httpbin.orgPragma: no-cacheUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Safari/537.366 GET 表示请求方法，常见的 HTTP 请求方法有 GET、POST、PUT、DELETE 等… GET 后面的 &#x2F;表示请求路径，这里我们访问的根路径，所以显示为 &#x2F;。如果你访问 httpbin.org&#x2F;get 的话，这里显示的就是 &#x2F;get了 HTTP&#x2F;1.1 表示使用的 HTTP 协议版本，现在常用的有 HTTP&#x2F;1.1 和 HTTP&#x2F;2，当然还有更先进的 HTTP&#x2F;3，这里就不过多展开了 下面的 9 行全部都是 HTTP header，每一个 header 包含 name 和 value，之间用冒号分隔开。 一个典型的 HTTP 响应如下所示 12345678910HTTP/1.1 200 OKDate: Sat, 08 Apr 2023 16:28:43 GMTContent-Type: text/html; charset=utf-8Content-Length: 9593Connection: keep-aliveServer: gunicorn/19.9.0Access-Control-Allow-Origin: *Access-Control-Allow-Credentials: truebody... HTTP&#x2F;1.1 指的协议版本，响应和请求的协议版本是一致的 200 OK 代表返回的响应码，表示这个响应是符合预期的。另外还有非常常见的返回码 404 NOT FOUND ，大家应该或多或少听说过，它表示服务器告诉你你访问的这个资源不存在 后面 7 行全部是 HTTP header，同样每一个 header 包含 name 和 value，之间用冒号分隔开。 最后是 HTTP Body，也就是响应体，即服务器返回给你的内容主体，浏览器正是根据响应体来渲染页面的 由于本文重点不在 HTTP，这里不再详细介绍各个部分的作用 2.为什么需要HTTPS我们知道，HTTP （除了最新的 HTTP&#x2F;3 外），传输层是基于 TCP 协议的。TCP 建立连接时，有三次握手。三次握手完毕之后，TCP 连接就顺利建立了，接下来两端将会传输数据。 对于普通的 HTTP 协议，在建立完 TCP 连接之后，就直接开始传输数据了，这时候数据是明文传输的，这也是 HTTP 最不安全的地方。 明文传输是什么概念呢？ 我们知道，浏览器和服务器之间，是存在很长一条路线的，你在家里通过浏览器访问网页的时候，数据会从你的电脑，传到你家里的路由器，再到光猫，到运营商，到互联网…直到最后才到服务器。在明文传输下，理论上来讲，浏览器和服务器之间的任一节点，包括你家里的路由器、包括你购买宽带&#x2F;流量的运营商，都可以“窃听”你们的数据，甚至还可以修改数据。 听起来不够直观？ 打个比方，近代时期，战场上打仗时，部队之间会通过电台进行交流。如果通过明文进行交流，那么非常危险，敌军可以打开电台进行窃听，偷取你的军事情报，这样的事也屡见不鲜了…那么他们是如何解决这个问题的呢？ 两个部队之间提前约定一个加密的方案，在传数据之前，先把它进行加密再传输，另一端收到数据之后，按照事先约定的方案进行解密，然后读取就可以了。这样即使敌军开始窃听，也只能听到加密后的情报，如果无法对其破解的话，得不到任何有效信息。 没错，这就是 HTTPS 的思想，浏览器在发送 HTTP 请求之前，先通过某种方式对其进行加密，然后再进行传输。服务器端收到数据之后，对其解密，读取真实内容，生成 HTTP 响应，同样对响应进行加密，然后传回给浏览器，浏览器收到数据之后，对其进行解密，得到真正的 HTTP 响应。这样就可以保证数据在传输过程中的安全性，无论是路由器还是运营商，都没有办法“窃听”你们的数据了。 说到这里，想必你已经知道 HTTPS 的一大作用了，它可以保证数据在互联网上传输的安全性，避免中间节点进行窃听和修改。 当然，聪明的你还可能会想到一些问题，例如： 战场上军队之间是提前约定好加密方案的，但是咱们任意一个浏览器都可以随时访问网页，没有办法提前约定加密方案呀，那是怎么做到的呢？ 战场上经常出现敌军对另一方部队之间的电台加密进行破解的事情，破解完成之后，还是能够窃听到数据，那 HTTPS 的这个加密方案到底安全吗，会被破解吗？ 这些问题，你都可以在本文中得到答案。 3. HTTP + SSL &#x3D; HTTPS ！上面提到了对 HTTP 进行加密的思想。在 HTTPS 的具体实现中，这个加密方案即是大名鼎鼎的 SSL（Secure Sockets Layer）。 定义：SSL（Secure Sockets Layer）是一种安全协议，用于在互联网上保护数据的传输安全。它工作在传输层，主要功能是通过加密技术，保护不同计算机之间的数据传输过程，防止敏感数据被黑客窃取和篡改。SSL 协议可以用于保护网站的用户登录、信用卡支付、网上银行等敏感信息的传输，以及企业之间的机密数据的传输。SSL 协议目前已经被继承为 TLS（Transport Layer Security），是一种安全性更高的传输层协议。所以，下面我将统一以 TLS 为名称进行讲解。 首先，划重点，TLS 中有 Transport Layer，顾名思义，它一定是工作在传输层了。上面提到过，HTTP 是应用层协议，传输层和应用层的概念，想必大家应该知道吧，计算机网络的事实标准中，自顶向下可以分为五层：应用层、传输层、网络层、链路层、物理层…这是《计算机网络》的基础，这里不过多展开，不熟悉的同学，要回去重修一下课程了。 我们知道，TCP 协议里有三次握手，三次握手成功后连接才算建立，接下来才会真正开始传输数据。传统的 HTTP 协议中，三次握手成功之后，就会直接开始明文传输 HTTP 数据了。 那么 TLS 是什么时候开始发挥作用的呢？答案很简单，在三次握手之后，传输数据之前。 也就是说，在 TCP 协议中加入 TLS 之后，三次握手成功之后就不会再立刻开始传输数据了，而是紧接着开始 TLS 的建立过程，也被称为 TLS 握手。 TLS 握手是干嘛呢？或者说为什么需要 TLS 握手呢？上面提到，在战场上，两个部队之间会提前约定好加密的方案，例如面对面用纸互相写下加密方案，然后在一段时间之内的电台通信统一用这个加密方案，这样能一定程度上保证电台通信的安全性。但是 TLS 中我们并没有这样一个“面对面”的机会，咱们总不可能在访问网页之前，人肉跑到服务器的维护者那边去跟他约定加密方案吧。出于这个目的，TLS 握手便出现了。所以我们可以说，TLS 握手的目的是给通信双方约定一个安全的加密方案（可以理解为商量一个只有双方知道的加密密钥）。 知道了 TLS 握手的目的，接下来我们需要知道它具体是怎么做的。首先，我们肯定不能直接明文传输加密方案（密钥），不然这个密钥在传输过程中就直接被第三方获取了，那么加密将没有任何意义。也就是说，TLS 握手需要做到：通信双方可以约定一个共同的加密方案（密钥），并且这个约定的过程（即 TLS 握手过程），即使被任何第三方窃听到，也无法解析出这个加密方案（密钥）。 是不是听起来很神奇，那到底是怎么做到的呢？这就不得不提到密码学中非常经典的两个概念：对称加密和非对称加密。 4.对称加密，非对称加密 对称加密是 TLS 握手成功后，通信双方之间采用的数据加密方案。现在的主要问题是：通信双方如何安全的商量好这个对称密钥，防止密钥被其他人窃取？ 这时就需要轮到非对称加密出场了。什么是非对称加密呢？与对称加密不同，非对称加密方案中，用户手握两把密钥，一把称为公钥，一把称为私钥，其中公&#x2F;私钥都可以用来加密&#x2F;解密数据，但是：用公钥加密后的数据，只有用私钥才能将其解开；用私钥加密后的数据，只有用公钥才能将其解开！ 这里只介绍了非对称加密的特点，并没有介绍其原理，因为这属于密码学的范畴了，展开来讲又是一篇文章。简单说说其思想吧，目前流行的非对称加密算法 RSA 基于的原理其实就一句话：我们目前还没有很好的办法对一个很大的数做因式分解，例如你在心里默默想一个很大的质数 p 和 质数 q，算出其乘积 n，那么向外公开 n 的话，外部人员是很难找出 p 和 q 的（只能暴力尝试，而当这样的数够大够多的时候，以现在的计算机算力也需要几百上千年的时间才能破解了）。对密码学感兴趣的同学，可自行进一步了解。 有了非对称加密，事情就变得有意思起来了。见下图，服务器端用非对称加密方案生成一对公&#x2F;私钥，私钥掌握在自己手里，谁也不告诉；在 TLS 握手的过程中，服务器将自己的公钥交给浏览器端，浏览器端在心里默默想出一个对称加密的密钥后，将这个密钥用服务器端的公钥进行加密，然后再传回给浏览器端；浏览器端收到这个数据之后，用自己的私钥将其进行解密，就能够得到刚才浏览器心里默念的那个对称密钥了。这样这个问题就完美的解决了，两边可以心有灵犀的拿到这个对称密钥，而不用担心被任何第三方窃取到了。 这就是 TLS 握手的过程吗？不，当然没这么简单了，我们还没有考虑一个非常巧妙的攻击手段：中间人攻击。 5.中间人攻击 假设现在我们从电脑上访问百度，如果有一个中间人在我的路由器端，或者运营商端，或者任何一个中间节点上截取了我的请求，刚不是提到服务器端需要返回给我们公钥吗，中间人他自己也生成一套公&#x2F;私钥，然后将自己的公钥返回给我，这样我就与中间人之间建立了一条我以为“安全”的连接了，此时我以为我连接的是百度服务器，其实我连接的是中间人…那么此时中间人可以做任何事情了，如果他人品比较好的话，他可以默默当一个代理，我要访问百度，他就去帮我访问百度，然后把结果返回给我，勤勤恳恳做一个“中间商”。当然，我们知道做这种攻击的人人品往往不会太好，所以他们可以做更坏的事情，例如伪造一个银行网页返回给我，让我填写账号和密码，这样的话…后果就不堪设想了。 那么如何防止中间人攻击呢？其中的核心就是：我们需要保证我们访问的就是目标服务器，例如，当我们访问百度时，我们需要确保在 TLS 握手时，给我们公钥的人就是百度，而不是任何其他人。 那么这个应该如何去保证呢？这就不得不提到接下来的几个概念了，数字证书，以及证书权威机构（Certificate Authority，简称 CA）。 6.数字证书、CA数字证书是由证书权威机构（CA）颁发的一个用于证明身份的证书，当然其中还包含了该用户的公钥等信息。例如还是以百度为例，假设百度需要给 www.baidu.com 这个域名申请一个数字证书，他需要在生成公钥&#x2F;私钥后，将自身的信息（包括域名、公司名称、公钥信息等）发给某个证书权威机构（CA），让 CA 给自己颁发一个数字证书。CA 需要验证百度的真实身份，并且他确实拥有 www.baidu.com 这个域名，一切都验证通过后，CA 才会给百度颁发这么一个数字证书。那么之后，不管是谁用浏览器访问 www.baidu.com 的时候，百度都会将刚才那个 CA 颁发的数字证书发送给用户，既可以用来自证身份，同时还顺便告诉了用户自己的公钥。 到这里你可能还会有几个疑问： 数字证书如何保证不能伪造呢，难道中间人不能伪造一个数字证书发送给用户吗？即使数字证书不能被伪造，从概念上看他是公开的，难道中间人不能直接把这个证书颁发给用户吗？ 下面会一一回答这几个问题。正式回答之前，先来看看数字证书里究竟有哪些内容。 既然上面提到百度，我们就以百度为例，我们使用浏览器访问百度，可以在地址栏左边看到一个小锁，点击后，就可以查看百度的数字证书 图中可以看到该证书的一些基本信息： 颁发对象：这个证书是颁发给百度的，并且只对域名 (www.)baidu.com 有效 颁发者：这个证书是由 GlobalSign 颁发的。（GlobalSign是一家全球知名的证书权威机构） 有效期：这个证书的有效期是从 2022 年 7 月到 2023 年 8 月。（一旦过期，证书将不被信任） 指纹：指纹是整张证书经过哈希计算后得到的特征值，主要与后面会提到的签名一起工作，起到防篡改的作用 当然，一张数字证书的内容远远不止于此，例如还包含了服务器的公钥，可以在“详细信息”中进行查看。 下面我们在证书详细信息中点击“导出”，将证书导出为 Base64 编码的单一证书，然后使用 openssl 对其进行解析和查看 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253$ openssl x509 -noout -text -in baidu.com.cerCertificate: Data: Version: 3 (0x2) Serial Number: 44:17:ce:86:ef:82:ec:69:21:cc:6f:68 Signature Algorithm: sha256WithRSAEncryption Issuer: C=BE, O=GlobalSign nv-sa, CN=GlobalSign RSA OV SSL CA 2018 Validity Not Before: Jul 5 05:16:02 2022 GMT Not After : Aug 6 05:16:01 2023 GMT Subject: C=CN, ST=beijing, L=beijing, OU=service operation department, O=Beijing Baidu Netcom Science Technology Co., Ltd, CN=baidu.com Subject Public Key Info: Public Key Algorithm: rsaEncryption RSA Public-Key: (2048 bit) Modulus: 00:aa:2f:cc:41:8d:25:ae:83:e9:f4:27:c4:00:b3: 39:6f:0e:98:2a:55:7d:07:e5:80:49:82:fa:d3:d3: 85:98:b5:df:7b:6f:bb:02:dd:ed:78:e4:0c:07:2b: 9e:1e:86:4b:f6:6a:86:58:d7:57:6f:21:59:11:d8: 6f:96:6e:d2:de:36:28:f6:b4:e3:ce:95:32:29:00: c1:65:8e:69:b0:00:fe:52:37:f4:88:3f:8b:6d:0f: bb:f0:ec:c5:c0:31:ef:ad:b5:0c:06:66:ad:be:dc: 43:13:c4:66:b0:5d:cf:56:53:e2:d1:96:82:1c:06: bb:9b:5f:ed:60:8d:d2:ed:f3:d2:50:ee:bb:cd:b2: 36:97:c8:ce:7b:d2:4b:b7:5c:b4:88:ca:37:6e:8b: ce:f9:96:fd:b4:f5:47:b5:20:77:bb:fc:a8:9d:81: b2:6c:f8:c7:09:6a:dd:22:6e:83:3f:a7:53:df:f1: da:2f:29:6b:22:c3:e9:1d:65:e8:c5:a0:ba:13:4e: 16:3f:03:93:f0:a5:59:8a:1a:80:e8:27:7d:49:23: df:d1:f9:4b:97:b7:01:c4:19:f5:f1:c5:ff:91:33: d0:a1:74:c6:ee:d4:cf:f6:38:0c:ed:bd:5e:aa:44: fb:88:f7:7b:99:70:76:34:55:7e:55:d2:0f:9e:bf: 94:93 ... (中间省略） Signature Algorithm: sha256WithRSAEncryption 63:21:07:23:47:06:eb:b3:7c:77:6c:df:bc:55:12:b9:f1:5e: 6a:04:60:16:be:d0:0b:18:9c:94:0c:a8:82:08:25:0d:26:fb: dd:cb:fc:8c:27:d9:0c:fa:4a:b6:31:b6:67:f0:26:2c:0d:96: 96:39:65:3f:d9:a1:ee:de:9c:10:4d:54:e1:c8:d6:a9:0e:77: db:00:e2:37:e3:3f:b4:9c:31:4f:ac:74:d3:22:12:53:36:d0: ef:18:07:2d:8e:d0:e6:91:b2:6c:4a:5e:39:53:14:58:4e:d1: 50:04:c9:83:7e:0d:7b:15:96:87:11:d7:5d:4a:17:ac:aa:9f: 84:e3:a8:24:9d:d6:17:77:26:8c:9f:7a:7b:18:da:39:2f:77: f7:2b:c7:23:b8:97:6f:c3:d1:72:4c:7e:fc:c6:0d:cc:73:38: 19:81:fb:e7:c1:7a:e8:b9:1d:3a:05:dc:36:04:9b:f1:f0:e1: a6:47:a0:30:4f:55:90:6c:da:cf:9e:b2:76:12:11:a1:5c:b6: 61:8d:15:a4:68:65:9a:57:2f:7a:6e:a3:1f:f5:b4:92:5a:3c: df:71:0a:cd:57:d4:d0:15:36:7e:ba:d5:03:25:27:45:b4:60: cd:2e:02:c1:0f:0a:e7:41:6f:58:69:20:9e:ad:47:52:1a:b5: e6:e5:8d:1d 可以看到，除了上面 Chrome 里显示的一些基本信息外，证书里还包含了几个重要信息： 服务器端的公钥，即上面 RSA Public-Key 下面的那一长串数字，就是百度的公钥了。 签名，证明数字证书有效的关键信息。如果把数字证书类比成一张合同的话，我们知道合同需要老板签字才算有效，同样，数字证书是需要 CA 签名才算有效的，这里的一长串字符就是 CA 对该证书的“签名”了。 我们知道合同上的签名是靠笔迹鉴定来确认真伪的，很明显这一长串字符里没有笔迹，那它是如何保证该签名是 CA 颁发的，而不是被其他人伪造的呢？ 上面我们提到，每一张数字证书有一个指纹，是将整张证书经过哈希运算后得到的特征值。CA 作为权威机构，其本身也是有一对公钥&#x2F;私钥的，它在颁发数字证书的时候，会用自己的私钥对证书的指纹进行加密，生成的这段加密数据，就是该证书的签名了！那么我们浏览器是如何验证证书的真伪呢？我们只需要使用 CA 的公钥对签名进行解密，看看得到的值是不是跟证书的指纹是一样的，这样就 OK 了，只要是一样，说明这个证书一定是 CA 颁发的。 那么，又有问题来了：我们浏览器是从哪里拿到 CA 的公钥呢？总不能还是通过网络传输吧，这样就有“套娃”的中间人攻击风险了。所以啊，我们的浏览器或操作系统已经内置了世界权威的 CA 的数字证书（证书里就包含了其公钥）了，点击浏览器的 设置 -&gt; 隐私设置和安全性 -&gt; 安全 -&gt; 管理设备证书，可以查看当前系统内置的所有 CA 证书。 上图是我的电脑中内置的 CA 证书。刚刚提到了百度的数字证书是由 GlobalSign 颁发的，这里也可以验证，GlobalSign 是被我们的操作系统所信任的 CA，并且我们已经将它的证书内置在操作系统中了。因此现在我们可以认定说，这个证书是值得信任的，与我们建立连接的就是百度，不是别人。 你可能会想，如果中间人将百度真实的数字证书返回给我呢？中间人是没有百度的私钥的，所以当我们提取出证书中的公钥，并对心里想的密钥进行加密后，中间人是解不开这个密钥的，所以中间人无论如何也无法与我们建立连接。 好了，数字证书的内容已经全部讲述完毕了，最后回过头来复习下前面提到的两个问题： 数字证书如何保证自身不会被伪造？数字证书中有一段签名，该签名是 CA 使用其私钥对证书指纹进行加密后得到的值，我们浏览器使用 CA 的公钥对该签名进行解密后，与该证书的指纹进行对比，就可以知道证书是否被篡改或者伪造了。当然，这里要多提一嘴，我们作为客户端，需要保证自己的电脑里保存的都是值得信任的 CA 根证书，因为信任某 CA 就代表信任了该 CA 颁发的所有数字证书，如果有人&#x2F;软件想在你的电脑里安装来历不明的 CA 证书，那你就要保持警惕了…如果中间人直接把真实的数字证书返回给我，它能够成功与我建立连接吗？答案是不行的。这个问题其实比较简单，刚刚提到，服务器端除了公钥外，自身还保存有一份私钥的，而中间人是拿不到这个私钥的，因为它被服务器雪藏起来，不会发送到互联网中的…那么如果中间人用服务器的证书返回给用户，用户采用服务器的公钥对自身默念出来的对称密钥进行加密后，返回给中间人的时候，中间人就一脸懵逼了，因为这个密钥它解不开呀，它没有私钥的，所以这个问题就完美解决了。 7.TLS握手的具体过程 上图来自 www.ssl.com ，展示了整个握手流程，我用大白话解释一下： 客户端向服务器发送 Client Hello 信息，告知自己想要建立一条 TLS 连接，并告知自己支持的加密算法。 服务器向客户端发送一个 Server Hello 的回应，并选择一个加密算法，同时给客户端发送自己的数字证书（包含服务器的公钥）。 客户端验证服务器发来的数字证书，验证通过后，在心里默默想出一个 pre-master 密钥（预主密钥），然后使用服务器的公钥，将预主密钥进行加密后，发送给服务器。服务器用自己的私钥进行解密，得到预主密钥。 客户端和服务器都通过预主密钥，进行相同的计算后，得到后续通信时使用的对称加密密钥，称为 shared secret。 客户端和服务器端都分别用生成的 shared-secret 加密一段报文后，发送给对方，以验证对方能够成功收到信息并解密。 然后 TLS 就建立成功了，接下来双方都用这个 shared-secret 进行加密通信。 总结一下，HTTPS 的加密过程中其实既用到了非对称加密也用到了对称加密，其中握手过程使用的是非对称加密，主要目的是双方可以安全的协商一个统一的密钥，而真正的数据传输过程则使用的是对称加密，正是使用刚才商量的这个密钥。 你可能会问，为什么不全程使用非对称加密呢？因为对称加密效率更高，尤其是在大量数据的时候，对称加密比非对称加密整整快几个数量级，所以真正数据传输的过程选用了对称加密。 到这里，HTTPS 的原理就已经全部介绍完毕了。大家如果还有什么疑问，欢迎在评论区留言讨论。 总结最后，我们总结一下，HTTPS 解决了两个问题： 数据传输过程中的安全问题，因为它对数据进行了加密，只有浏览器和服务器可以对其进行解密。 浏览器对服务器的信任问题，数字证书以及其中的数字签名，保证了我们访问的就是我们想要访问的服务器，不可能被钓鱼网站欺骗，也不可能被中间人攻击所欺骗。 当然，保证以上安全的前提是我们的电脑本身没有被攻破，如果你的电脑被黑客攻击，装上了来历不明的根证书，那么 HTTPS 也不能保障你的安全了。 在Nignx上部署SSL证书介绍完了HTTPS的原理，我们来看看如何在Nginx上部署SSL证书。 首先你要去到你购买服务器的控制台，找到你的服务器，点击“管理”，然后点击“安全组”，在“入站规则”中添加一个“HTTPS”规则，端口号为443，协议为TCP，然后点击“保存”。 然后搜索“SSL证书”，找到“SSL证书”，点击“创建证书”，然后按照提示填写好信息，点击“确定”。 每个服务器供应商都会提供免费的SSL证书，你可以选择免费的证书，也可以选择付费的证书。 按流程添加DNS解析并等待证书生成即可。 证书生成后点击下载并解压到本地 解压文件后，将其中以.key和.crt结尾的文件打开并复制到Nginx的配置文件中。 我是用的是宝塔面板进行配置的，在“网站”中找到你的网站，点击“设置”–&gt;“SSL”，然后点击“上传证书”，将刚才复制的文件粘贴进去即可。 之后你就可以用HTTPS访问你的网站了!"},{"title":"Redis的数据类型","path":"/posts/1286363648/","content":"Redis 数据类型Redis 主要支持以下几种数据类型： string（字符串）: 基本的数据存储单元，可以存储字符串、整数或者浮点数。 **hash（哈希）:**一个键值对集合，可以存储多个字段。 **list（列表）:**一个简单的列表，可以存储一系列的字符串元素。 **set（集合）:**一个无序集合，可以存储不重复的字符串元素。 zset(sorted set：有序集合): 类似于集合，但是每个元素都有一个分数（score）与之关联。 位图（Bitmaps）：基于字符串类型，可以对每个位进行操作。 超日志（HyperLogLogs）：用于基数统计，可以估算集合中的唯一元素数量。 地理空间（Geospatial）：用于存储地理位置信息。 发布&#x2F;订阅（Pub&#x2F;Sub）：一种消息通信模式，允许客户端订阅消息通道，并接收发布到该通道的消息。 流（Streams）：用于消息队列和日志存储，支持消息的持久化和时间排序。 模块（Modules）：Redis 支持动态加载模块，可以扩展 Redis 的功能。 String（字符串）string 是 redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。 string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据，比如jpg图片或者序列化的对象。 string 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB。 常用命令 SET key value：设置键的值。 GET key：获取键的值。 INCR key：将键的值加 1。 DECR key：将键的值减 1。 APPEND key value：将值追加到键的值之后。 实例redis 127.0.0.1:6379&gt; SET runoob “菜鸟教程”OKredis 127.0.0.1:6379&gt; GET runoob“菜鸟教程” 在以上实例中我们使用了 Redis 的 SET 和 GET 命令。键为 runoob，对应的值为 菜鸟教程。 注意：一个键最大能存储 512MB。 Hash（哈希）Redis hash 是一个键值(key&#x3D;&gt;value)对集合，类似于一个小型的 NoSQL 数据库。 Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。 每个哈希最多可以存储 2^32 - 1 个键值对。 常用命令 HSET key field value：设置哈希表中字段的值。 HGET key field：获取哈希表中字段的值。 HGETALL key：获取哈希表中所有字段和值。 HDEL key field：删除哈希表中的一个或多个字段。 实例DEL runoob 用于删除前面测试用过的 key，不然会报错：(error) WRONGTYPE Operation against a key holding the wrong kind of value redis 127.0.0.1:6379&gt; DEL runoobredis 127.0.0.1:6379&gt; HMSET runoob field1 “Hello” field2 “World”“OK”redis 127.0.0.1:6379&gt; HGET runoob field1“Hello”redis 127.0.0.1:6379&gt; HGET runoob field2“World” 实例中我们使用了 Redis HMSET, HGET 命令，HMSET 设置了两个 field&#x3D;&gt;value 对, HGET 获取对应 field 对应的 value。 List（列表）Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。 列表最多可以存储 2^32 - 1 个元素。 常用命令 LPUSH key value：将值插入到列表头部。 RPUSH key value：将值插入到列表尾部。 LPOP key：移出并获取列表的第一个元素。 RPOP key：移出并获取列表的最后一个元素。 LRANGE key start stop：获取列表在指定范围内的元素。 实例redis 127.0.0.1:6379&gt; DEL runoobredis 127.0.0.1:6379&gt; lpush runoob redis(integer) 1redis 127.0.0.1:6379&gt; lpush runoob mongodb(integer) 2redis 127.0.0.1:6379&gt; lpush runoob rabbitmq(integer) 3redis 127.0.0.1:6379&gt; lrange runoob 0 101) “rabbitmq”2) “mongodb”3) “redis”redis 127.0.0.1:6379&gt; Set（集合）Redis 的 Set 是 string 类型的无序集合。 集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 常用命令 SADD key value：向集合添加一个或多个成员。 SREM key value：移除集合中的一个或多个成员。 SMEMBERS key：返回集合中的所有成员。 SISMEMBER key value：判断值是否是集合的成员。 sadd 命令添加一个 string 元素到 key 对应的 set 集合中，成功返回 1，如果元素已经在集合中返回 0。 sadd key member 实例redis 127.0.0.1:6379&gt; DEL runoobredis 127.0.0.1:6379&gt; sadd runoob redis(integer) 1redis 127.0.0.1:6379&gt; sadd runoob mongodb(integer) 1redis 127.0.0.1:6379&gt; sadd runoob rabbitmq(integer) 1redis 127.0.0.1:6379&gt; sadd runoob rabbitmq(integer) 0redis 127.0.0.1:6379&gt; smembers runoob 1) “redis”2) “rabbitmq”3) “mongodb” 注意：以上实例中 rabbitmq 添加了两次，但根据集合内元素的唯一性，第二次插入的元素将被忽略。 集合中最大的成员数为 232 - 1(4294967295, 每个集合可存储40多亿个成员)。 zset(sorted set：有序集合)Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。 不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。 zset的成员是唯一的,但分数(score)却可以重复。 常用命令 ZADD key score value：向有序集合添加一个或多个成员，或更新已存在成员的分数。 ZRANGE key start stop [WITHSCORES]：返回指定范围内的成员。 ZREM key value：移除有序集合中的一个或多个成员。 ZSCORE key value：返回有序集合中，成员的分数值。 zadd 命令添加元素到集合，元素在集合中存在则更新对应score zadd key score member 实例redis 127.0.0.1:6379&gt; DEL runoobredis 127.0.0.1:6379&gt; zadd runoob 0 redis(integer) 1redis 127.0.0.1:6379&gt; zadd runoob 0 mongodb(integer) 1redis 127.0.0.1:6379&gt; zadd runoob 0 rabbitmq(integer) 1redis 127.0.0.1:6379&gt; zadd runoob 0 rabbitmq(integer) 0redis 127.0.0.1:6379&gt; ZRANGEBYSCORE runoob 0 10001) “mongodb”2) “rabbitmq”3) “redis” 其他高级数据类似HyperLogLog 用于基数估计算法的数据结构。 常用于统计唯一值的近似值。 Bitmaps 位数组，可以对字符串进行位操作。 常用于实现布隆过滤器等位操作。 Geospatial Indexes 处理地理空间数据，支持地理空间索引和半径查询。 Streams* 日志数据类型，支持时间序列数据。 * 用于消息队列和实时数据处理。"},{"title":"Redis的安装","path":"/posts/590946299/","content":"Redis 安装Windows 下安装下载地址：https://github.com/tporadowski/redis/releases。 Redis 支持 32 位和 64 位。这个需要根据你系统平台的实际情况选择，这里我们下载 Redis-x64-xxx.zip压缩包到 C 盘，解压后，将文件夹重新命名为 redis。 打开文件夹，内容如下： 打开一个 cmd 窗口 使用 cd 命令切换目录到 C:\\redis 运行： redis-server.exe redis.windows.conf 如果想方便的话，可以把 redis 的路径加到系统的环境变量里，这样就省得再输路径了，后面的那个 redis.windows.conf 可以省略，如果省略，会启用默认的。输入之后，会显示如下界面： 这时候另启一个 cmd 窗口，原来的不要关闭，不然就无法访问服务端了。 切换到 redis 目录下运行: redis-cli.exe -h 127.0.0.1 -p 6379 设置键值对: set myKey abc 取出键值对: get myKey Linux 源码安装下载地址：http://redis.io/download，下载最新稳定版本。 本教程使用的最新文档版本为 2.8.17，下载并安装： # wget http://download.redis.io/releases/redis-6.0.8.tar.gz tar -xzvf redis-6.0.8.tar.gzcd redis-6.0.8make执行完 make 命令后，redis-6.0.8 的 src 目录下会出现编译后的 redis 服务程序 redis-server，还有用于测试的客户端程序 redis-cli： 下面启动 redis 服务： # cd src .&#x2F;redis-server注意这种方式启动 redis 使用的是默认配置。也可以通过启动参数告诉 redis 使用指定配置文件使用下面命令启动。 # cd src .&#x2F;redis-server ..&#x2F;redis.confredis.conf 是一个默认的配置文件。我们可以根据需要使用自己的配置文件。 启动 redis 服务进程后，就可以使用测试客户端程序 redis-cli 和 redis 服务交互了。 比如： # cd src .&#x2F;redis-cliredis&gt; set foo barOKredis&gt; get foo“bar” Ubuntu apt 命令安装在 Ubuntu 系统安装 Redis 可以使用以下命令: # sudo apt update sudo apt install redis-server启动 Redis# redis-server 查看 redis 是否启动？# redis-cli 以上命令将打开以下终端： redis 127.0.0.1:6379&gt; 127.0.0.1 是本机 IP ，6379 是 redis 服务端口。现在我们输入 PING 命令。 redis 127.0.0.1:6379&gt; pingPONG 以上说明我们已经成功安装了redis。"},{"title":"Redis从入门到入土","path":"/posts/3383901741/","content":"Redis入门到入土 学习Redis的重要性Remote Dictionary Server(Redis) 是一个由 Salvatore Sanfilippo 写的 key-value 存储系统，是跨平台的非关系型数据库。 Redis 是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存、分布式、可选持久性的键值对(Key-Value)存储数据库，并提供多种语言的 API。 Redis 通常被称为数据结构服务器，因为值（value）可以是字符串(String)、哈希(Hash)、列表(list)、集合(sets)和有序集合(sorted sets)等类型。 如今，大多数互联网公司都已经使用Redis中间件来优化他们的服务速度。那么Redis的重要信就不言而喻了。 Redis的简介Redis（Remote Dictionary Server）是一个开源的内存数据库，遵守 BSD 协议，它提供了一个高性能的键值（key-value）存储系统，常用于缓存、消息队列、会话存储等应用场景。 性能极高：Redis 以其极高的性能而著称，能够支持每秒数十万次的读写操作24。这使得Redis成为处理高并发请求的理想选择，尤其是在需要快速响应的场景中，如缓存、会话管理、排行榜等。 丰富的数据类型：Redis 不仅支持基本的键值存储，还提供了丰富的数据类型，包括字符串、列表、集合、哈希表、有序集合等。这些数据类型为开发者提供了灵活的数据操作能力，使得Redis可以适应各种不同的应用场景。 原子性操作：Redis 的所有操作都是原子性的，这意味着操作要么完全执行，要么完全不执行。这种特性对于确保数据的一致性和完整性至关重要，尤其是在高并发环境下处理事务时。 持久化：Redis 支持数据的持久化，可以将内存中的数据保存到磁盘中，以便在系统重启后恢复数据。这为 Redis 提供了数据安全性，确保数据不会因为系统故障而丢失。 支持发布&#x2F;订阅模式：Redis 内置了发布&#x2F;订阅模式（Pub&#x2F;Sub），允许客户端之间通过消息传递进行通信。这使得 Redis 可以作为消息队列和实时数据传输的平台。 单线程模型：尽管 Redis 是单线程的，但它通过高效的事件驱动模型来处理并发请求，确保了高性能和低延迟。单线程模型也简化了并发控制的复杂性。 主从复制：Redis 支持主从复制，可以通过从节点来备份数据或分担读请求，提高数据的可用性和系统的伸缩性。 应用场景广泛：Redis 被广泛应用于各种场景，包括但不限于缓存系统、会话存储、排行榜、实时分析、地理空间数据索引等。 社区支持：Redis 拥有一个活跃的开发者社区，提供了大量的文档、教程和第三方库，这为开发者提供了强大的支持和丰富的资源。 跨平台兼容性：Redis 可以在多种操作系统上运行，包括 Linux、macOS 和 Windows，这使得它能够在不同的技术栈中灵活部署。 Redis 与其他 key-value 存储有什么不同？Redis 与其他 key-value 存储系统的主要区别在于其提供了丰富的数据类型、高性能的读写能力、原子性操作、持久化机制、以及丰富的特性集。 以下是 Redis 的一些独特之处： 丰富的数据类型：Redis 不仅仅支持简单的 key-value 类型的数据，还提供了 list、set、zset（有序集合）、hash 等数据结构的存储。这些数据类型可以更好地满足特定的业务需求，使得 Redis 可以用于更广泛的应用场景。 高性能的读写能力：Redis 能读的速度是 110000次&#x2F;s，写的速度是 81000次&#x2F;s。这种高性能主要得益于 Redis 将数据存储在内存中，从而显著提高了数据的访问速度。 原子性操作：Redis 的所有操作都是原子性的，这意味着操作要么完全执行，要么完全不执行。这种特性对于确保数据的一致性和完整性非常重要。 持久化机制：Redis 支持数据的持久化，可以将内存中的数据保存在磁盘中，以便在系统重启后能够再次加载使用。这为 Redis 提供了数据安全性，确保数据不会因为系统故障而丢失。 丰富的特性集：Redis 还支持 publish&#x2F;subscribe（发布&#x2F;订阅）模式、通知、key 过期等高级特性。这些特性使得 Redis 可以用于消息队列、实时数据分析等复杂的应用场景。 主从复制和高可用性：Redis 支持 master-slave 模式的数据备份，提供了数据的备份和主从复制功能，增强了数据的可用性和容错性。 支持 Lua 脚本：Redis 支持使用 Lua 脚本来编写复杂的操作，这些脚本可以在服务器端执行，提供了更多的灵活性和强大的功能。 单线程模型：尽管 Redis 是单线程的，但它通过高效的事件驱动模型来处理并发请求，确保了高性能和低延迟。"},{"title":"Blog主题美化-sakura","path":"/posts/4114488392/","content":"sakura主题美化（本站作者前博客，已经不再使用）本站正在积极优化中，优化完成后将贴出心得优化参考链接： Mashiro.本站原作者 cungudafa.一个很厉害的小姐姐 hojun.从sakura主题魔改本站的大佬 感谢以上大佬代码的开源，枣糕也备受开源精神的感染 感谢在本站优化过程中为枣糕提供帮助的小伙伴： kang.我的好朋友兼本站优化指导 更新日志2021&#x2F;4&#x2F;24 23:58 关于-我？今日更新:“关于—我”下的botui BOTUI:一款自动回复文字、图片、视频的JS聊天机器人框架BotUI，可以自由设置多种选项、触发关键词、输入框等内容，聊天内容或范围也可以自由设置，回复内容可以是文字、图片（GIF亦可）、视频，我在博客中引用了此框架。 优化后图片:详情跳转至关于—我本次优化参考了cungudafa姐姐的教程教程链接修改了主目录\\source\\about\\index.md及sakura/js/botui.js, 具体修改内容参考cungudafa的教程链接 修改了各分类页的图片和内容框架，不过不是很满意，仍在施工中 2021&#x2F;4&#x2F;25 23:58 添加视频HEXO添加视频 添加了分类页的播放器 2021&#x2F;10&#x2F;17 22:26 给文字标题添加css动画博客搁置了好久了，今天来更新一下主题美化首先看看效果： 修改前 修改后 1.给文章标题添加css动画横线修改 themes\\Sakura\\layout\\_widget\\common-article.ejs编辑文章通用属性目录themes\\Sakura\\layout\\_widget\\common-article.ejs 找到如下部分在&lt;p class=&quot;entry-census&quot;&gt;前添加： 1&lt;span class=&quot;toppic-line&quot;&gt;&lt;/span&gt; 添加自定义CSS将添加到style.css里头的自定义 CSS 样式就好啦~直接复制下列代码粘贴到style.css 12345/*标题横线动画*/.single-center header.single-header .toppic-line&#123;position:relative;bottom:0;left:0;display:block;width:100%;height:2px;background-color:#fff;animation:lineWidth 2.5s;animation-fill-mode:forwards;&#125;@keyframes lineWidth&#123;0%&#123;width:0;&#125;100%&#123;width:100%;&#125;&#125; 2.给标题文字添加CSS动画这部分比较简单直接添加自定义css即可 添加自定义CSS 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/*标题动画*/.entry-title &#123;\t-moz-animation: fadeInUp 2s; -webkit-animation:fadeInUp 2s;\tanimation: fadeInUp 2s;&#125;@-moz-keyframes fadeInUp &#123;\t0% &#123; -moz-transform: translateY(200%); transform: translateY(200%); opacity: 0\t&#125;\t50% &#123; -moz-transform: translateY(200%); transform: translateY(200%); opacity: 0\t&#125;\t100% &#123; -moz-transform: translateY(0%); transform: translateY(0%); opacity: 1\t&#125;&#125;@-webkit-keyframes fadeInUp &#123;\t0% &#123; -webkit-transform: translateY(200%); transform: translateY(200%); opacity: 0\t&#125;\t50% &#123; -webkit-transform: translateY(200%); transform: translateY(200%); opacity: 0\t&#125;\t100% &#123; -webkit-transform: translateY(0%); transform: translateY(0%); opacity: 1\t&#125;&#125;@keyframes fadeInUp &#123;\t0% &#123; -moz-transform: translateY(200%); -ms-transform: translateY(200%); -webkit-transform: translateY(200%); transform: translateY(200%); opacity: 0\t&#125;\t50% &#123; -moz-transform: translateY(200%); -ms-transform: translateY(200%); -webkit-transform: translateY(200%); transform: translateY(200%); opacity: 0\t&#125;\t100% &#123; -moz-transform: translateY(0%); -ms-transform: translateY(0%); -webkit-transform: translateY(0%); transform: translateY(0%); opacity: 1\t&#125;&#125;"},{"title":"算法—贪婪算法之田忌赛马","path":"/posts/3615288770/","content":"贪婪算法之田忌赛马贪婪算法之田忌赛马【问题描述】中国古代的历史故事“田忌赛马”是为大家所熟知的。话说齐王和田忌又要赛马了，他们各派出N匹马，每场比赛，输的一方将要给赢的一方200两黄金，如果是平局的话，双方都不必拿出钱。现在每匹马的速度值是固定而且已知的，而齐王出马也不管田忌的出马顺序。请问田忌该如何安排自己的马去对抗齐王的马，才能赢取最多的钱？ 输入第一行为一个正整数n (n &lt;&#x3D; 2000) ，表示双方马的数量。第二行有N个整数表示田忌的马的速度。第三行的N个整数为齐王的马的速度。 输出仅有一行，为田忌赛马可能赢得的最多的钱，结果有可能为负。 输入示例392 83 7195 87 74 输出示例200 C语言的实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;stdio.h&gt;#define MAX 1000int t[MAX],w[MAX];void sort(int n,int t[])&#123;\tint i,j,temp;\tfor(i=1;i&lt;=n;i++) for(j=1;j&lt;=n-i;j++) &#123; if(t[j]&gt;t[j+1]) &#123; temp=t[j]; t[j]=t[j+1]; t[j+1]=temp; &#125; &#125;&#125;int main()&#123;\tint n;\tprintf(&quot;请输入双方赛马数量n:&quot;);\tscanf(&quot;%d&quot;,&amp;n);\tprintf(&quot;请录入田忌赛马速度:&quot;);\tfor(int i=1;i&lt;=n;i++)\t&#123; scanf(&quot;%d&quot;,&amp;t[i]);\t&#125;\tprintf(&quot;请录入齐王赛马速度:&quot;);\tfor(i=1;i&lt;=n;i++)\t&#123; scanf(&quot;%d&quot;,&amp;w[i]);\t&#125;\tsort(n,t);\tsort(n,w);\tint tj_min=1,tj_max=n,qw_min=1,qw_max=n,count=0,sum;\twhile(n--)\t&#123; if(t[tj_max]&gt;w[qw_max]) &#123; count++; tj_max--; qw_max--; &#125; else if(t[tj_max]&lt;w[qw_max]) &#123; count--; tj_min++; qw_max--; &#125; else &#123; if(t[tj_min]&gt;w[qw_min]) &#123; count++; tj_min++; qw_min++; &#125; else &#123; if(t[tj_min]&lt;w[qw_max]) count--; tj_min++; qw_max--; &#125; &#125;\t&#125;\tsum=count*200;\tprintf(&quot;最终田忌最多可以拿到%d的奖金 &quot;,sum);\treturn 0;&#125; 运行截图"},{"title":"算法—贪婪算法之背包问题","path":"/posts/3151518252/","content":"贪婪算法之背包问题算法描述设有编号为1、2、…、n的n个物品，它们的重量分别为w1、w2、…、wn，价值分别为v1、v2、…、vn，其中wi、vi（1≤i≤n）均为正数。 有一个背包可以携带的最大重量不超过W。求解目标：在不超过背包负重的前提下，使背包装入的总价值最大（即效益最大化），与0&#x2F;1背包问题的区别是，这里的每个物品可以取一部分装入背包。 C语言的实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;stdio.h&gt;#define MAX 101void sort(int n,float w[],float v[])&#123;\tint i,j;\tfloat temp1,temp2;\tfor(i=1;i&lt;=n;i++) for(j=1;j&lt;=n-i;j++) &#123; temp1=v[j]/w[j]; temp2=v[j+1]/w[j+1]; if(temp1&lt;temp2) &#123; float temp; temp=w[j]; w[j]=w[j+1]; w[j+1]=temp; temp=v[j]; v[j]=v[j+1]; v[j+1]=temp; &#125; &#125;&#125;int main()&#123;\tfloat p[MAX],w[MAX],v[MAX];\tint n;\tfloat M;\tprintf(&quot;请输入物品总数n和背包最大容纳重量M:&quot;);\tscanf(&quot;%d %f&quot;,&amp;n,&amp;M);\tfor(int i=1;i&lt;=n;i++)\t&#123; printf(&quot;请输入第%d件物品的重量和价值:&quot;,i); scanf(&quot;%f %f&quot;,&amp;w[i],&amp;v[i]);\t&#125;\tsort(n,w,v);\tfloat c=M;\tfor(i=1;i&lt;=n;i++)\t&#123; p[i]=0;\t&#125;\tfor(i=1;i&lt;=n;i++)\t&#123; if(c&gt;=w[i]) &#123; p[i]=1; c=c-w[i]; &#125; else &#123; p[i]=c/w[i]; break; &#125;\t&#125;\tfor(i=1;i&lt;=n;i++)\t&#123; printf(&quot;重量为%.0f,价值量为%.0f,的物品，放入的比例为%.2f &quot;,w[i],v[i],p[i]);\t&#125;\treturn 0;&#125; 运行截图"},{"title":"算法—动态规划算法求数塔问题","path":"/posts/213526926/","content":"动态规划算法求数塔问题算法描述【实验目的】1.掌握动态算法的思想和求解问题的步骤；2.用动态规划算法策略求解数塔问题；3.用动态规划算法策略求解收获花生问题。 【实验内容】1．动态规划算法求解数塔问题 【问题描述】数塔问题有如下图所示的一个数塔，从顶部出发，在每一结点可以选择向左走或是向右走，一直走到底层，要求找出一条路径，使路径上的数值和最大。 【算法设计】给出算法设计思想，并用动态规划算法实现。 C语言的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;stdio.h&gt;#define MAX 1000int data[MAX][MAX];int dp[MAX][MAX];int n;void tower_walk()&#123;\tfor(int i=1;i&lt;=n;i++)\t&#123; dp[n][i]=data[n][i];\t&#125;\tint temp_max;\tfor(i=n;i&gt;=1;i--)\t&#123; for(int j=1;j&lt;=i;j++) &#123; if(dp[i+1][j]&gt;dp[i+1][j+1]) temp_max=dp[i+1][j]; else if(dp[i+1][j]&lt;dp[i+1][j+1]) temp_max=dp[i+1][j+1]; else temp_max=dp[i+1][j]; //\ttemp_max=max(dp[i+1][j],dp[i+1][j+1]); dp[i][j]=temp_max+data[i][j]; &#125;\t&#125;&#125;int\tprint_tower()&#123;\tprintf(&quot;最大路径和是:%d &quot;,dp[1][1]);\tint node_value;\tprintf(&quot;最大路径是:%d&quot;,data[1][1]);\tint j=1;\tfor(int i=2;i&lt;=n;i++)\t&#123; node_value=dp[i-1][j]-data[i-1][j]; if(node_value==dp[i][j+1]) ++j; printf(&quot;--&gt;%d&quot;,data[i][j]);\t&#125;\tprintf(&quot; &quot;);\treturn 0;&#125;int main()&#123;\tprintf(&quot;请输入塔的层数n:&quot;);\tscanf(&quot;%d&quot;,&amp;n);\tprintf(&quot;请输入塔每个节点的数据(第i层有i个节点): &quot;);\tfor(int i=1;i&lt;=n;i++)\t&#123; for(int j=1;j&lt;=i;j++) &#123; scanf(&quot;%d&quot;,&amp;data[i][j]); &#125;\t&#125;\ttower_walk();\tprint_tower();\treturn 0;&#125; 运行截图"},{"title":"算法—动态规划算法求收花生问题","path":"/posts/3835304321/","content":"动态规划算法求收花生问题算法描述【问题描述】收获花生问题咚咚想摘点花生送给她喜欢的米老鼠。她来到一片有网格状道路的矩形花生地(如下图)，从西北角进去，东南角出来。地里每个道路的交叉点上都有种着一株花生苗，上面有若干颗花生，经过一株花生苗就能摘走该它上面所有的花生。咚咚只能向东或向南走，不能向西或向北走。问咚咚最多能够摘到多少颗花生。 【输入】第一行是一个整数T，代表一共有多少组数据。1&lt;&#x3D;T &lt;&#x3D; 100接下来是T组数据。每组数据的第一行是两个整数，分别代表花生苗的行数R和列数 C ( 1&lt;&#x3D; R,C &lt;&#x3D;100)每组数据的接下来R行数据，从北向南依次描述每行花生苗的情况。每行数据有 C 个整数，按从西向东的顺序描述了该行每株花生苗上的花生数目 M ( 0&lt;&#x3D; M &lt;&#x3D; 1000)。 【输出】【样例输入】22 21 13 42 32 3 41 6 5【样例输出】816 对每组输入数据，输出一行，内容为能摘到得最多的花生颗数。 【问题分析】根据题意只能向东或者向南走，不能向西或向北走。所以这道题不用判断是不是访问过，直接选取最大的经过的数来代替，然后把最后一个数输出就大功告成了。以下是具体思路图片。 【算法设计】给出算法设计思想，并用动态规划算法实现。 C语言的实现123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;#define MAX 1000int w[MAX][MAX];int f[MAX][MAX];int t,n,m;int main()&#123;\tprintf(&quot;请输入数据组数t的值:&quot;); scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; printf(&quot;请输入行数n和列数m的值:&quot;); scanf(&quot;%d %d&quot;,&amp;n,&amp;m); printf(&quot;请输入每个节点上的花生数量 &quot;); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) scanf(&quot;%d&quot;,&amp;w[i][j]); for(i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++)&#123; if(f[i-1][j]&gt;f[i][j-1]) f[i][j] = f[i-1][j]+w[i][j]; else f[i][j] = f[i][j-1]+w[i][j]; &#125; printf(&quot;可以摘到的花生的总和的最大值是:%d &quot;,f[n][m]); &#125;\treturn 0;&#125; 运行截图"},{"title":"算法—动态规划算法求最长公共子序列问题","path":"/posts/2646402340/","content":"动态规划算法求最长公共子序列问题问题描述【问题描述】字符序列的子序列是指从给定字符序列中随意地（不一定连续）去掉若干个字符（可能一个也不去掉）后所形成的字符序列。给定两个字符序列A和B，如果字符序列Z既是A的子序列，又是B的子序列，则称序列Z是A和B的公共子序列。该问题是求两序列A和B的最长公共子序列（LCS）。【问题分析】dp[i][j]为子序列（a0，a1，…，ai-1）和（b0，b1，…，bj-1）的最长公共子序列的长度。对应的状态转移方程如下： C语言的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;stdio.h&gt;#include&lt;string.h&gt;char str1[100];char str2[100];int c[100][100]; int b[100][100];void print_LCS(int lenght1, int lenght2)&#123;\tif(lenght1 == 0 || lenght2 == 0)&#123; return; &#125;\tif(b[lenght1][lenght2] == 1)&#123; print_LCS(lenght1-1,lenght2-1); printf(&quot;%c&quot;,str1[lenght1-1]); &#125; else if(b[lenght1][lenght2] == 2)&#123; print_LCS(lenght1-1,lenght2); &#125;else&#123; print_LCS(lenght1,lenght2-1); &#125; &#125;void LCS(char str1[], char str2[])&#123; int str1_lenght, str2_lenght; str1_lenght = strlen(str1); str2_lenght = strlen(str2); if(str1_lenght == 0 || str2_lenght == 0)&#123; printf(&quot;%s &quot;, &quot;No sub seqence&quot;); return;\t&#125; int i, j;\tfor(i = 0; i &lt;= str1_lenght; i++)&#123; c[i][0] = 0;\t&#125; for(j = 0; j &lt;= str2_lenght; j++)&#123; c[0][j] = 0; &#125; for(i = 1; i &lt;= str1_lenght; i++)&#123; for(j = 1; j &lt;= str2_lenght; j++)&#123; if (str1[i-1] == str2[j-1])&#123; c[i][j] = c[i-1][j-1] + 1; b[i][j] = 1; &#125; else if(c[i-1][j] &gt; c[i][j-1])&#123; c[i][j] = c[i-1][j]; b[i][j] = 2; &#125; else&#123; c[i][j] = c[i][j-1]; b[i][j] = 3; &#125; &#125; &#125; if(c[str1_lenght][str2_lenght] &lt;= 0)&#123; printf(&quot;%s &quot;,&quot;No sub squence&quot;); return; &#125; printf(&quot;size = %d &quot;, c[str1_lenght][str2_lenght]); print_LCS(str1_lenght,str2_lenght); printf(&quot; &quot;);&#125;int main()&#123; printf(&quot;请输入第一个字符串:&quot;); scanf(&quot;%s&quot;, str1); printf(&quot;请输入第二个字符串:&quot;); scanf(&quot;%s&quot;, str2); LCS(str1,str2); return 0;&#125; 运行截图"},{"title":"算法—动态规划算法求最大子段和","path":"/posts/1148179130/","content":"动态规划算法求最大子段和问题描述【问题描述】给定由n个整数组成的序列a1,a2,…,an，求该序列子段和的最大值。当所有整数均为负值时定义其最大子段和为0。依此定义， 例如， 当(a1,a2, a3, a4, a5,a6)&#x3D;(-2, 11, -4, 13, -5, -2)时，最大子段和为20。【问题分析】 【算法设计】给出算法设计思想，并用动态规划算法实现。 C语言的实现1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;#define MAX 100int a[MAX]; int MaxSum(int a[],int n)&#123;\tint temp = 0;\tint maxsum = 0;\tfor(int i=1;i&lt;=n;i++)&#123; if(temp&lt;0) temp=a[i]; else temp=temp+a[i]; if(temp &gt; maxsum)&#123; maxsum = temp; &#125;\t&#125;\treturn maxsum;\t&#125;int main()&#123;\tint n;\tprintf(&quot;请输入n的值:&quot;);\tscanf(&quot;%d&quot;,&amp;n);\tprintf(&quot;请依次输入元素:&quot;);\tfor(int i=1;i&lt;=n;i++)&#123; scanf(&quot;%d&quot;,&amp;a[i]);\t&#125;\tprintf(&quot;最大子段和为:%d &quot;,MaxSum(a,n)); return 0;&#125; 运行截图"},{"title":"算法—回溯法求解01背包问题","path":"/posts/4146540002/","content":"回溯法求解01背包问题算法描述【问题描述】有n个重量分别为{w1，w2，…，wn}的物品，它们的价值分别为{v1，v2，…，vn}，给定一个容量为W的背包。设计从这些物品中选取一部分物品放入该背包的方案，每个物品要么选中要么不选中，要求选中的物品不仅能够放到背包中，而且满足重量限制具有最大的价值。 C语言实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;stdio.h&gt;float w[100],p[100];int x1[100],x[100],m,n;float max=0,total=0;int knap(int i)&#123;\tint j;\tfloat sum=0;\tif(i==n+1)\t&#123; for(j=1;j&lt;=n;j++) sum=sum+x1[j]*p[j]; if(sum&gt;max) &#123; max=sum; for(j=1;j&lt;=n;j++) x[j]=x1[j]; &#125; return 0;\t&#125;\tx1[i]=0;\tknap(i+1);\tif(total+w[i]&lt;=m)\t&#123; x1[i]=1; total=total+w[i]; knap(i+1); x1[i]=0; total=total-w[i];\t&#125;\treturn 0;&#125;int main()&#123;\tint s=0,sum=0,i;\tprintf(&quot;请输入背包的总容量m和物品件数n的值:&quot;);\tscanf(&quot;%d %d&quot;,&amp;m,&amp;n);\tfor(i=1;i&lt;=n;i++)\t&#123; printf(&quot;请输入第%d件物品的重量和价值:&quot;,i); scanf(&quot;%f %f&quot;,&amp;w[i],&amp;p[i]); s+=w[i]; sum+=p[i];\t&#125;\tif(s&lt;=m)\t&#123; printf(&quot;%d %d&quot;,m,sum); printf(&quot;最大价值为%d&quot;,sum); return 0;\t&#125;\telse knap(1);\tfor(i=1;i&lt;=n;i++) printf(&quot;x%d=%d &quot;,i+1,x[i]);\tprintf(&quot;最大价值为%.2f&quot;, max);\treturn 0;&#125; 运行截图"},{"title":"算法—回溯法求解七巧板涂色问题","path":"/posts/4151911364/","content":"回溯法求解七巧板涂色问题算法描述【问题描述】有如图所示的七巧板，试编写一源程序如下，使用至多四种不同颜色对七巧板进行涂色(每块涂一种颜色)，要求相邻区域的颜色互不相同，打印输出所有可能的涂色方案。【问题分析】为了让算法能识别不同区域间的相邻关 系，我们把七巧板上每一个区域看成一个顶点若两个区域相邻，则相应的顶点间用一条边相连，这样该问题就转化为图一个图的搜索问题了。 C语言实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;int m, pointnum, edgenum, sum = 0;int Graph[100][100], x[100];void InPut() &#123; int pos1, pos2; printf(&quot;请输入点的个数和色数(p m)：&quot;); scanf(&quot;%d%d&quot;,&amp;pointnum,&amp;m); printf(&quot;请输入边的个数: &quot;); scanf(&quot;%d&quot;,&amp;edgenum); printf(&quot;输入边的起始点信息(起点 终点)： &quot;); for(int i = 1; i &lt;= edgenum; ++i) &#123; scanf(&quot;%d%d&quot;,&amp;pos1,&amp;pos2); Graph[pos1][pos2] = Graph[pos2][pos1] = 1; &#125;&#125;int IsOk(int i) &#123; for(int j = 1; j &lt; i; ++j) if(Graph[i][j] == 1 &amp;&amp; x[j] == x[i]) return 0; return 1;&#125;void BackTrack(int i) &#123; if(i &gt; pointnum) &#123; sum += 1; printf(&quot;方法 %d:&quot;,sum); for(int j = 1; j &lt;= pointnum; ++j) &#123; printf(&quot; %d&quot;,x[j]); &#125; printf(&quot; &quot;); &#125; else &#123; for(int j = 1; j &lt;= m; ++j) &#123; x[i] = j; if(IsOk(i)) BackTrack(i + 1); x[i] = 0; &#125; &#125;&#125;int main() &#123; InPut(); BackTrack(1); printf(&quot;一共有%d种绘色方案&quot;,sum);&#125; 运行截图"},{"title":"算法—矩阵最长滑翔路径","path":"/posts/2945491289/","content":"算法——矩阵最长滑翔路径算法描述【问题描述】在一个C行R列的矩阵M中，其元素M[i][j]可以滑翔到相邻的上下左右的四个元素中的一个(当然不能超出矩阵的边界)，当且仅当相邻的元素比它要小，因为只能从高处滑翔到低处，每滑翔到一个元素，路径长度加1，现在要求你编程计算该矩阵中最长的滑翔路径长度是多少。要求输入矩阵的行列数和各元素的值，计算输出该矩阵中最长的滑翔路径长度。并给出路径。【输入样例】5 51 2 3 4 516 17 18 19 615 24 25 20 714 23 22 21 813 12 11 10 9【输出样例】2525 24……1 C语言实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;stdio.h&gt;#include&lt;string.h&gt;int G[100][100],len[100][100],have[100][100];int n,m,mov[2][4]=&#123;0,0,1,-1,1,-1,0,0&#125;;bool bound(int p,int q) &#123; return p&gt;n||p&lt;1||q&gt;m||q&lt;1;&#125;int DFS(int p,int q)&#123; if(have[p][q]) return len[p][q]; int ans=1; for(int i=0;i&lt;4;i++) &#123; int np=p+mov[0][i],nq=q+mov[1][i]; if(bound(np,nq)) continue; if(G[p][q]&gt;G[np][nq])&#123; if(ans&gt;DFS(np,nq)+1) ans=ans; else &#123; ans=DFS(np,nq)+1; &#125; &#125; &#125; len[p][q]=ans; have[p][q]=1; return ans; &#125;int main()&#123;\tint i,j,maxi,maxj;\tprintf(&quot;请输入行列数(用空格分隔): &quot;); scanf(&quot;%d %d&quot;,&amp;n,&amp;m);\tG[0][0]=0;\tprintf(&quot;请输入矩阵的值: &quot;); for(i=1;i&lt;=n;i++) for(j=1;j&lt;=m;j++) &#123; scanf(&quot;%d&quot;,&amp;G[i][j]); have[i][j]=0; &#125; int ans=0; for(i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) &#123; len[i][j]=DFS(i,j); if(ans&gt;len[i][j]) ans=ans; else &#123; ans=len[i][j]; maxi=i; maxj=j; &#125; &#125; printf(&quot;最长滑翔长度是%d &quot;,ans);\tfor(i=ans;i&gt;1;i--) printf(&quot;%d-&quot;,i);\tprintf(&quot;1&quot;); return 0;&#125; 运行截图"},{"title":"Mysql基础命令","path":"/posts/4265605807/","content":"mysql基基础——常用命令一、MySQL——常用命令1、创建数据库（Create）12345678mysql&gt; create database db_name; -- 创建数据库mysql&gt; show databases; -- 显示所有的数据库mysql&gt; drop database db_name; -- 删除数据库mysql&gt; use db_name; -- 选择数据库mysql&gt; create table tb_name (字段名 varchar(20), 字段名 char(1)); -- 创建数据表模板mysql&gt; show tables; -- 显示数据表mysql&gt; desc tb_name； -- 显示表结构mysql&gt; drop table tb_name； -- 删除表 例如：创建学生表 1234567create table Student( Sno char(10) primary key, Sname char(20) unique, Ssex char(2), Sage smallint, Sdept char(20))； 2、插入数据（Insert）insert into 语句用于向表格中插入新的行: 1234/*第一种形式无需指定要插入数据的列名，只需提供被插入的值即可：*/mysql&gt; insert into tb_name values (value1,value2,value3,...);/*第二种形式需要指定列名及被插入的值：*/mysql&gt; insert into tb_name (column1,column2,column3,...) values (value1,value2,value3,...); 例如：插入数据 1234mysql&gt; insert into Student values ( 20180001,张三,男,20,CS）;mysql&gt; insert into Student values ( 20180002,李四,男,19,CS）;mysql&gt; insert into Student (Sno,Sname,Ssex,Sage,Sdept) values ( 20180003,王五,男,18,MA）;mysql&gt; insert into Student (Sno,Sname,Ssex,Sage,Sdept) values ( 20180004,赵六,男,20,IS）; 3、查询数据（Select）select语句除了可以查看数据库中的表格和视图的信息外,还可以查看 SQL Server的系统信息、复制、创建数据表。其查询功能强大，是SQL语言的灵魂语句，也是SQL中使用频率最高的语句。 基本select语句：一个基本的select语句可分解成三个部分：查找什么数据（select）、从哪里查找（from）、查找的条件是什么（where）。 select 语句的一般格式如下： 1234567select &lt;目标列表达式列表&gt;[into 新表名]from 表名或视图名[where &lt;条件&gt;][group by &lt;分组表达式&gt;][having &lt;条件&gt;][order by &lt;排序表达式&gt;[ASC|DESC]] (一)查询指定的列1.查询表中所有列在select语句指定列的位置上使用*号时，表示查询表的所有列。 1select * from tb_name 2.查询表中指定的列查询多列时，列名之间要用逗号隔开。 1select tb_name.&lt;字符型字段&gt;,&lt;字符型字段&gt;... from tb_name; 3.指定查询结果中的列标题通过指定列标题（也叫列别名）可使输出结果更容易被人理解。指定列标题时，可在列名之后使用AS子句；也可使用:列别名&#x3D;&lt;表达式&gt;的形式指定列标题。 AS子句的格式为：列名或计算表达式 [AS] 列标题 1select &lt;字符型字段&gt; as 列标题1,&lt;字符型字段&gt; as 列标题2, &lt;字符型字段&gt; as 列标题3 from bt_name； 4.查询经过计算的列（即表达式的值）使用select对列进行查询时，不仅可以直接以列的原始值作为结果，而且还可以将列值进行计算后所得值作为查询结果，即select子句可以查询表达式的值,表达式可由列名、常量及算术运算符组成。查询结果计算列显示“无列名”,一般要给计算列加列标题。其中：表达式中可以使用的运算符有：加+、减-、乘*、除&#x2F;、取余% 1select &lt;字符型字段&gt;,&lt;字符型字段&gt;,列标题 = &lt;字符型字段&gt; * n from tb_name； (二)选择行：选择表中的部分行或全部行作为查询的结果1select [all|distinct] [top n[percent]]&lt;目标列表达式列表&gt; from 表名 1. 消除查询结果中的重复行对于关系数据库来说，表中的每一行都必须是不同的(即无重复行)。但当对表进行查询时若只选择其中的某些列，查询结果中就可能会出现重复行。在select语句中使用distinct关键字可以消除结果集中的重复行 1select distinct &lt;字符型字段&gt;[,&lt;字符型字段&gt;,...] from tb_name； 2. 限制查询结果中的返回行数使用top选项可限制查询结果的返回行数，即返回指定个数的记录数。其中：n是一个正整数，表示返回查询结果集的前n行；若带percent关键字，则表示返回结果集的前n%行。 12celect top n from tb_name; /*查询前 n 的数据*/celect top n percent from tb_name; /*查询前 n% tb_name的数据*/ (三)查询满足条件的行: 用where子句实现条件查询通过where子句实现,该子句必须紧跟在From子句之后 1select [all|distinct] [top n[percent]]&lt;目标列表达式列表&gt; from 表名 where &lt;条件&gt;； 说明：在查询条件中可使用以下运算符或表达式运算符 运算符标识比较运算符 &lt;&#x3D;，&lt;，&#x3D;，&gt;，&gt;&#x3D;，!&#x3D;，&lt;&gt;，!&gt;，!&lt;范围运算符 between… and，not between… and列举运算符 in，not in模糊匹配运算符 like，not like空值运算符 is null，is not null逻辑运算符 and，or，not 1.使用比较运算符1select * from tb_name where &lt;字符型字段&gt; &gt;=n; 2.指定范围用于指定范围的关键字有两个：between…and和 not between…and。 1select * from tb_name where [not] between &lt;表达式1&gt; and &lt;表达式2&gt;; 其中：between关键字之后的是范围的下限（即低值）,and关键字之后的是范围的上限（即高值）用于查找字段值在（或不在）指定范围的行。 3.使用列举使用in关键字可以指定一个值的集合，集合中列出所有可能的值，当表达式的值与集合中的任一元素个匹配时，即返回true，否则返回false。 1select * from tb_name where &lt;字符型字段&gt; [not] in(值1,值2,...,值n); 4.使用通配符进行模糊查询可用like 子句进行字符串的模糊匹配查询，like子句将返回逻辑值（true或False）。like子句的格式： select * from tb_name where &lt;字符型字段&gt; [not] like &lt;匹配串&gt;；其含义是：查找指定字段值与匹配串相匹配的记录。匹配串中通常含有通配符%和_（下划线）。其中: %：代表任意长度（包括0）的字符串 5.使用null的查询当需要判定一个表达式的值是否为空值时，使用 is null关键字。当不使用not时，若表达式的值为空值，则返回true，否则返回false；当使用not时，结果刚好相反。 1select * from tb_name where &lt;字符型字段&gt; is [not] null; 6.多重条件查询(使用逻辑运算符)逻辑运算符and（与：两个条件都要满足）和or（或：满足其中一个条件即可）可用来联接多个查询条件。and的优先级高于or,但若使用括号可以改变优先级。 1select * from tb_name where &lt;字符型字段&gt; = &#x27;volues&#x27; and &lt;字符型字段&gt; &gt; n; (四)对查询结果排序order by子句可用于对查询结果按照一个或多个字段的值（或表达式的值）进行升序（ASC）或降序（DESC）排列，默认为升序。 1order by &#123;排序表达式[ASC|DESC]&#125;[,...n]； 其中：排序表达式既可以是单个的一个字段，也可以是由字段、函数、常量等组成的表达式，或一个正整数。模板：select * from tb_name order by &lt;排序表达式&gt; &lt;排序方法&gt;； (五)使用统计函数(又称集函数，聚合函数)在对表进行检索时，经常需要对结果进行计算或统计，T-SQL提供了一些统计函数（也称集函数或聚合函数），用来增强检索功能。统计函数用于计算表中的数据，即利用这些函数对一组数据进行计算，并返回单一的值。常用统计函数表 函数名 功能 AVG 求平均值 count 求记录个数，返回int类型整数 max 求最大值 min 求最小值 sum 求和 1. SUM和AVG功能：求指定的数值型表达式的和或平均值。 1select avg(&lt;字符型字段&gt;) as 平均数,sum(&lt;字符型字段&gt;) as 总数 from tb_name where &lt;字符型字段&gt; =&#x27;字符串&#x27;; 2. Max和Min功能：求指定表达式的最大值或最小值。 1select max(&lt;字符型字段&gt;) as 最大值,min(&lt;字符型字段&gt;) as 最小值 from tb_name; 3. count该函数有两种格式：count(_)和count([all]|[distinct] 字段名），为避免出错，查询记录个数一般使用count(_)，而查询某字段有几种取值用count(distinct 字段名）。 (1).count(*):功能：统计记录总数。 1select count(*) as 总数 from tb_name; (2).count([all]|[distinct] 字段名）功能：统计指定字段值不为空的记录个数，字段的数据类型可以是text、image、ntext、uniqueidentifier之外的任何类型。 1select count(&lt;字符型字段&gt;) as 总数 from tb_name; (六)对查询结果分组group by子句用于将查询结果表按某一列或多列值进行分组，列值相等的为一组，每组统计出一个结果。该子句常与统计函数一起使用进行分组统计。 1group by 分组字段[,...n][having &lt;条件表达式&gt;]； 1.在使用group by子句后select列表中只能包含：group by子句中所指定的分组字段及统计函数。 2.having子句的用法having子句必须与group by 子句配合使用，用于对分组后的结果进行筛选（筛选条件中常含有统计函数）。 3. 分组查询时不含统计函数的条件通常使用where子句；含有统计函数的条件,则只能用having子句。 1select &lt;字符型字段&gt;,count(*) as 列标题 from tb_name where &lt;字符型字段&gt;=&#x27;字符串&#x27; group by &lt;字符型字段&gt;； 4、修改数据(Update）Update 语句用于修改表中的数据。 1update tb_name set 列名称 = 新值 where 列名称 = 某值； 5、删除数据(Delete)删除单行 1delete from tb_name where 列名称 = 某值； 删除所有行可以在不删除表的情况下删除所有的行。这意味着表的结构、属性和索引都是完整的： 1delete * from tb_name 或 delete from tb_name； 二、MySQL——alter命令alter add命令用来增加表的字段。alter add命令格式：alter table 表名 add字段 类型 其他; 例如，在表MyClass中添加了一个字段passtest，类型为int(4)，默认值为0： 1mysql&gt; alter table MyClass add passtest int(4) default &#x27;0&#x27;; 添加两个字段 1mysql&gt; alter table Person add age int,add address varchar(11); 删除两个字段 1mysql&gt; alter table Person drop column age,drop column address; 修改字段的注释 1mysql&gt; alter table `student` modify column `id` comment &#x27;学号&#x27;; 1)加索引mysql&gt; alter table 表名 add index 索引名 (字段名1[，字段名2 …]); 1mysql&gt; alter table employee add index emp_name (name); 2)加主关键字的索引mysql&gt; alter table 表名 add primary key (字段名); 1mysql&gt; alter table employee add primary key(id); 3)加唯一限制条件的索引mysql&gt; alter table 表名 add unique 索引名 (字段名); 1mysql&gt; alter table employee add unique emp_name2(cardnumber); 4)删除某个索引mysql&gt; alter table 表名 drop index 索引名; 1mysql&gt;alter table employee drop index emp_name; 5)添加字段1mysql&gt; ALTER TABLE table_name ADD field_name field_type; 6)修改原字段名称及类型1mysql&gt; ALTER TABLE table_name CHANGE old_field_name new_field_name field_type; 7)删除字段1MySQL ALTER TABLE table_name DROP field_name; 三、MySQL – 应用学生-课程数据库 学生表：Student（Sno，Sname，Ssex，Sage，Sdept） 课程表：Course（Cno，Cname，Cpno，Ccredit） 学生选课表：SC（Sno，Cno，Grade） 关系的主码加下划线表示。各个表中的数据示例如图所示： 一、建立一个“学生”表Student1234567create table Student( Sno char(9) peimary key, /*列级完整性约束条件，Sno是主码*/ Sname char(20) unique, /* Sname取唯一值*/ Ssex char(2), Sage smallint, Sdept char(20)); 二、建立一个“课程”表Course1234567create table Course( Sno char(4) primary key, /*列级完整性约束条件，Cname不能取空值*/ Sname char(40) not null, /*Cpno的含义是先修课*/ Cpno char(4) Ccredit smallint, foreign key (Cpnoo) references Course(Cno) /*表级完整性约束条件，Cpno是外码，被参照表是Course，被参照列是Cno*/); 三、建立学生选课表SC12345678create table SC( Sno char(9), Cno char(4), Grade smallint, frimary key (Sno,Cno), /*主码由两个属性构成，必须作为表级完整性进行定义*/ foreign key (Sno) references Student(Sno), /*表级完整性约束条件，Sno是外码，被参照表是Student*/ foreign key (Cno) references Course(Cno) /*表级完整性约束条件，Cno是外码，被参照表是Course */); 本文转载于MySQL基础 — 常用命令"},{"title":"算法—加法接力赛","path":"/posts/2038932490/","content":"算法—加法接力赛算法描述【问题描述】正在上一年级的小卡卡最近开始学习数的加法运算，一天老师为了测试大家对加法的掌握情况，让同学们做了一个有趣的加法接力赛游戏。老师在黑板上从左到右写下了n个大于零的整数，老师接下来找出n个同学完成下面的计算任务。第一个同学在黑板上抄下最左边的数字，第二个同学负责将第一个同学写下的数字，加上老师写下的左边第二个数字所得到的数写在了黑板上。以此类推，第m个同学将前面第m-1个同学所写下的数字加上老师在黑板上写下的从左边数的第m个数字所得之和，并将结果写到黑板上。当计算完成这n个数字之后，老师又让同学从最右边开始按相同的方法再次计算出n个数值。最后老师让同学们找出这所有数字当中共有多少个是相同的。例如：老师在黑板上写下了7个数，从左到右依次为：3，6，2，1，4，5，2，则同学们第一次从左边开始计算所得到的7个数值应该是：3，9，11，12，16，21，23；而第二次从右边开始计算所得到的7个数值应该是：2，7，11，12，14，20，23；于是第一次与第二次计算出的数值中相同的有3个，它们分别是：11、12与23。【输入】共两行，第一行为n（1&lt;n&lt;100），第二行为n个数，用空格隔开， 每个数的大小在0～200之间。 【输出】第一次与第二次计算出的数值中相同的个数。【输入样例】73 6 2 1 4 5 2【输出样例】3 C语言的实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;stdio.h&gt;#define MAX 100int a[MAX],sum[MAX],sum1[MAX],same[MAX];int i,j,k,n,s,t;void try1()&#123;\tfor(i=1;i&lt;=n;i++) same[i]=0;\tfor(i=1;i&lt;=n;i++)&#123; for(j=1;j&lt;=n;j++)&#123; if(sum[i]==sum1[j]) same[i]=sum[i]; &#125;\t&#125;\tt=0;\tfor(i=1;i&lt;=n;i++)&#123; if(same[i]!=0)&#123; t++; printf(&quot;%d &quot;,same[i]); &#125;\t&#125;\tprintf(&quot; &quot;);\tprintf(&quot;共%d个数相同 &quot;,t);&#125;int main()&#123;\ta[0]=0;\tprintf(&quot;请输入数字总量n:&quot;);\tscanf(&quot;%d&quot;,&amp;n);\tprintf(&quot;请从左到右录入数字(以空格分隔):&quot;);\tfor(i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);\tprintf(&quot;第一次运行: &quot;);\ts=0;\tfor(i=0;i&lt;n;i++)&#123; sum[i+1]=s+a[i+1]; s=sum[i+1];\t&#125;\tfor(i=1;i&lt;=n;i++) printf(&quot;%d &quot;,sum[i]);\tprintf(&quot; 第二次运行: &quot;);\ts=0;\tfor(i=n;i&gt;0;i--)&#123; sum1[n-i+1]=s+a[i]; s=sum1[n-i+1];\t&#125;\tfor(i=1;i&lt;=n;i++) printf(&quot;%d &quot;,sum1[i]);\tprintf(&quot; &quot;);\ttry1();\treturn 0;&#125; 运行截图"},{"title":"算法—矩阵连乘","path":"/posts/502788320/","content":"算法—矩阵连乘算法描述【问题描述】给定n个矩阵{A1,A2,…,An}，其中Ai与Ai+1是可乘的，i&#x3D;1,2…,n-1。现在需要研究的问题是如何确定矩阵连乘积的计算次序，使得计算矩阵连乘所需的乘法次数最少。矩阵连乘问题满足结合律, 其计算次序可以用加括号的方式确定，若矩阵连乘已完全加括号，则其计算次序完全确定。例如，有四个矩阵A,B,C,D，它们的维数分别是：A&#x3D;50×10，B&#x3D;10×40, C&#x3D;40×30, D&#x3D;30×5。ABCD矩阵连乘共有五种完全加括号的方式，计算次序和乘法次数如下：(A((BC)D)) 16000 (A(B(CD))) 10500((AB)(CD)) 36000 (((AB)C)D) 87500((A(BC))D) 34500可见不同的计算次序会导致不同的计算代价，我们要做的就是让计算代价最小。【输入】第1行输入连乘矩阵的个数n，第2行依次输入连乘矩阵的大小。【输出】输出包括两行，第1行输出最小的计算量，第2行输出矩阵连乘完全加括号的形式。【输入样例1】450 10 40 30 5【输出样例1】1050(A1) 【输入样例2】35 6 3 4【输出样例2】150((A[1]A[2])A[3]) C语言实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;stdio.h&gt;int N;int p[100],m[100][100],s[100][100];int MatrixChain(int *p,int n)&#123; for(int i=1;i&lt;=n;i++) m[i][i]=0; for(int r=2;r&lt;=n;r++)&#123; for(int i=1;i&lt;=n-r+1;i++)&#123; int j=i+(r-1); m[i][j]=m[i][i]+m[i+1][j]+p[i-1]*p[i]*p[j]; s[i][j]=i; for(int k=i+1;k&lt;j;k++)&#123; int t=m[i][k]+m[k+1][j]+p[i-1]*p[k]*p[j]; if(t&lt;m[i][j])&#123; m[i][j]=t; s[i][j]=k; &#125; &#125; &#125; &#125;\treturn 0;&#125;void Traceback(int i,int j)&#123; if(i==j) &#123; printf(&quot;A%d&quot;,i); &#125; else &#123; printf(&quot;(&quot;); Traceback(i,s[i][j]); Traceback(s[i][j]+1,j); printf(&quot;)&quot;); &#125;&#125;int main()&#123;\tprintf(&quot;请输入矩阵数量:&quot;);\tscanf(&quot;%d&quot;,&amp;N);\tN=N+1;\tprintf(&quot;请输入各矩阵纬度(用空格分隔):&quot;);\tfor(int i=0;i&lt;N;i++) scanf(&quot;%d&quot;,&amp;p[i]);\tMatrixChain(p,N-1); Traceback(1,N-1);\tprintf(&quot; &quot;);\treturn 0;&#125; 运行截图运行截图示例1运行截图示例2"},{"title":"算法—马拦过河卒","path":"/posts/3422505860/","content":"算法—马拦过河卒算法描述【题目描述】棋盘上A点有一个过河卒，需要走到目标B点。卒行走的规则：可以向下、或者向右。同时在棋盘上的某一点有一个对方的马（如C点），该马所在的点和所有跳跃一步可达的点称为对方马的控制点，如图中的C点和P1，……，P8，卒不能通过对方马的控制点。棋盘用坐标表示，A点(0,0)、B点(n, m) (n,m为不超过20的整数),同样马的位置坐标是需要给出的，C≠A且C≠B。现在要求你计算出卒从A点能够到达B点的路径的条数。（假设马的位置是固定不动的，并不是卒走一步马走一步。）【输入】给出n、m和C点的坐标。【输出】从A点能够到达B点的路径的条数。【输入样例】8 6 0 4【输出样例】1617 C语言实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt; int mmp[20][20];int vis[20][20];int step;int ma[9][2]=&#123;0,0,1,2,1,-2,-1,2,-1,-2,2,1,2,-1,-2,1,-2,-1&#125;;int n,m;int b,c; void bfs(int x,int y)&#123; if(x==n&amp;&amp;y==m) step++; int next[2][2]=&#123;1,0,0,1&#125;; int i; int dx,dy; for(i=0;i&lt;2;i++) &#123; dx=x+next[i][1]; dy=y+next[i][0]; if(dx&lt;0||dx&gt;n||dy&lt;0||dy&gt;m) continue; if(!vis[dx][dy]&amp;&amp;mmp[dx][dy]==0) &#123; vis[dx][dy]=1; bfs(dx,dy); //回溯 vis[dx][dy]=0;\t//回溯前清场 &#125; &#125;&#125;int main()&#123; int i; int dx,dy;\tprintf(&quot;请输入目标B点坐标和马的坐标C:&quot;); scanf(&quot;%d %d %d %d&quot;,&amp;n,&amp;m,&amp;b,&amp;c) ; memset(vis,0,sizeof(vis)); memset(mmp,0,sizeof(mmp)); for(i=0;i&lt;=8;i++) &#123; dx=b+ma[i][0]; dy=c+ma[i][1]; if(dx&lt;0||dx&gt;n||dy&lt;0||dy&gt;m) continue; else mmp[dx][dy]=1; &#125; vis[0][0]=1; bfs(0,0);\tprintf(&quot;从A到B的路径数为:&quot;); printf(&quot;%d &quot;,step); return 0;&#125; 运行截图"},{"title":"算法—加密字符串相似度计算","path":"/posts/2083461370/","content":"加密字符串相似度计算算法描述【问题描述】现有4个加密的字符串(中间不含空格)，需要分析研究它们的相似度，两个字符串的相似度用其最长公共子系列的长度表示，例如，字符串“ABDECFG”和字符串“ADCGEFA”的一个最长公共子序列为 “ADEF”，所以这两个字符串的相似度为4。现在需要对输入的4个字符串，分别计算它们的相似度，找出相似度最高的一对字符串，若存在多对相似度最高的字符串，应全部输出。【输入】 分4行输入4个字符串。【输出】 按行依次输出相似度最高的一对字符串、它们的相似度、对应的最长公共子序列，若有多组最高相似度相同，应全部输出。【输入样例】ABDECFEBADCEBGHADCFEBBECEBFBD【输出样例】ABDECFEB ADCFEB 6 ADCFEB 输出样例说明：以上4个字符串，共可以构成6组，依次计算它们的相似度如果，因此，相似度最高的是字符串ABDECFEB和ADCFEB，相似度为6，对应的一个最长公共子序列为ADCFEB。ABDECFEB ADCEBGH 5 ADCEBABDECFEB ADCFEB 6 ADCFEBABDECFEB BECEBFBD 5 BECFBADCEBGH ADCFEB 5 ADCEBADCEBGH BECEBFBD 3 CEBADCFEB BECEBFBD 3 CFB C语言实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/*动态规划算法加递归时间复杂度为n方*/#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define MAXLEN 100char s[MAXLEN][MAXLEN];int len[MAXLEN],b[MAXLEN][MAXLEN],c[MAXLEN][MAXLEN];void LCSLength(char *x, char *y, int m, int n, int c[][MAXLEN], int b[][MAXLEN])&#123; int i, j; for (i=0; i&lt;=m;i++) c[i][0]=0; for (j=1; j&lt;=n;j++) c[0][j]=0; for (i=1;i&lt;=m;i++) for (j=1;j&lt;=n;j++) &#123;if (x[i-1]==y[j-1]) &#123;c[i][j]=c[i-1][j-1]+1; b[i][j]=0; &#125; else if(c[i-1][j]&gt;=c[i][j-1]) &#123;c[i][j]=c[i-1][j]; b[i][j]=1; &#125; else &#123;c[i][j]=c[i][j-1]; b[i][j]=-1; &#125; &#125;&#125;void PrintLCS(int b[][MAXLEN], char *x, int i, int j)&#123; if (i==0||j==0) return; if (b[i][j]==0) &#123; PrintLCS(b,x,i-1,j-1); printf(&quot;%c&quot;,x[i-1]); &#125; else if(b[i][j]==1) PrintLCS(b,x,i-1,j); else PrintLCS(b,x,i,j-1);&#125;int main()&#123; printf(&quot;输入: &quot;); for(int i=0;i&lt;4;i++) scanf(&quot;%s&quot;,&amp;s[i]); //为字符串数组s[]赋初值 for(i=0;i&lt;4;i++) len[i]=strlen(s[i]); int maxn=c[len[0]][len[0]]; //c是记录最长公共子序列长度的数组 for(i=0;i&lt;4;i++) for(int j=i+1;j&lt;4;j++) &#123; LCSLength(s[i],s[j],len[i], len[j], c, b); maxn=(maxn&gt;c[len[i]][len[j]])?maxn:c[len[i]][len[j]];//获取公共位数最大值 &#125; printf(&quot;输出：&quot;); for(i=0;i&lt;4;i++) for(int j=i+1;j&lt;4;j++) &#123; LCSLength(s[i], s[j],len[i], len[j], c, b); if(maxn==c[len[i]][len[j]]) &#123; printf(&quot;%s &quot;,s[i]); printf(&quot;%s &quot;,s[j]); printf(&quot;%d &quot;, c[len[i]][len[j]]);//打印公共位数 PrintLCS(b, s[i], len[i], len[j]);//打印子序列 printf(&quot; &quot;); &#125; &#125; return 0;&#125; 运行截图"},{"title":"算法—数字地图","path":"/posts/3256024956/","content":"数字地图算法描述【问题描述】Jacky在网上发布了通过无人机航拍的某海域的地图，该海域有很多岛屿，为了能更好地分析该区域的航拍地图，地图被数字化为0到9组成矩阵,0表示该位置为大海，数字1到9都表示陆地(海拔不同)，假设在地图坐标m[x][y]处降落，现在要统计降落所在岛屿的面积（有多少个方格），降落点上下左右相连接的陆地为同一岛屿。例如，在如下4行4列的数字化地图中，降落点坐标为(3,3)，则所在岛屿的面积为9 。5 1 0 07 9 1 00 0 7 30 0 4 9 【输入】第1行为两整数m,n(m行，n列)，表示数字化地图m行n列，第2行输入降落地点的坐标x,y，再后面接着输入m行n列的矩阵。【输出】只有1行，为降落点所在岛屿的面积。【输入样例】4 43 35 1 0 02 6 2 00 0 1 90 0 7 5【输出样例】9 C语言实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/*回溯法——深度优先搜索时间复杂度为n方*/#include &lt;stdio.h&gt;#define max 1000int map[max][max];int vis[max][max];//记录i,j位置是否遍历过int m,n,x,y,num=0; int dfs(int x,int y)&#123; //深度优先算法 int i,nx,ny; int dx[4]=&#123;1,0,-1,0&#125;; int dy[4]=&#123;0,1,0,-1&#125;; for (i=0;i&lt;4;i++) &#123; nx=x+dx[i]; ny=y+dy[i]; if (nx&gt;=0 &amp;&amp; nx&lt;m &amp;&amp; ny&gt;=0 &amp;&amp; ny&lt;n &amp;&amp; map[nx][ny]!=0 &amp;&amp; vis[nx][ny]==0)&#123; vis[nx][ny]=1; if(map[nx][ny]!=map[x][y]) &#123; num++;&#125; dfs(nx,ny);//递归 &#125; else continue; &#125; return num;&#125;int main() &#123; int i,j,max1;\tnum=0;\tprintf(&quot;请输入岛的大小(m*n):&quot;); scanf(&quot;%d %d&quot;,&amp;m,&amp;n);\tprintf(&quot;请输入落地点(x*y):&quot;); scanf(&quot;%d %d&quot;,&amp;x,&amp;y);\tfor(i=0;i&lt;m;i++) for(j=0;j&lt;n;j++)&#123; scanf(&quot;%d&quot;,&amp;map[i][j]); &#125;\tfor(i=0;i&lt;m;i++) for(j=0;j&lt;n;j++) vis[i][j]=0;\tif (vis[x][y]==0 &amp;&amp; map[x][y]!=0) &#123; vis[x][y]=1; num=1; max1=dfs(x,y);\t&#125;\tprintf(&quot;所在岛屿面积为:%d &quot;,max1); return 0;&#125; 运行截图"},{"title":"JAVA面向对象三大特征--封装","path":"/posts/1511018263/","content":"JAVA面向对象三大特征—封装封装是面向对象编程中的三大特征之一，在对封装性进行解释时我们有必要先了解一些面向对象的思想，以及相关的概念。当我们想要去描述一系列的关系时我们要用到的最基本结构就是类，其中存在着成员变量和方法，用于记录属性和表达行为。 一、名词解读为了解释封装的概念和作用，需要先来了解一下几个相关的概念，这有助于我们接下来的理解。 1.权限修饰符当我们在一个类中定义成员变量时，会指定一个变量的类型，除此之外，还会有修饰符的部分，在此给出定义成员变量的规范格式： 123// 定义变量[修饰符] 变量类型 变量名称;[修饰符] 变量类型 变量名称 = 初始值; 修饰符起到的作用从字面就可以解释，起到一个修饰和限定的作用，可以使用在成员变量之前的修饰符可以是：public、protected、private、final、static。修饰符与修饰符之间的顺序没有强制要求，其中public、protected、private被称为权限修饰符，可以用来限定类的属性和方法的访问权限，指明在哪些包的哪些类中能够调用到这些属性或方法，是一种一定会存在的修饰符。需要注意的是，这三个单词不能同时出现，当这三个单词都不出现的时候会被认为是默认访问权限，所以权限修饰符一共有四种：private、默认、protected、public。 2.权限对应关系表 private：私有权限，只能在定义的类中访问，在其他类中创建的实例均无法访问 默认：同包可访问权限，在没有声明权限修饰符时为默认权限，允许在同包的其他类访问 protected：受保护权限，允许有继承关系的子类访问 public：公共权限，允许任何类访问 3.属性访问由于权限修饰符在封装特性中的作用只是实现封装性的一种途径，所以在这里只演示private与public的作用，权限修饰符的其他作用将在后续的文章中继续介绍。 1234567src└──edu └──sandtower └──bean │ Person.java └──test │ Test.java 以上为实体类与测试类所在的目录结构，Person实体类所在包：edu.sandtower.bean，Test测试类所在包：edu.sandtower.test，相应代码如下： 123456789package edu.sandtower.bean;public class Person&#123; // 声明公开属性 public String name; // 声明私有属性 private double money;&#125; 123456789101112package edu.sandtower.test;import edu.sandtower.bean.Person;public class Test&#123; public static void main(String[] args)&#123; // 在test包中的Test类中创建Person实例 Person person = new Person(); person.name = &quot;小张&quot;;// 编译通过，可以访问name属性 person.money = 500.0;// 编译失败，无法访问money属性 &#125;&#125; 从上面的例子可以看出，虽然依然是使用Person自己的实例在进行属性的调用，但是我们是在另外一个包中的类发生的调用，所以是不能够访问到private修饰的属性的，在刚开始学习时一定要注意区分。 二、概念阐释1.封装有什么用通过使用权限修饰符，我们可以限定类的成员的被访问权限，那为什么要这样做呢？在很多场景下，我们需要确保我们对属性值的操作均是有效操作，不能违背某些规则。比如，我们定义了一个Person类，具有name和money两个属性，在买东西时需要扣掉相应的金额，原始写法如下： 1234public class Person&#123; public String name; public double money;&#125; 1234567891011public class Test&#123; public static void main(String[] args)&#123; Person person = new Person(); person.money = 500;// 初始金额500元 System.out.println(&quot;购买一张桌子，花费200元&quot;); person.money -= 200; System.out.println(&quot;购买二手PSP，花费350元&quot;); person.money -= 350; System.out.println(&quot;目前余额为：&quot; + person.money);// -50 &#125;&#125; 可以看到，经过代码操作以后可能会导致money的属性为负。看官甲：你自己不加判断赖代码？没错，这个问题我们可以增加判断代码来解决，由于这个操作是对money属性值的操作，我们将它封装成一个方法写在实体类中，于是有了改进之后的代码： class Person{ &#96;public String name; public double money; // 定义一个方法，用于设置money属性的值 public void setMoney(double money)&#123; if(money &gt;= 0)&#123; this.money = money; &#125; &#125; }&#96;&#96;&#96; class Test&#123;123456789101112131415161718 public static void main(String[] args)&#123; Person person = new Person(); person.money = 500;// 初始金额500元 System.out.println(&quot;购买一张桌子，花费200元&quot;); person.setMoney(person.money - 200); System.out.println(&quot;购买二手PSP，花费350元&quot;); person.setMoney(person.money - 350); System.out.println(&quot;目前余额为：&quot; + person.money);// 300 &#125;&#125;```经过上面的改进，我们可以确保money的值不为负数，同时可以看到，当在实体类中定义方法后，使用者需要修改属性值时直接调用方法就可以保证不出问题。但是由于属性值依然可以被直接访问，还不能保证万无一失，于是我们利用权限修饰符使得变量不能被直接访问，同时需要定义一个能够取得属性值的方法。`public class Person\\&#123; public String name; // 声明money属性为private权限 private double money; &#x2F;&#x2F; 定义一个方法，用于设置money属性的值public void setMoney(double money){ if(money &gt;&#x3D; 0){ this.money &#x3D; money; }}&#x2F;&#x2F; 定义一个方法，用于获取money属性的值public double getMoney(){ return this.money;} 1234\\&#125;```none public class Test{ public static void main(String[] args){ Person person &#x3D; new Person(); person.setMoney(500);&#x2F;&#x2F; 初始金额500元，此时已经不能使用对象.属性的方法赋值 System.out.println(“购买一张桌子，花费200元”); person.setMoney(person.getMoney() - 200); System.out.println(“购买二手PSP，花费350元”); person.setMoney(person.getMoney() - 300); System.out.println(“目前余额为：” + person.getMoney());&#x2F;&#x2F; 300 }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354通过以上的案例，我们可以看到进行封装有以下几个作用：防止类的属性被外部代码随意的修改和访问，保证数据的完备性 将对属性的操作转换为方法，更加灵活和安全 使用封装可以隐藏实现的细节：使用者只需要作用，不需要知道过程 在类的定义结构中修改，提高了代码的可维护性，同时又可以不影响外部的使用 通过封装方法可以有效减少耦合 耦合：模块与模块之间，代码与代码之间的关联程度，对属性封装后，和调用相关的代码就会变得相对简单，可以降低耦合### 2.如何进行封装在进行封装时都是出于对属性保护的考虑，可以按照以下两个步骤来进行：使用权限修饰符 使用private作用在属性上，关闭直接访问的入口 使用public作用在方法上，提供调用的入口 定义与属性存取相关的方法 在属性关闭后，我们需要通过方法来获取属性的值以及对属性值进行修改。由于有了方法结构，我们就可以对存入的数据进行判断，对不符合逻辑的数据进行处理。### 3.常规封装方法明白了封装的作用后，我们可以通过自定义方法的方式完成对属性的封装。封装方法和类中定义的其他方法在结构上没有任何的区别，同样都是普通的方法，区别主要在于体现在用途方面：普通方法主要表达该类所能产生的行为 封装方法主要为属性的访问和使用提供了一个入口，作用相对单一 在进入到框架的学习之后，很多对实体类属性自动赋值的操作都是通过调用封装方法实现的，所以我们必须要知道常规封装方法的名称定义和类型设置规则。 对于属性来说我们只会进行两种操作：存和取。那么相应的封装方法应该有一对儿get代表取用：既然是取值，那么就要把属性值进行返回，方法的返回值类型与属性类型相同 set代表存储：既然是存值，那么就要在参数列表中接收想要存入的值，类型与属性类型相同 对于命名方面只要遵从驼峰命名法就好，以get或set开头，大写属性名称的首字母，其余不变，看下面一个例子：```nonepublic class Person&#123; // 使用private声明属性 private String name; private double money; // 使用public声明方法，作为操作属性的入口 public void setName(String name)&#123; this.name = name; &#125; public String getName()&#123; return this.name; &#125; public void setMoney(double money)&#123; // 如有需要，可以在方法中可以自定义其他逻辑 this.money = money; &#125; public double getMoney()&#123; return this.money; &#125;&#125; 由于常规封装方法定义的格式和名称都相对固定，所以一般的编译器都自带自动生成封装方法的功能，这样既方便又能降低出错率，大家一定要掌握。 Eclipse： 属性定义完成后，选择source菜单 -&gt; Generate Getters and Setters… 点击Select All（选择所有属性） -&gt; Generate"},{"title":"Maven的下载与环境配置(Windows)","path":"/posts/896528036/","content":"Maven的下载与环境配置(Windows)一、Maven的主要内容 二、Maven的简介Maven[‘meven]这个词可以翻译为”专家”内行”。作为Apache组织中的一个颇为成功的开源项目，Maven主要服务于基于java平台的项目构建，依赖管理和项目信息管理。 无论是小型的开源类库项目，还是大型的企业级应用;无论是传统的瀑布式开发，还是流行的敏捷开发，Maven都能大显身手。 本文将教你掌握Maven的安装以及配置方法。 三、Maven的下载在maven的官网可以下载，点击跳转maven官网下载页选择Files-&gt;Link-&gt;apache-maven-3.x.x-bin.zip点击下载即可。下载解压后，文件目录结构如下： 四、Maven常用配置！！！在配置之前请务必将JDK安装好。 1.环境变量配置选择此电脑（右键）--&gt; 属性 \\--&gt; 高级系统设置进入如下页面：新手注意这里分为用户变量和系统变量，对于一台电脑（系统）来说，你是使用它的用户，而同一台电脑可以被另外一个用户使用，所以当更换用户时，你在用户变量配置的环境就消失了，为了方便使用，我们一般将环境变量全部配置在系统变量下，如图所示：点击新建后我们添加Maven的HOME（在后文解释为什么要建立HOME）在变量名一栏中输入MAVEN_HOME在变量值中输入maven的解压的地址，我使用的是自己文件的解压地址，请你换成你自己的,获取解压地址的方法如下：如图复制了之后在变量值中填入D:\\Workspace\\Maven\\apache-maven-3.8.3-bin\\apache-maven-3.8.3(替换成你自己的) 编辑Path接下来编辑Path，配置Path的目的是，当在cmd输入指令的时候，系统会在Path中寻找你的指令是否存在，所以配置Path的步骤最为关键在编辑界面中添加%MAVEN_HOME%\\bin 注：其实前面的HOME不配置都可以，只要把在Path中的%MAVEN_HOME%\\bin换成变量值\\bin是一样的，只不过变量值的路径一般都很长，为了增加可读性，我们会建立一个HOME 测试win+r输入cmd回车在cmd窗口输入mvn -v查看显示如下即为安装成功： 2.修改配置文件通常我们需要修改解压目录下conf/settings.xml文件，这样可以更好的适合我们的使用。 此处注意：所有的修改一定要在注释标签外面，不然修改无效。Maven很多标签都是给的例子，都是注释掉的。 文末附上我的整个Settings.xml文件配置。 本地仓库位置的修改 在标签内添加自己的本地位置路径 1234567 &lt;!-- localRepository | The path to the local repository maven will use to store artifacts. | | Default: $&#123;user.home&#125;/.m2/repository &lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt; --&gt;&lt;localRepository&gt;D:\\tools\\repository&lt;/localRepository&gt; 修改maven默认的JDK版本 在标签下添加一个标签，修改maven默认的JDK版本。 123456789101112&lt;profile&gt; &lt;id&gt;JDK-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;/profile&gt; 添加国内镜像源 添加标签下，添加国内镜像源，这样下载jar包速度很快。默认的中央仓库有时候甚至连接不通。一般使用阿里云镜像库即可。这里我就都加上了，Maven会默认从这几个开始下载，没有的话就会去中央仓库了。 1234567891011121314151617181920212223&lt;!-- 阿里云仓库 --&gt;&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt;&lt;/mirror&gt;&lt;!-- 中央仓库1 --&gt;&lt;mirror&gt; &lt;id&gt;repo1&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://repo1.maven.org/maven2/&lt;/url&gt;&lt;/mirror&gt;&lt;!-- 中央仓库2 --&gt;&lt;mirror&gt; &lt;id&gt;repo2&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://repo2.maven.org/maven2/&lt;/url&gt;&lt;/mirror&gt; 五、常用IDE下配置Maven目前常用的开发工具如idea，eclipse都自身集成了一个版本的Maven。但是通常我们使用自己已经配置好的Maven。 IDEA下配置Maven跟着图片选择然后1：此处修改为自己解压的Maven目录 2：勾选Override，修改为自己目录下的settings.xml目录 3：修改为自己的本地仓库地址，一般会自动识别。 此处勾选，当修改pom文件时，Maven就能帮我们自动导包了。 Eclipse下配置Maven将eclipse使用的Maven修改为自己的。点击add后选择自己Maven的安装目录即可。添加好之后记得勾选。将所有的settings修改为自己Maven目录下的conf&#x2F;settings.xml.点击Update Settings按钮，下面的Local Respository会自动识别出来。 附：完整的Settings.xml文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!--Licensed to the Apache Software Foundation (ASF) under oneor more contributor license agreements. See the NOTICE filedistributed with this work for additional informationregarding copyright ownership. The ASF licenses this fileto you under the Apache License, Version 2.0 (the&quot;License&quot;); you may not use this file except in compliancewith the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing,software distributed under the License is distributed on an&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANYKIND, either express or implied. See the License for thespecific language governing permissions and limitationsunder the License.--&gt;&lt;!-- | This is the configuration file for Maven. It can be specified at two levels: | | 1. User Level. This settings.xml file provides configuration for a single user, | and is normally provided in $&#123;user.home&#125;/.m2/settings.xml. | | NOTE: This location can be overridden with the CLI option: | | -s /path/to/user/settings.xml | | 2. Global Level. This settings.xml file provides configuration for all Maven | users on a machine (assuming they&#x27;re all using the same Maven | installation). It&#x27;s normally provided in | $&#123;maven.conf&#125;/settings.xml. | | NOTE: This location can be overridden with the CLI option: | | -gs /path/to/global/settings.xml | | The sections in this sample file are intended to give you a running start at | getting the most out of your Maven installation. Where appropriate, the default | values (values used when the setting is not specified) are provided. | |--&gt;&lt;settings xmlns=&quot;http://maven.apache.org/SETTINGS/1.2.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.2.0 https://maven.apache.org/xsd/settings-1.2.0.xsd&quot;&gt; &lt;!-- localRepository | The path to the local repository maven will use to store artifacts. | | Default: $&#123;user.home&#125;/.m2/repository &lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt; --&gt; &lt;localRepository&gt;D:\\tools\\repository&lt;/localRepository&gt; &lt;!-- interactiveMode | This will determine whether maven prompts you when it needs input. If set to false, | maven will use a sensible default value, perhaps based on some other setting, for | the parameter in question. | | Default: true &lt;interactiveMode&gt;true&lt;/interactiveMode&gt; --&gt; &lt;!-- offline | Determines whether maven should attempt to connect to the network when executing a build. | This will have an effect on artifact downloads, artifact deployment, and others. | | Default: false &lt;offline&gt;false&lt;/offline&gt; --&gt; &lt;!-- pluginGroups | This is a list of additional group identifiers that will be searched when resolving plugins by their prefix, i.e. | when invoking a command line like &quot;mvn prefix:goal&quot;. Maven will automatically add the group identifiers | &quot;org.apache.maven.plugins&quot; and &quot;org.codehaus.mojo&quot; if these are not already contained in the list. |--&gt; &lt;pluginGroups&gt; &lt;!-- pluginGroup | Specifies a further group identifier to use for plugin lookup. &lt;pluginGroup&gt;com.your.plugins&lt;/pluginGroup&gt; --&gt; &lt;/pluginGroups&gt; &lt;!-- proxies | This is a list of proxies which can be used on this machine to connect to the network. | Unless otherwise specified (by system property or command-line switch), the first proxy | specification in this list marked as active will be used. |--&gt; &lt;proxies&gt; &lt;!-- proxy | Specification for one proxy, to be used in connecting to the network. | &lt;proxy&gt; &lt;id&gt;optional&lt;/id&gt; &lt;active&gt;true&lt;/active&gt; &lt;protocol&gt;http&lt;/protocol&gt; &lt;username&gt;proxyuser&lt;/username&gt; &lt;password&gt;proxypass&lt;/password&gt; &lt;host&gt;proxy.host.net&lt;/host&gt; &lt;port&gt;80&lt;/port&gt; &lt;nonProxyHosts&gt;local.net|some.host.com&lt;/nonProxyHosts&gt; &lt;/proxy&gt; --&gt; &lt;/proxies&gt; &lt;!-- servers | This is a list of authentication profiles, keyed by the server-id used within the system. | Authentication profiles can be used whenever maven must make a connection to a remote server. |--&gt; &lt;servers&gt; &lt;!-- server | Specifies the authentication information to use when connecting to a particular server, identified by | a unique name within the system (referred to by the &#x27;id&#x27; attribute below). | | NOTE: You should either specify username/password OR privateKey/passphrase, since these pairings are | used together. | &lt;server&gt; &lt;id&gt;deploymentRepo&lt;/id&gt; &lt;username&gt;repouser&lt;/username&gt; &lt;password&gt;repopwd&lt;/password&gt; &lt;/server&gt; --&gt; &lt;!-- Another sample, using keys to authenticate. &lt;server&gt; &lt;id&gt;siteServer&lt;/id&gt; &lt;privateKey&gt;/path/to/private/key&lt;/privateKey&gt; &lt;passphrase&gt;optional; leave empty if not used.&lt;/passphrase&gt; &lt;/server&gt; --&gt; &lt;/servers&gt; &lt;!-- mirrors | This is a list of mirrors to be used in downloading artifacts from remote repositories. | | It works like this: a POM may declare a repository to use in resolving certain artifacts. | However, this repository may have problems with heavy traffic at times, so people have mirrored | it to several places. | | That repository definition will have a unique id, so we can create a mirror reference for that | repository, to be used as an alternate download site. The mirror site will be the preferred | server for that repository. |--&gt; &lt;mirrors&gt; &lt;!-- mirror | Specifies a repository mirror site to use instead of a given repository. The repository that | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used | for inheritance and direct lookup purposes, and must be unique across the set of mirrors. | &lt;mirror&gt; &lt;id&gt;mirrorId&lt;/id&gt; &lt;mirrorOf&gt;repositoryId&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://my.repository.com/repo/path&lt;/url&gt; &lt;/mirror&gt; --&gt; &lt;mirror&gt; &lt;id&gt;maven-default-http-blocker&lt;/id&gt; &lt;mirrorOf&gt;external:http:*&lt;/mirrorOf&gt; &lt;name&gt;Pseudo repository to mirror external repositories initially using HTTP.&lt;/name&gt; &lt;url&gt;http://0.0.0.0/&lt;/url&gt; &lt;blocked&gt;true&lt;/blocked&gt; &lt;/mirror&gt; &lt;!-- 闃块噷浜戜粨搴?--&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt; &lt;/mirror&gt; &lt;!-- 涓ぎ浠撳簱1 --&gt; &lt;mirror&gt; &lt;id&gt;repo1&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://repo1.maven.org/maven2/&lt;/url&gt; &lt;/mirror&gt; &lt;!-- 涓ぎ浠撳簱2 --&gt; &lt;mirror&gt; &lt;id&gt;repo2&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://repo2.maven.org/maven2/&lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt; &lt;!-- profiles | This is a list of profiles which can be activated in a variety of ways, and which can modify | the build process. Profiles provided in the settings.xml are intended to provide local machine- | specific paths and repository locations which allow the build to work in the local environment. | | For example, if you have an integration testing plugin - like cactus - that needs to know where | your Tomcat instance is installed, you can provide a variable here such that the variable is | dereferenced during the build process to configure the cactus plugin. | | As noted above, profiles can be activated in a variety of ways. One way - the activeProfiles | section of this document (settings.xml) - will be discussed later. Another way essentially | relies on the detection of a system property, either matching a particular value for the property, | or merely testing its existence. Profiles can also be activated by JDK version prefix, where a | value of &#x27;1.4&#x27; might activate a profile when the build is executed on a JDK version of &#x27;1.4.2_07&#x27;. | Finally, the list of active profiles can be specified directly from the command line. | | NOTE: For profiles defined in the settings.xml, you are restricted to specifying only artifact | repositories, plugin repositories, and free-form properties to be used as configuration | variables for plugins in the POM. | |--&gt; &lt;profiles&gt; &lt;profile&gt; &lt;id&gt;JDK-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;!-- profile | Specifies a set of introductions to the build process, to be activated using one or more of the | mechanisms described above. For inheritance purposes, and to activate profiles via &lt;activatedProfiles/&gt; | or the command line, profiles have to have an ID that is unique. | | An encouraged best practice for profile identification is to use a consistent naming convention | for profiles, such as &#x27;env-dev&#x27;, &#x27;env-test&#x27;, &#x27;env-production&#x27;, &#x27;user-jdcasey&#x27;, &#x27;user-brett&#x27;, etc. | This will make it more intuitive to understand what the set of introduced profiles is attempting | to accomplish, particularly when you only have a list of profile id&#x27;s for debug. | | This profile example uses the JDK version to trigger activation, and provides a JDK-specific repo. &lt;profile&gt; &lt;id&gt;jdk-1.4&lt;/id&gt; &lt;activation&gt; &lt;jdk&gt;1.4&lt;/jdk&gt; &lt;/activation&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;jdk14&lt;/id&gt; &lt;name&gt;Repository for JDK 1.4 builds&lt;/name&gt; &lt;url&gt;http://www.myhost.com/maven/jdk14&lt;/url&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;snapshotPolicy&gt;always&lt;/snapshotPolicy&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;/profile&gt; --&gt; &lt;!-- | Here is another profile, activated by the system property &#x27;target-env&#x27; with a value of &#x27;dev&#x27;, | which provides a specific path to the Tomcat instance. To use this, your plugin configuration | might hypothetically look like: | | ... | &lt;plugin&gt; | &lt;groupId&gt;org.myco.myplugins&lt;/groupId&gt; | &lt;artifactId&gt;myplugin&lt;/artifactId&gt; | | &lt;configuration&gt; | &lt;tomcatLocation&gt;$&#123;tomcatPath&#125;&lt;/tomcatLocation&gt; | &lt;/configuration&gt; | &lt;/plugin&gt; | ... | | NOTE: If you just wanted to inject this configuration whenever someone set &#x27;target-env&#x27; to | anything, you could just leave off the &lt;value/&gt; inside the activation-property. | &lt;profile&gt; &lt;id&gt;env-dev&lt;/id&gt; &lt;activation&gt; &lt;property&gt; &lt;name&gt;target-env&lt;/name&gt; &lt;value&gt;dev&lt;/value&gt; &lt;/property&gt; &lt;/activation&gt; &lt;properties&gt; &lt;tomcatPath&gt;/path/to/tomcat/instance&lt;/tomcatPath&gt; &lt;/properties&gt; &lt;/profile&gt; --&gt; &lt;/profiles&gt; &lt;!-- activeProfiles | List of profiles that are active for all builds. | &lt;activeProfiles&gt; &lt;activeProfile&gt;alwaysActiveProfile&lt;/activeProfile&gt; &lt;activeProfile&gt;anotherAlwaysActiveProfile&lt;/activeProfile&gt; &lt;/activeProfiles&gt; --&gt;&lt;/settings&gt;"},{"title":"用JAVA实现银行家算法","path":"/posts/56575920/","content":"用Java实现银行家算法实验目的银行家算法是避免死锁的一种重要方法，本实验要求用高级语言编写和调试一个简单的银行家算法程序。加深了解有关资源申请、避免死锁等概念，并体会和了解死锁和避免死锁的具体实施方法。 实验内容1)设计进程对各类资源最大申请表示及初值确定。2)设定系统提供资源初始状况。3)设定每次某个进程对各类资源的申请表示。4)编制程序，依据银行家算法，决定其申请是否得到满足。 代码解释Banker类-T0时刻资源分配进行变量定义：对进程数量M，资源种类数量N，各资源总数All[]，m个进程对n类资源的最大需求量Max[][]，m个进程已经得到n类资源的资源量Allocation[][],m个进程还需要n类资源的资源量Need[][],系统可用资源数系统可用资源数Available[][]。还有一个进程完成标志位Finish[]。 12345678910111213class Banker&#123;\tint ID[], //进程代号 M, //m个进程 N, //n类资源 All[], //系统各资源数量 Max[][], //m个进程对n类资源的最大需求量 Allocation[][],\t//m个进程已经得到n类资源的资源量 Need[][], //m个进程还需要n类资源的资源量 Available[][];\t//系统可用资源数 boolean Finish[];\t//标记进程是否完成\tint a=0;//Available的第一个下标 无参构造函数：在无参函数中进行变量的初始化，需要手动输入的变量为M,N，All[]，Max[][]，Allocation[][]。当输入了初始值后，Need[][]和Available[][]就可以通过need 的计算公式：Need&#x3D;[i][j]&#x3D; Max[i][j]- Allocation[i][j]Available[][]：Available[a][n] &#x3D; All[n] - Allocation[m][n]（遍历） 1234567891011121314151617181920212223242526272829303132public Banker() &#123;\t//无参构造器 @SuppressWarnings(&quot;resource&quot;) Scanner input = new Scanner(System.in); System.out.println(&quot;请输入进程数&quot;); M = input.nextInt();//m个进程 System.out.println(&quot;请输入资源种类数&quot;); N = input.nextInt();//n类资源 //初始化数组 ID = new int[M]; //进程代号 All = new int[N]; //系统各资源数量 Max = new int[M][N]; //m个进程对n类资源的最大需求量 Allocation = new int[M][N];\t//m个进程已经得到n类资源的资源量 Need = new int[M][N]; //m个进程还需要n类资源的资源量 Available = new int[M+1][N]; //系统可用资源数 Finish = new boolean[M];\t//标记进程是否完成 System.out.println(&quot;请输入系统初始可用资源数&quot;); for(int i=0; i&lt;N; i++)//系统初始可用资源数 All[i] = input.nextInt(); System.out.println(&quot;请输入&quot;+M+&quot;个进程对&quot;+N+&quot;类资源的最大需求量&quot;); for(int i=0; i&lt;M; i++)&#123;//m个进程对n类资源的最大需求量 ID[i] = i; for(int j=0; j&lt;N; j++) Max[i][j] = input.nextInt(); &#125; System.out.println(&quot;请输入&quot;+M+&quot;个进程已经得到的&quot;+N+&quot;类资源的资源量&quot;); for(int i=0; i&lt;M; i++)\t//m个进程已经得到n类资源的资源量 for(int j=0; j&lt;N; j++) Allocation[i][j] = input.nextInt(); Need_Resources(); Available_Resources(); Print_Banker();\t&#125; 初始化Need和Available矩阵： 12345678910111213141516private void Need_Resources() &#123;//初始化Need矩阵 // TODO Auto-generated method stub for(int i=0; i&lt;M; i++)//m个进程还需要n类资源的资源量 for(int j=0; j&lt;N; j++) Need[i][j] = Max[i][j] - Allocation[i][j];\t&#125;\tprivate void Available_Resources() &#123;//更新系统当前可用资源数 // TODO Auto-generated method stub for(int n=0; n&lt;N; n++)&#123;//系统目前可用资源数 Available[a][n] = All[n]; for(int m=0; m&lt;M; m++)&#123; Available[a][n] -= Allocation[m][n]; &#125; &#125;\t&#125; 就此，所有矩阵初始化完毕，对T0时刻的资源分配图进行打印，如图所示： 1234567891011121314151617181920212223242526272829303132private void Print_Banker() &#123;//T0时刻的资源分配图 System.out.println(&quot; T0时刻资源分配图：&quot;); System.out.print(&quot;资源\\t资源数量 &quot;); for(int i=0; i&lt;N; i++) System.out.printf(&quot;S%d\\t%d &quot;, i, All[i]); System.out.print(&quot; 进程\\t Max\\tAllocation\\tNeed\\tAvailable\\tFinish &quot;); for(int i=0; i&lt;M; i++)&#123; System.out.print(&quot;P&quot;+ID[i]); System.out.print(&quot;\\t&quot;); for(int j=0; j&lt;Max[ID[i]].length; j++)&#123; System.out.printf(&quot;%d &quot;, Max[ID[i]][j]); &#125; System.out.print(&quot;\\t&quot;); for(int j=0; j&lt;Allocation[ID[i]].length; j++)&#123; System.out.printf(&quot;%d &quot;, Allocation[ID[i]][j]); &#125; System.out.print(&quot;\\t\\t&quot;); for(int j=0; j&lt;Need[ID[i]].length; j++)&#123; System.out.printf(&quot;%d &quot;, Need[ID[i]][j]); &#125; System.out.print(&quot;\\t&quot;); if(i == 0)&#123; for(int j=0; j&lt;N; j++)&#123; System.out.printf(&quot;%d &quot;, Available[i][j]); &#125; &#125; System.out.print(&quot;\\t&quot;); System.out.print(&quot;\\t&quot;); System.out.print(Finish[i]); System.out.println(); &#125;\t&#125; 安全性检查对T0时刻资源分配情况进行安全性分析，为每个进程进行可满足性检查。Need[i][j] &gt; Available[a][j]遍历每个资源，都满足可满足性，则进入试分配，若不满足，将该进程的标志位flag2置为false，跳出for循环。试分配，先将进程的Finish标志位置为true，代表这个进程已经被分配资源执行完毕。更新Available：Available[a][j] &#x3D; Available[a-1][j] + Allocation[i][j];当所有进程都通过试分配(a &#x3D;&#x3D; M)后，打印分配过资源的安全序列Print_Banker_Se() 12345678910111213141516171819202122232425262728293031323334353637public void Security_examine()&#123;//安全性检测 boolean flag1,\t//所有进程 flag2;\t//每个进程 flag1 = true; while(flag1)&#123; flag1 = false; for(int i=0; i&lt;M; i++)&#123; flag2 = true; for(int j=0; flag2 &amp;&amp; j&lt;N; j++)&#123; if(Need[i][j] &gt; Available[a][j] || Finish[i])&#123;//存在一个条件不满足或者该进程已经完成 flag2 = false; &#125; &#125; if(flag2 &amp;&amp; !Finish[i])&#123;//该进程（第i个进程）可执行 flag1 = true; Finish[i] = true; ID[a] = i; a++;//以此判断所有进程是否都执行，安全检查 for(int j=0; flag2 &amp;&amp; j&lt;N; j++)&#123; Available[a][j] = Available[a-1][j] + Allocation[i][j]; &#125; &#125; &#125; &#125; System.out.println(&quot; T0时刻的安全性：&quot;); if(a == M)&#123; Print_Banker_Se(); System.out.println(&quot; 安全序列：&quot;); for(int i=0; i&lt;M; i++)&#123; System.out.print(&quot;-&gt;P&quot;+ID[i]); &#125; System.out.println(&quot; &quot;); &#125; else&#123; System.out.println(&quot;系统不安全&quot;); &#125;\t&#125; Banker类-银行家算法申请资源：某个进程发起请求向量Request(,,*)，系统按银行家算法进行检查。① Request[i] &gt; Need[n][i]② Request[i] &gt; Available[0][i]满足以上两条说明不满足正确性检查和可满足性检查，将标志位flag置为false，报告分配不安全。若通过了正确性和可满足性检测就将这条进程的已分配Allocation加上申请量，并重新对Need和Available矩阵进行新的初始化。并打印此时初状态资源分配表。 安全性检查：通过主程序调用键盘输入控制进入安全性检查部分，思想和源码与T0时刻的安全性检查雷同，再次不在赘述。安全性检查 123456789101112131415161718192021222324252627282930313233343536public void Reallocation()&#123;//申请资源 @SuppressWarnings(&quot;resource&quot;) Scanner input = new Scanner(System.in); int[] Request = new int[N]; boolean flag = true; System.out.print(&quot; 输入进程代号：&quot;); int n = input.nextInt(); System.out.print(&quot;输入请求资源数：&quot;); for(int j=0; j&lt;N; j++) Request[j] = input.nextInt(); for(int i=0; i&lt;N; i++)&#123;//合理性检查,可用性检查 if(Request[i] &gt; Need[n][i] || Request[i] &gt; Available[0][i]) flag = false; &#125; if(flag)&#123; for(int i=0; i&lt;N; i++)&#123; Allocation[n][i] += Request[i]; &#125; Init(); Print_Banker(); &#125; else&#123; System.out.println(&quot;分配不安全 &quot;); &#125; &#125;\tprivate void Init() &#123; // TODO Auto-generated method stub a = 0; Need_Resources();//再次初始化 Available_Resources(); for(int i=0; i&lt;M; i++)&#123;//ID初始化 ID[i] = i; Finish[i] = false; &#125;\t&#125; 主函数使用无参构造器new了一个banker对象，打印菜单，并控制调用安全性检测、银行家算法（请求再分配资源）以及退出。 1234567891011121314151617181920212223public class TestBankerClass &#123;\tpublic static void main(String[] args) &#123; // TODO Auto-generated method stub Banker banker = new Banker(); int n; boolean flag=true; Scanner input = new Scanner(System.in); System.out.println(&quot; *************菜单****************&quot;); System.out.println(&quot;进行安全性检查：1 请求再分配资源：2 退出：其他&quot;); System.out.println(&quot;*********************************&quot;); while(flag)&#123; System.out.print(&quot;输入操作代号：&quot;); n = input.nextInt(); switch(n)&#123; case 1:\tbanker.Security_examine();break; case 2:\tbanker.Reallocation();break; default:flag = false; System.out.print(&quot; 操作结束！！！！&quot;); &#125; &#125; input.close();//关闭流\t&#125;&#125; 输入示例例1： 1234567891011121314151617181920212223242526初始化：5310 5 77 5 33 2 29 0 22 2 24 3 30 1 02 0 03 0 22 1 10 0 2再分配：11 0 243 3 000 2 0 例2： 123456789101112131415161718初始化：3310 8 78 7 55 2 56 6 23 2 02 0 21 3 2再分配：01 0 010 1 1 运行结果例1： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107T0时刻资源分配图：资源\t资源数量S0\t10S1\t5S2\t7进程 Max\tAllocation\tNeed\tAvailable\tFinishP0\t7 5 3 0 1 0 7 4 3 3 3 2 falseP1\t3 2 2 2 0 0 1 2 2 falseP2\t9 0 2 3 0 2 6 0 0 falseP3\t2 2 2 2 1 1 0 1 1 falseP4\t4 3 3 0 0 2 4 3 1 false*************菜单****************进行安全性检查：1请求再分配资源：2退出：其他*********************************输入操作代号：1T0时刻的安全性：进程 Work\tNeed\tAllocation\tWork+Allocation\tFinishP1\t3 3 2 1 2 2 2 0 0 5 3 2 trueP3\t5 3 2 0 1 1 2 1 1 7 4 3 trueP4\t7 4 3 4 3 1 0 0 2 7 4 5 trueP0\t7 4 5 7 4 3 0 1 0 7 5 5 trueP2\t7 5 5 6 0 0 3 0 2 10 5 7 true安全序列：-&gt;P1-&gt;P3-&gt;P4-&gt;P0-&gt;P2输入操作代号：2输入进程代号：1输入请求资源数：1 0 2T0时刻资源分配图：资源\t资源数量S0\t10S1\t5S2\t7进程 Max\tAllocation\tNeed\tAvailable\tFinishP0\t7 5 3 0 1 0 7 4 3 2 3 0 falseP1\t3 2 2 3 0 2 0 2 0 falseP2\t9 0 2 3 0 2 6 0 0 falseP3\t2 2 2 2 1 1 0 1 1 falseP4\t4 3 3 0 0 2 4 3 1 false输入操作代号：1T0时刻的安全性：进程 Work\tNeed\tAllocation\tWork+Allocation\tFinishP1\t2 3 0 0 2 0 3 0 2 5 3 2 trueP3\t5 3 2 0 1 1 2 1 1 7 4 3 trueP4\t7 4 3 4 3 1 0 0 2 7 4 5 trueP0\t7 4 5 7 4 3 0 1 0 7 5 5 trueP2\t7 5 5 6 0 0 3 0 2 10 5 7 true安全序列：-&gt;P1-&gt;P3-&gt;P4-&gt;P0-&gt;P2输入操作代号：2输入进程代号：4输入请求资源数：3 3 0分配不安全输入操作代号：1T0时刻的安全性：进程 Work\tNeed\tAllocation\tWork+Allocation\tFinishP1\t2 3 0 0 2 0 3 0 2 5 3 2 trueP3\t5 3 2 0 1 1 2 1 1 7 4 3 trueP4\t7 4 3 4 3 1 0 0 2 7 4 5 trueP0\t7 4 5 7 4 3 0 1 0 7 5 5 trueP2\t7 5 5 6 0 0 3 0 2 10 5 7 true安全序列：-&gt;P1-&gt;P3-&gt;P4-&gt;P0-&gt;P2输入操作代号：2输入进程代号：0输入请求资源数：0 2 0T0时刻资源分配图：资源\t资源数量S0\t10S1\t5S2\t7进程 Max\tAllocation\tNeed\tAvailable\tFinishP0\t7 5 3 0 3 0 7 2 3 2 1 0 falseP1\t3 2 2 3 0 2 0 2 0 falseP2\t9 0 2 3 0 2 6 0 0 falseP3\t2 2 2 2 1 1 0 1 1 falseP4\t4 3 3 0 0 2 4 3 1 false输入操作代号：1T0时刻的安全性：系统不安全输入操作代号：4操作结束！！！！ 完整代码TestBankerClass类： 123456789101112131415161718192021222324252627package bankerTest;import java.util.Scanner;public class TestBankerClass &#123;\tpublic static void main(String[] args) &#123; // TODO Auto-generated method stub Banker banker = new Banker(); int n; boolean flag=true; Scanner input = new Scanner(System.in); System.out.println(&quot; *************菜单****************&quot;); System.out.println(&quot;进行安全性检查：1 请求再分配资源：2 退出：其他&quot;); System.out.println(&quot;*********************************&quot;); while(flag)&#123; System.out.print(&quot;输入操作代号：&quot;); n = input.nextInt(); switch(n)&#123; case 1:\tbanker.Security_examine();break; case 2:\tbanker.Reallocation();break; default:flag = false; System.out.print(&quot; 操作结束！！！！&quot;); &#125; &#125; input.close();//关闭流\t&#125;&#125; Banker类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202package bankerTest;import java.util.Scanner;class Banker&#123;\t//定义数组\tint ID[], //进程代号 M, //m个进程 N, //n类资源 All[], //系统各资源数量 Max[][], //m个进程对n类资源的最大需求量 Allocation[][],\t//m个进程已经得到n类资源的资源量 Need[][], //m个进程还需要n类资源的资源量 Available[][];\t//系统可用资源数\tboolean Finish[];\t//标记进程是否完成\tint a=0; //Available的第一个下标\tpublic Banker() &#123;\t//无参构造器 @SuppressWarnings(&quot;resource&quot;)//忽视输入流未关闭的报错 Scanner input = new Scanner(System.in); System.out.println(&quot;请输入进程数&quot;); M = input.nextInt();//m个进程 System.out.println(&quot;请输入资源种类数&quot;); N = input.nextInt();//n类资源 //初始化数组 ID = new int[M]; //进程代号 All = new int[N]; //系统各资源数量 Max = new int[M][N]; //m个进程对n类资源的最大需求量 Allocation = new int[M][N];\t//m个进程已经得到n类资源的资源量 Need = new int[M][N]; //m个进程还需要n类资源的资源量 Available = new int[M+1][N]; //系统可用资源数 Finish = new boolean[M];\t//标记进程是否完成 System.out.println(&quot;请输入系统初始可用资源数&quot;); for(int i=0; i&lt;N; i++)//系统初始可用资源数 All[i] = input.nextInt(); System.out.println(&quot;请输入&quot;+M+&quot;个进程对&quot;+N+&quot;类资源的最大需求量&quot;); for(int i=0; i&lt;M; i++)&#123;//m个进程对n类资源的最大需求量 ID[i] = i; for(int j=0; j&lt;N; j++) Max[i][j] = input.nextInt(); &#125; System.out.println(&quot;请输入&quot;+M+&quot;个进程已经得到的&quot;+N+&quot;类资源的资源量&quot;); for(int i=0; i&lt;M; i++)\t//m个进程已经得到n类资源的资源量 for(int j=0; j&lt;N; j++) Allocation[i][j] = input.nextInt(); Need_Resources(); Available_Resources(); Print_Banker();\t&#125;\tprivate void Need_Resources() &#123;//初始化Need矩阵 // TODO Auto-generated method stub for(int i=0; i&lt;M; i++)//m个进程还需要n类资源的资源量 for(int j=0; j&lt;N; j++) Need[i][j] = Max[i][j] - Allocation[i][j];\t&#125;\tprivate void Available_Resources() &#123;//更新系统当前可用资源数 // TODO Auto-generated method stub for(int n=0; n&lt;N; n++)&#123;//系统目前可用资源数 Available[a][n] = All[n]; for(int m=0; m&lt;M; m++)&#123; Available[a][n] -= Allocation[m][n]; &#125; &#125;\t&#125;\tprivate void Print_Banker() &#123;//T0时刻的资源分配图 System.out.println(&quot; T0时刻资源分配图：&quot;); System.out.print(&quot;资源\\t资源数量 &quot;); for(int i=0; i&lt;N; i++) System.out.printf(&quot;S%d\\t%d &quot;, i, All[i]); System.out.print(&quot; 进程\\t Max\\tAllocation\\tNeed\\tAvailable\\tFinish &quot;); for(int i=0; i&lt;M; i++)&#123; System.out.print(&quot;P&quot;+ID[i]); System.out.print(&quot;\\t&quot;); for(int j=0; j&lt;Max[ID[i]].length; j++)&#123; System.out.printf(&quot;%d &quot;, Max[ID[i]][j]); &#125; System.out.print(&quot;\\t&quot;); for(int j=0; j&lt;Allocation[ID[i]].length; j++)&#123; System.out.printf(&quot;%d &quot;, Allocation[ID[i]][j]); &#125; System.out.print(&quot;\\t\\t&quot;); for(int j=0; j&lt;Need[ID[i]].length; j++)&#123; System.out.printf(&quot;%d &quot;, Need[ID[i]][j]); &#125; System.out.print(&quot;\\t&quot;); if(i == 0)&#123; for(int j=0; j&lt;N; j++)&#123; System.out.printf(&quot;%d &quot;, Available[i][j]); &#125; &#125; System.out.print(&quot;\\t&quot;); System.out.print(&quot;\\t&quot;); System.out.print(Finish[i]); System.out.println(); &#125;\t&#125;\tpublic void Security_examine()&#123;//安全性检测 boolean flag1,\t//所有进程 flag2;\t//每个进程 flag1 = true; while(flag1)&#123; flag1 = false; for(int i=0; i&lt;M; i++)&#123; flag2 = true; for(int j=0; flag2 &amp;&amp; j&lt;N; j++)&#123; if(Need[i][j] &gt; Available[a][j] || Finish[i])&#123;//存在一个条件不满足或者该进程已经完成 flag2 = false; &#125; &#125; if(flag2 &amp;&amp; !Finish[i])&#123;//该进程（第i个进程）可执行 flag1 = true; Finish[i] = true; ID[a] = i; a++;//以此判断所有进程是否都执行，安全检查 for(int j=0; flag2 &amp;&amp; j&lt;N; j++)&#123; Available[a][j] = Available[a-1][j] + Allocation[i][j]; &#125; &#125; &#125; &#125; System.out.println(&quot; T0时刻的安全性：&quot;); if(a == M)&#123; Print_Banker_Se(); System.out.println(&quot; 安全序列：&quot;); for(int i=0; i&lt;M; i++)&#123; System.out.print(&quot;-&gt;P&quot;+ID[i]); &#125; System.out.println(&quot; &quot;); &#125; else&#123; System.out.println(&quot;系统不安全&quot;); &#125;\t&#125; public void Reallocation()&#123;//申请资源 @SuppressWarnings(&quot;resource&quot;) Scanner input = new Scanner(System.in); int[] Request = new int[N]; boolean flag = true; System.out.print(&quot; 输入进程代号：&quot;); int n = input.nextInt(); System.out.print(&quot;输入请求资源数：&quot;); for(int j=0; j&lt;N; j++) Request[j] = input.nextInt(); for(int i=0; i&lt;N; i++)&#123;//合理性检查,可用性检查 if(Request[i] &gt; Need[n][i] || Request[i] &gt; Available[0][i]) flag = false; &#125; if(flag)&#123; for(int i=0; i&lt;N; i++)&#123; Allocation[n][i] += Request[i]; &#125; Init(); Print_Banker(); &#125; else&#123; System.out.println(&quot;分配不安全 &quot;); &#125; &#125;\tprivate void Init() &#123; // TODO Auto-generated method stub a = 0; Need_Resources();//再次初始化 Available_Resources(); for(int i=0; i&lt;M; i++)&#123;//ID初始化 ID[i] = i; Finish[i] = false; &#125;\t&#125;\tprivate void Print_Banker_Se() &#123; System.out.print(&quot; 进程\\t Work\\tNeed\\tAllocation\\tWork+Allocation\\tFinish &quot;); for(int i=0; i&lt;M; i++)&#123; System.out.print(&quot;P&quot;+ID[i]); System.out.print(&quot;\\t&quot;); for(int j=0; j&lt;Available[i].length; j++)&#123; System.out.printf(&quot;%d &quot;, Available[i][j]); &#125; System.out.print(&quot;\\t&quot;); for(int j=0; j&lt;Need[ID[i]].length; j++)&#123; System.out.printf(&quot;%d &quot;, Need[ID[i]][j]); &#125; System.out.print(&quot;\\t&quot;); for(int j=0; j&lt;Allocation[ID[i]].length; j++)&#123; System.out.printf(&quot;%d &quot;, Allocation[ID[i]][j]); &#125; System.out.print(&quot;\\t\\t&quot;); for(int j=0; j&lt;Available[i+1].length; j++)&#123; System.out.printf(&quot;%d &quot;, Available[i+1][j]); &#125; System.out.print(&quot;\\t&quot;); System.out.print(&quot;\\t&quot;); System.out.print(Finish[i]); System.out.println(); &#125;\t&#125;\t&#125;"},{"title":"关于枣糕同学","path":"/about/index.html","content":"本站是枣糕同学的个人站 博主目前在深圳大学计算机与软件学院读研，热衷技术，希望能做出一些更有意思的东西。 后续有作品会发布在本站，希望大家喜欢~ 博主最近在做的事情 生活技术2024 年 10 月 18 日最近本博客的基础完成的差不多了，等域名备案下来，准备把博客部署在服务器上2024 年 9 月 1 日入学深圳大学2024 年 10 月 24 日在 kang 的协助下学会了本地主机和服务器之间的文件传输，但是试图用FTP协议进行文件传输失败了，改成使用SFTP协议进行文件传输，成功了。2024 年 10 月 22 日今天备案成功，顺便研究了一下怎么使用git工具进行分支管理，顺便学习了一下git的一些常用命令，现在已经可以使用git工具进行分支管理了。2024 年 10 月 18 日最近本博客的基础完成的差不多了，等域名备案下来，准备把博客部署在服务器上2021 年 某 月 某 日在 kang 的指导下开始了自己的技术生涯"},{"title":"专栏","path":"/wiki/index.html","content":"本页面还在改进优化中"}]